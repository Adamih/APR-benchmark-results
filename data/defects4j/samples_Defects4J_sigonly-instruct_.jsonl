{"identifier": "Compress-39", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\nindex cd0165fd..0a755ce3 100644\n--- a/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java\n@@ -28,7 +28,6 @@ import org.apache.commons.compress.archivers.ArchiveEntry;\n  */\n public class ArchiveUtils {\n \n-    private static final int MAX_SANITIZED_NAME_LENGTH = 255;\n \n     /** Private constructor to prevent instantiation of this utility class. */\n     private ArchiveUtils(){\n@@ -271,13 +270,7 @@ public class ArchiveUtils {\n      * @since Compress 1.12\n      */\n     public static String sanitize(String s) {\n-        final char[] cs = s.toCharArray();\n-        final char[] chars = cs.length <= MAX_SANITIZED_NAME_LENGTH ? cs : Arrays.copyOf(cs, MAX_SANITIZED_NAME_LENGTH);\n-        if (cs.length > MAX_SANITIZED_NAME_LENGTH) {\n-            for (int i = MAX_SANITIZED_NAME_LENGTH - 3; i < MAX_SANITIZED_NAME_LENGTH; i++) {\n-                chars[i] = '.';\n-            }\n-        }\n+        final char[] chars = s.toCharArray();\n         final int len = chars.length;\n         final StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < len; i++) {\n"}
{"identifier": "Jsoup-42", "buggy_code": "    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (\"select\".equals(el.tagName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val();\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }\n", "fixed_code": "    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (\"select\".equals(el.tagName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/FormElement.java b/src/main/java/org/jsoup/nodes/FormElement.java\nindex a12e353..4ce1190 100644\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n@@ -77,7 +77,6 @@ public class FormElement extends Element {\n         // iterate the form control elements and accumulate their values\n         for (Element el: elements) {\n             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n-            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n             String name = el.attr(\"name\");\n             if (name.length() == 0) continue;\n             String type = el.attr(\"type\");\n@@ -97,7 +96,7 @@ public class FormElement extends Element {\n             } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                 // only add checkbox or radio if they have the checked attribute\n                 if (el.hasAttr(\"checked\")) {\n-                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n+                    final String val = el.val();\n                     data.add(HttpConnection.KeyVal.create(name, val));\n                 }\n             } else {\n"}
{"identifier": "Cli-29", "buggy_code": "    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\"))\n        {\n            str = str.substring(1, str.length());\n        }\n        int length = str.length();\n        if (str.endsWith(\"\\\"\"))\n        {\n            str = str.substring(0, length - 1);\n        }\n        \n        return str;\n    }\n", "fixed_code": "    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n        {\n            str = str.substring(1, length - 1);\n        }\n        \n        return str;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/Util.java b/src/java/org/apache/commons/cli/Util.java\nindex bceee25..40f66f1 100644\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n@@ -62,10 +62,14 @@ class Util\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n+        if (str.startsWith(\"\\\"\"))\n+        {\n+            str = str.substring(1, str.length());\n+        }\n         int length = str.length();\n-        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n+        if (str.endsWith(\"\\\"\"))\n         {\n-            str = str.substring(1, length - 1);\n+            str = str.substring(0, length - 1);\n         }\n         \n         return str;\n"}
{"identifier": "Lang-63", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 3a9d9f6..127b927 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -303,20 +303,25 @@ public class DurationFormatUtils {\n             days -= 1;\n         }\n         while (days < 0) {\n-            end.add(Calendar.MONTH, -1);\n-            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+            days += 31;\n //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n // Also it's contextual - if asked for no M in the format then I should probably \n // be doing no calculating here.\n             months -= 1;\n-            end.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n+        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n@@ -424,6 +429,18 @@ public class DurationFormatUtils {\n         }\n         return buffer.toString();\n     }\n+    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n+        end.add( field, -1 * difference );\n+        int endValue = end.get(field);\n+        int startValue = start.get(field);\n+        if (endValue < startValue) {\n+            int newdiff = startValue - endValue;\n+            end.add( field, newdiff );\n+            return newdiff;\n+        } else {\n+            return 0;\n+        }\n+    }\n \n     static final Object y = \"y\";\n     static final Object M = \"M\";\n"}
{"identifier": "Closure-40", "buggy_code": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n          }\n        }\n      }\n    }\n", "fixed_code": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public void visit(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 6e9e470..088a993 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -632,9 +632,11 @@ final class NameAnalyzer implements CompilerPass {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, true);\n+          JsName name = getName(ns.name, false);\n+          if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n+          }\n         }\n       }\n     }\n"}
{"identifier": "Csv-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 7e9d7d4..1e3106e 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -286,7 +286,6 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n     private final Lexer lexer;\n \n-    private final CSVRecordIterator csvRecordIterator;\n     \n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> recordList = new ArrayList<>();\n@@ -355,7 +354,6 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n         this.format = format;\n         this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n-        this.csvRecordIterator = new CSVRecordIterator();\n         this.headerMap = this.initializeHeader();\n         this.characterOffset = characterOffset;\n         this.recordNumber = recordNumber - 1;\n@@ -522,10 +520,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n      */\n     @Override\n     public Iterator<CSVRecord> iterator() {\n-        return csvRecordIterator;\n-    }\n-    \n-    class CSVRecordIterator implements Iterator<CSVRecord> {\n+        return new Iterator<CSVRecord>() {\n         private CSVRecord current;\n   \n         private CSVRecord getNextRecord() {\n@@ -573,6 +568,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             throw new UnsupportedOperationException();\n         }\n     };\n+    }\n \n     /**\n      * Parses the next record from the current point in the stream.\n"}
{"identifier": "Lang-10", "buggy_code": "    /**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n", "fixed_code": "    /**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 8df302f..a01159b 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -301,8 +301,17 @@ public class FastDateParser implements DateParser, Serializable {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n+        boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n+            if(Character.isWhitespace(c)) {\n+                if(!wasWhite) {\n+                    wasWhite= true;\n+                    regex.append(\"\\\\s*+\");\n+                }\n+                continue;\n+            }\n+            wasWhite= false;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n"}
{"identifier": "Jsoup-30", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/safety/Cleaner.java b/src/main/java/org/jsoup/safety/Cleaner.java\nindex 27af7a7..9e06b9c 100644\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n@@ -3,8 +3,6 @@ package org.jsoup.safety;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.NodeTraversor;\n-import org.jsoup.select.NodeVisitor;\n \n import java.util.List;\n \n@@ -69,17 +67,11 @@ public class Cleaner {\n     /**\n      Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.\n      */\n-    private final class CleaningVisitor implements NodeVisitor {\n-        private int numDiscarded = 0;\n-        private final Element root;\n-        private Element destination; // current element to append nodes to\n-\n-        private CleaningVisitor(Element root, Element destination) {\n-            this.root = root;\n-            this.destination = destination;\n-        }\n+    private int copySafeNodes(Element root, Element destination) {\n+        List<Node> sourceChildren = root.childNodes();\n+        int numDiscarded = 0;\n \n-        public void head(Node source, int depth) {\n+        for (Node source : sourceChildren) {\n             if (source instanceof Element) {\n                 Element sourceEl = (Element) source;\n \n@@ -89,31 +82,20 @@ public class Cleaner {\n                     destination.appendChild(destChild);\n \n                     numDiscarded += meta.numAttribsDiscarded;\n-                    destination = destChild;\n-                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n+                    numDiscarded += copySafeNodes(sourceEl, destChild);\n+                } else {\n                     numDiscarded++;\n+                    numDiscarded += copySafeNodes(sourceEl, destination);\n                 }\n             } else if (source instanceof TextNode) {\n                 TextNode sourceText = (TextNode) source;\n                 TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n                 destination.appendChild(destText);\n-            } else { // else, we don't care about comments, xml proc instructions, etc\n-                numDiscarded++;\n             }\n         }\n+        return numDiscarded;\n \n-        public void tail(Node source, int depth) {\n-            if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) {\n-                destination = destination.parent(); // would have descended, so pop destination stack\n-            }\n-        }\n-    }\n \n-    private int copySafeNodes(Element source, Element dest) {\n-        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n-        NodeTraversor traversor = new NodeTraversor(cleaningVisitor);\n-        traversor.traverse(source);\n-        return cleaningVisitor.numDiscarded;\n     }\n \n     private ElementMeta createSafeElement(Element sourceEl) {\n"}
{"identifier": "Mockito-28", "buggy_code": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n        }\n    }\n", "fixed_code": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n            mocks.remove(injected);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\nindex 846fbf7..213ebf3 100644\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n@@ -90,8 +90,7 @@ public class DefaultInjectionEngine {\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n-            mocks.remove(injected);\n+            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n         }\n     }\n \n"}
{"identifier": "JacksonDatabind-62", "buggy_code": "    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed\n     * for.\n     */\n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        // also, often value deserializer is resolved here:\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        // and finally, type deserializer needs context as well\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }\n", "fixed_code": "    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed\n     * for.\n     */\n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n            if (_valueInstantiator.canCreateUsingDelegate()) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                            +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n                }\n                delegateDeser = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        // also, often value deserializer is resolved here:\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        // and finally, type deserializer needs context as well\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n            valueTypeDeser = valueTypeDeser.forProperty(property);\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed\n     * for.\n     */\n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\nindex 33d8878e3..7f58b7ad8 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n@@ -181,14 +181,6 @@ public class CollectionDeserializer\n                             +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n                 }\n                 delegateDeser = findDeserializer(ctxt, delegateType, property);\n-            } else if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n-                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n-                if (delegateType == null) {\n-                    throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType\n-                            +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n-                            +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n-                }\n-                delegateDeser = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n         // [databind#1043]: allow per-property allow-wrapping of single overrides:\n"}
{"identifier": "Lang-49", "buggy_code": "    /**\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     * \n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     */\n    public Fraction reduce() {\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }\n", "fixed_code": "    /**\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     * \n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     */\n    public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     * \n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     */\n    public Fraction reduce()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/math/Fraction.java b/src/java/org/apache/commons/lang/math/Fraction.java\nindex 3347689..5f8e565 100644\n--- a/src/java/org/apache/commons/lang/math/Fraction.java\n+++ b/src/java/org/apache/commons/lang/math/Fraction.java\n@@ -463,9 +463,6 @@ public final class Fraction extends Number implements Comparable {\n      * @return a new reduced fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n-        if (numerator == 0) {\n-            return equals(ZERO) ? this : ZERO;\n-        }\n         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;\n"}
{"identifier": "Lang-47", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex fd135fd..13281ce 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1183,9 +1183,6 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            if (str == null) {\n-                str = \"\";\n-            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);\n@@ -1230,9 +1227,6 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            if (str == null) {\n-                str = \"\";\n-            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);\n"}
{"identifier": "Cli-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex 08a9280..8f03474 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -125,7 +125,7 @@ public class PosixParser extends Parser {\n             // single hyphen\n             else if (\"-\".equals(token))\n             {\n-                tokens.add(token);\n+                processSingleHyphen(token);\n             }\n             else if (token.startsWith(\"-\"))\n             {\n@@ -210,6 +210,10 @@ public class PosixParser extends Parser {\n             tokens.add(value);\n         }\n     }\n+    private void processSingleHyphen(String hyphen)\n+    {\n+        tokens.add(hyphen);\n+    }\n \n     /**\n      * <p>If an {@link Option} exists for <code>token</code> then\n@@ -234,7 +238,6 @@ public class PosixParser extends Parser {\n         else if (stopAtNonOption)\n         {\n             eatTheRest = true;\n-            tokens.add(token);\n         }\n     }\n \n"}
{"identifier": "Mockito-17", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/creation/MockSettingsImpl.java b/src/org/mockito/internal/creation/MockSettingsImpl.java\nindex 5285d90..bf2cf3b 100644\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n@@ -17,11 +17,9 @@ public class MockSettingsImpl implements MockSettings {\n     private Object spiedInstance;\n     private Answer<Object> defaultAnswer;\n     private MockName mockName;\n-    private boolean serializable;\n \n     public MockSettings serializable() {\n-        this.serializable = true;\n-        return this;\n+        return this.extraInterfaces(java.io.Serializable.class);\n     }\n \n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n@@ -73,7 +71,7 @@ public class MockSettingsImpl implements MockSettings {\n     }\n \n     public boolean isSerializable() {\n-        return serializable;\n+        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n     }\n \n     public void initiateMockName(Class classToMock) {\ndiff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex b8ed8b4..d2d042f 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -16,7 +16,6 @@ import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n \n-import java.io.Serializable;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n@@ -43,11 +42,7 @@ public class MockUtil {\n         Class<?>[] interfaces = settings.getExtraInterfaces();\n \n         Class<?>[] ancillaryTypes;\n-        if (settings.isSerializable()) {\n-            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n-        } else {\n             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n-        }\n \n         Object spiedInstance = settings.getSpiedInstance();\n         \n"}
{"identifier": "Math-50", "buggy_code": "    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex c781a90..e47d982 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,6 +184,10 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+                    if (x == x1) {\n+                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        f0 = computeObjectiveValue(x0);\n+                    }\n                     break;\n                 default:\n                     // Should never happen.\n"}
{"identifier": "Lang-28", "buggy_code": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // TODO: Protect from ArrayIndexOutOfBounds\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n\n            int end = start;\n            while(input.charAt(end) != ';') {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n\n                out.write(entityValue);\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }\n", "fixed_code": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // TODO: Protect from ArrayIndexOutOfBounds\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n\n            int end = start;\n            while(input.charAt(end) != ';') {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\nindex a21671a..c3cb869 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n@@ -60,13 +60,7 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n                 return 0;\n             }\n \n-            if(entityValue > 0xFFFF) {\n-                char[] chrs = Character.toChars(entityValue);\n-                out.write(chrs[0]);\n-                out.write(chrs[1]);\n-            } else {\n                 out.write(entityValue);\n-            }\n             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;\n"}
{"identifier": "Mockito-7", "buggy_code": "        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n", "fixed_code": "        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeParametersOn(new TypeVariable[] { typeVariable });\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void readTypeVariables()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nindex 80bd908..2d6c07b 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -376,7 +376,6 @@ public abstract class GenericMetadataSupport {\n             for (Type type : typeVariable.getBounds()) {\n                 registerTypeVariablesOn(type);\n             }\n-            registerTypeParametersOn(new TypeVariable[] { typeVariable });\n             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n         }\n \n"}
{"identifier": "Gson-13", "buggy_code": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n", "fixed_code": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate int peekNumber() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex 9cbc62f4..877742bf 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -728,7 +728,7 @@ public class JsonReader implements Closeable {\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n"}
{"identifier": "Closure-106", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 47ea27a..d7e85df 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -904,10 +904,6 @@ class GlobalNamespace {\n       // Don't try to collapse if the one global set is a twin reference.\n       // We could theoretically handle this case in CollapseProperties, but\n       // it's probably not worth the effort.\n-      Preconditions.checkNotNull(declaration);\n-      if (declaration.getTwin() != null) {\n-        return false;\n-      }\n \n       if (isClassOrEnum) {\n         return true;\ndiff --git a/src/com/google/javascript/rhino/JSDocInfoBuilder.java b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\nindex bdfc2e8..1311638 100644\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n@@ -186,7 +186,9 @@ final public class JSDocInfoBuilder {\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n+    if (parseDocumentation) {\n     populated = true;\n+    }\n     return currentInfo.documentBlock(description);\n   }\n \n"}
{"identifier": "Cli-31", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/HelpFormatter.java b/src/main/java/org/apache/commons/cli/HelpFormatter.java\nindex 6d73237..1debaf6 100644\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n@@ -650,10 +650,10 @@ public class HelpFormatter\n         }\n         \n         // if the Option has a value and a non blank argname\n-        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n+        if (option.hasArg() && option.hasArgName())\n         {\n             buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n-            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n+            buff.append(\"<\").append(option.getArgName()).append(\">\");\n         }\n         \n         // if the Option is not a required option\ndiff --git a/src/main/java/org/apache/commons/cli/Option.java b/src/main/java/org/apache/commons/cli/Option.java\nindex ce12780..921c7ab 100644\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n@@ -54,7 +54,7 @@ public class Option implements Cloneable, Serializable\n     private String longOpt;\n \n     /** the name of the argument for this option */\n-    private String argName;\n+    private String argName = \"arg\";\n \n     /** description of the option */\n     private String description;\ndiff --git a/src/main/java/org/apache/commons/cli/OptionBuilder.java b/src/main/java/org/apache/commons/cli/OptionBuilder.java\nindex a22d829..33a24a6 100644\n--- a/src/main/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/main/java/org/apache/commons/cli/OptionBuilder.java\n@@ -77,7 +77,7 @@ public final class OptionBuilder\n     private static void reset()\n     {\n         description = null;\n-        argName = null;\n+        argName = \"arg\";\n         longopt = null;\n         type = null;\n         required = false;\n"}
{"identifier": "Chart-9", "buggy_code": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n", "fixed_code": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex d16d447..4067e3e 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -941,7 +941,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if ((endIndex < 0)  || (endIndex < startIndex)) {\n+        if (endIndex < 0) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n"}
{"identifier": "Closure-19", "buggy_code": "  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n        // \"this\" references aren't currently modeled in the CFG.\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }\n", "fixed_code": "  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        // \"this\" references aren't currently modeled in the CFG.\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Declares a refined type in\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 752e04f..0345c85 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -169,9 +169,7 @@ public abstract class ChainableReverseAbstractInterpreter\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n-      case Token.THIS:\n         // \"this\" references aren't currently modeled in the CFG.\n-        break;\n \n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n"}
{"identifier": "Compress-24", "buggy_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "fixed_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n        if (start == end) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 4cf32d6f..594aa33f 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -126,13 +126,16 @@ public class TarUtils {\n         // space but some implementations use the extra digit for big\n         // sizes/uids/gids ...\n         byte trailer = buffer[end - 1];\n-        while (start < end && (trailer == 0 || trailer == ' ')) {\n+        if (trailer == 0 || trailer == ' '){\n             end--;\n-            trailer = buffer[end - 1];\n-        }\n-        if (start == end) {\n+        } else {\n             throw new IllegalArgumentException(\n-                    exceptionMessage(buffer, offset, length, start, trailer));\n+                    exceptionMessage(buffer, offset, length, end-1, trailer));\n+        }\n+        trailer = buffer[end - 1];\n+        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n+            end--;\n+            trailer = buffer[end - 1];\n         }\n \n         for ( ;start < end; start++) {\n"}
{"identifier": "Closure-28", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineCostEstimator.java b/src/com/google/javascript/jscomp/InlineCostEstimator.java\nindex 65694ab..76a5d0a 100644\n--- a/src/com/google/javascript/jscomp/InlineCostEstimator.java\n+++ b/src/com/google/javascript/jscomp/InlineCostEstimator.java\n@@ -99,9 +99,5 @@ class InlineCostEstimator {\n      * Constants (true, false, null) are considered basically free,\n      * because it's likely that they will get folded when we're done.\n      */\n-    @Override\n-    void addConstant(String newcode) {\n-      add(\"0\");\n-    }\n   }\n }\n"}
{"identifier": "Closure-72", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\nindex 3fee1a9..64764c0 100644\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n@@ -149,8 +149,6 @@ class FunctionToBlockMutator {\n                 \"inline_\",\n                 isCallInLoop)));\n     // Make label names unique to this instance.\n-    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)\n-        .process(null, fnNode);\n   }\n \n   static class LabelNameSupplier implements Supplier<String> {\ndiff --git a/src/com/google/javascript/jscomp/RenameLabels.java b/src/com/google/javascript/jscomp/RenameLabels.java\nindex 28e52ee..a2f53cf 100644\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n@@ -212,7 +212,7 @@ final class RenameLabels implements CompilerPass {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n       // This is a label...\n-      if (li.referenced || !removeUnused) {\n+      if (li.referenced) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n           // ... and it is used, give it the short name.\n"}
{"identifier": "Lang-21", "buggy_code": "    /**\n     * <p>Checks if two calendar objects represent the same local time.</p>\n     *\n     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n", "fixed_code": "    /**\n     * <p>Checks if two calendar objects represent the same local time.</p>\n     *\n     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Checks if two calendar objects represent the same local time.</p>\n     *\n     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\nindex 52a4436..9a24c00 100644\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n@@ -262,7 +262,7 @@ public class DateUtils {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n+                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n"}
{"identifier": "Closure-149", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\nindex 8e2b2633..8cb44726 100644\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n@@ -156,7 +156,6 @@ abstract class AbstractCommandLineRunner<A extends Compiler,\n     options.setCodingConvention(config.codingConvention);\n     options.setSummaryDetailLevel(config.summaryDetailLevel);\n \n-    options.outputCharset = getOutputCharset();\n     inputCharset = getInputCharset();\n \n     if (config.jsOutputFile.length() > 0) {\n@@ -516,6 +515,11 @@ abstract class AbstractCommandLineRunner<A extends Compiler,\n     Result result;\n \n     setRunOptions(options);\n+    if (inputCharset == Charsets.UTF_8) {\n+      options.outputCharset = Charsets.US_ASCII;\n+    } else {\n+      options.outputCharset = inputCharset;\n+    }\n \n     boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n@@ -686,16 +690,6 @@ abstract class AbstractCommandLineRunner<A extends Compiler,\n    *    be a supported charset.\n    * @throws FlagUsageException if flag is not a valid Charset name.\n    */\n-  private String getOutputCharset() throws FlagUsageException {\n-    if (!config.charset.isEmpty()) {\n-      if (!Charset.isSupported(config.charset)) {\n-        throw new FlagUsageException(config.charset +\n-            \" is not a valid charset name.\");\n-      }\n-      return config.charset;\n-    }\n-    return \"US-ASCII\";\n-  }\n \n   protected List<JSSourceFile> createExterns() throws FlagUsageException,\n       IOException {\ndiff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex bd2de605..e3334a30 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -468,6 +468,7 @@ public class CommandLineRunner extends\n     }\n \n     options.closurePass = flags.process_closure_primitives;\n+    initOptionsFromFlags(options);\n     return options;\n   }\n \ndiff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 56bc4eb8..7a12c4fc 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1359,8 +1359,7 @@ public class Compiler extends AbstractCompiler {\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n \n-    Charset charset = options.outputCharset != null ?\n-        Charset.forName(options.outputCharset) : null;\n+    Charset charset = options.outputCharset;\n     builder.setOutputCharset(charset);\n \n     return builder.build();\ndiff --git a/src/com/google/javascript/jscomp/CompilerOptions.java b/src/com/google/javascript/jscomp/CompilerOptions.java\nindex f1c95357..f4c78363 100644\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n@@ -585,7 +585,7 @@ public class CompilerOptions implements Serializable, Cloneable {\n    * Charset to use when generating code.  If null, then output ASCII.\n    * This needs to be a string because CompilerOptions is serializable.\n    */\n-  String outputCharset;\n+  public Charset outputCharset;\n \n   /**\n    * Whether the named objects types included 'undefined' by default.\n@@ -957,9 +957,6 @@ public class CompilerOptions implements Serializable, Cloneable {\n   /**\n    * Sets the output charset by name.\n    */\n-  public void setOutputCharset(String charsetName) {\n-    this.outputCharset = charsetName;\n-  }\n \n   /**\n    * Whether to include \"undefined\" in the default types.\n"}
{"identifier": "Compress-12", "buggy_code": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }\n", "fixed_code": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex 34e73554..bb670f30 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -195,13 +195,7 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n             return null;\n         }\n \n-        try {\n-            currEntry = new TarArchiveEntry(headerBuf);\n-        } catch (IllegalArgumentException e) {\n-            IOException ioe = new IOException(\"Error detected parsing the header\");\n-            ioe.initCause(e);\n-            throw ioe;\n-        }\n+        currEntry = new TarArchiveEntry(headerBuf);\n         entryOffset = 0;\n         entrySize = currEntry.getSize();\n \n"}
{"identifier": "Jsoup-11", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/select/Selector.java b/src/main/java/org/jsoup/select/Selector.java\nindex e370de8..13341ce 100644\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n@@ -107,8 +107,6 @@ public class Selector {\n         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n             elements.add(root);\n             combinator(tq.consume().toString());\n-        } else if (tq.matches(\":has(\")) {\n-            elements.addAll(root.getAllElements());\n         } else {\n             addElements(findElements()); // chomp first element matcher off queue \n         }            \n@@ -180,8 +178,6 @@ public class Selector {\n             return matches(false);\n         } else if (tq.matches(\":matchesOwn(\")) {\n             return matches(true);\n-        } else if (tq.matches(\":not(\")) {\n-            return not();\n         } else { // unhandled\n             throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n         }\n@@ -306,13 +302,7 @@ public class Selector {\n     }\n \n     // :not(selector)\n-    private Elements not() {\n-        tq.consume(\":not\");\n-        String subQuery = tq.chompBalanced('(', ')');\n-        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n \n-        return filterOut(root.getAllElements(), select(subQuery, root));\n-    }\n \n     // direct child descendants\n     private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n@@ -406,21 +396,6 @@ public class Selector {\n     }\n \n     // exclude set. package open so that Elements can implement .not() selector.\n-    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n-        Elements output = new Elements();\n-        for (Element el: elements) {\n-            boolean found = false;\n-            for (Element out: outs) {\n-                if (el.equals(out)) {\n-                    found = true;\n-                    break;\n-                }\n-            }\n-            if (!found)\n-                output.add(el);\n-        }\n-        return output;\n-    }\n \n     public static class SelectorParseException extends IllegalStateException {\n         public SelectorParseException(String msg, Object... params) {\n"}
{"identifier": "Mockito-6", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/Matchers.java b/src/org/mockito/Matchers.java\nindex d6893af..04f40e5 100644\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n@@ -119,7 +119,7 @@ public class Matchers {\n      * @return <code>false</code>.\n      */\n     public static boolean anyBoolean() {\n-        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\n+        return reportMatcher(Any.ANY).returnFalse();\n     }\n \n     /**\n@@ -134,7 +134,7 @@ public class Matchers {\n      * @return <code>0</code>.\n      */\n     public static byte anyByte() {\n-        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\n+        return reportMatcher(Any.ANY).returnZero();\n     }\n \n     /**\n@@ -149,7 +149,7 @@ public class Matchers {\n      * @return <code>0</code>.\n      */\n     public static char anyChar() {\n-        return reportMatcher(new InstanceOf(Character.class)).returnChar();\n+        return reportMatcher(Any.ANY).returnChar();\n     }\n \n     /**\n@@ -164,7 +164,7 @@ public class Matchers {\n      * @return <code>0</code>.\n      */\n     public static int anyInt() {\n-        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\n+        return reportMatcher(Any.ANY).returnZero();\n     }\n \n     /**\n@@ -179,7 +179,7 @@ public class Matchers {\n      * @return <code>0</code>.\n      */\n     public static long anyLong() {\n-        return reportMatcher(new InstanceOf(Long.class)).returnZero();\n+        return reportMatcher(Any.ANY).returnZero();\n     }\n \n     /**\n@@ -194,7 +194,7 @@ public class Matchers {\n      * @return <code>0</code>.\n      */\n     public static float anyFloat() {\n-        return reportMatcher(new InstanceOf(Float.class)).returnZero();\n+        return reportMatcher(Any.ANY).returnZero();\n     }\n \n     /**\n@@ -209,7 +209,7 @@ public class Matchers {\n      * @return <code>0</code>.\n      */\n     public static double anyDouble() {\n-        return reportMatcher(new InstanceOf(Double.class)).returnZero();\n+        return reportMatcher(Any.ANY).returnZero();\n     }\n \n     /**\n@@ -224,7 +224,7 @@ public class Matchers {\n      * @return <code>0</code>.\n      */\n     public static short anyShort() {\n-        return reportMatcher(new InstanceOf(Short.class)).returnZero();\n+        return reportMatcher(Any.ANY).returnZero();\n     }\n \n     /**\n@@ -241,7 +241,7 @@ public class Matchers {\n      * @return <code>null</code>.\n      */\n     public static <T> T anyObject() {\n-        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();\n+        return (T) reportMatcher(Any.ANY).returnNull();\n     }\n \n     /**\n@@ -289,7 +289,7 @@ public class Matchers {\n      * @return <code>null</code>.\n      */\n     public static <T> T any(Class<T> clazz) {\n-        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\n+        return (T) reportMatcher(Any.ANY).returnFor(clazz);\n     }\n     \n     /**\n@@ -306,7 +306,7 @@ public class Matchers {\n      * @return <code>null</code>.\n      */\n     public static <T> T any() {\n-        return (T) reportMatcher(Any.ANY).returnNull();\n+        return (T) anyObject();\n     }\n \n     /**\n@@ -321,7 +321,7 @@ public class Matchers {\n      * @return empty String (\"\")\n      */\n     public static String anyString() {\n-        return reportMatcher(new InstanceOf(String.class)).returnString();\n+        return reportMatcher(Any.ANY).returnString();\n     }\n     \n     /**\n@@ -336,7 +336,7 @@ public class Matchers {\n      * @return empty List.\n      */\n     public static List anyList() {\n-        return reportMatcher(new InstanceOf(List.class)).returnList();\n+        return reportMatcher(Any.ANY).returnList();\n     }    \n     \n     /**\n@@ -355,7 +355,7 @@ public class Matchers {\n      * @return empty List.\n      */\n     public static <T> List<T> anyListOf(Class<T> clazz) {\n-        return anyList();\n+        return (List) reportMatcher(Any.ANY).returnList();\n     }    \n     \n     /**\n@@ -370,7 +370,7 @@ public class Matchers {\n      * @return empty Set\n      */\n     public static Set anySet() {\n-        return reportMatcher(new InstanceOf(Set.class)).returnSet();\n+        return reportMatcher(Any.ANY).returnSet();\n     }\n     \n     /**\n@@ -389,7 +389,7 @@ public class Matchers {\n      * @return empty Set\n      */\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\n-        return anySet();\n+        return (Set) reportMatcher(Any.ANY).returnSet();\n     }\n \n     /**\n@@ -404,7 +404,7 @@ public class Matchers {\n      * @return empty Map.\n      */\n     public static Map anyMap() {\n-        return reportMatcher(new InstanceOf(Map.class)).returnMap();\n+        return reportMatcher(Any.ANY).returnMap();\n     }\n \n     /**\n@@ -424,7 +424,7 @@ public class Matchers {\n      * @return empty Map.\n      */\n     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\n-        return anyMap();\n+        return reportMatcher(Any.ANY).returnMap();\n     }\n     \n     /**\n@@ -439,7 +439,7 @@ public class Matchers {\n      * @return empty Collection.\n      */\n     public static Collection anyCollection() {\n-        return reportMatcher(new InstanceOf(Collection.class)).returnList();\n+        return reportMatcher(Any.ANY).returnList();\n     }    \n     \n     /**\n@@ -458,7 +458,7 @@ public class Matchers {\n      * @return empty Collection.\n      */\n     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\n-        return anyCollection();\n+        return (Collection) reportMatcher(Any.ANY).returnList();\n     }    \n \n     /**\n"}
{"identifier": "JxPath-15", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\nindex 80e111e..04adadf 100644\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n@@ -17,10 +17,8 @@\n package org.apache.commons.jxpath.ri.axes;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n \n import org.apache.commons.jxpath.BasicNodeSet;\n-import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n@@ -55,17 +53,13 @@ public class UnionContext extends NodeSetContext {\n                     while (ctx.nextNode()) {\n                         NodePointer ptr = ctx.getCurrentNodePointer();\n                         if (!pointers.contains(ptr)) {\n+                            nodeSet.add(ptr);\n                             pointers.add(ptr);\n                         }\n                     }\n                 }\n             }\n-            sortPointers(pointers);\n-\n-            for (Iterator it = pointers.iterator(); it.hasNext();) {\n-                nodeSet.add((Pointer) it.next());\n-            }\n         }\n         return super.setPosition(position);\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Lang-51", "buggy_code": "    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n", "fixed_code": "    /**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n                return false;\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Converts a String to a boolean (optimised for performance).</p>\n     * \n     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n     * (case insensitive) will return <code>true</code>. Otherwise,\n     * <code>false</code> is returned.</p>\n     * \n     * <p>This method performs 4 times faster (JDK1.4) than\n     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n     * 'on' and 'yes' as true values.\n     *\n     * <pre>\n     *   BooleanUtils.toBoolean(null)    = false\n     *   BooleanUtils.toBoolean(\"true\")  = true\n     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n     *   BooleanUtils.toBoolean(\"on\")    = true\n     *   BooleanUtils.toBoolean(\"yes\")   = true\n     *   BooleanUtils.toBoolean(\"false\") = false\n     *   BooleanUtils.toBoolean(\"x gti\") = false\n     * </pre>\n     *\n     * @param str  the String to check\n     * @return the boolean value of the string, <code>false</code> if no match\n     */\n    public static boolean toBoolean(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 8b5028c..3fda4ec 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -679,7 +679,6 @@ public class BooleanUtils {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n-                return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);\n"}
{"identifier": "JacksonDatabind-37", "buggy_code": "    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n", "fixed_code": "    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    protected JavaType _narrow(Class<?> subclass)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\nindex 1c741ec9f..eca7e8e48 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n@@ -132,7 +132,7 @@ public class SimpleType // note: until 2.6 was final\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n+        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n"}
{"identifier": "Cli-36", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/OptionGroup.java b/src/main/java/org/apache/commons/cli/OptionGroup.java\nindex dc6d5db..322053f 100644\n--- a/src/main/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/main/java/org/apache/commons/cli/OptionGroup.java\n@@ -19,8 +19,8 @@ package org.apache.commons.cli;\n \n import java.io.Serializable;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.LinkedHashMap;\n import java.util.Map;\n \n /**\n@@ -34,7 +34,7 @@ public class OptionGroup implements Serializable\n     private static final long serialVersionUID = 1L;\n     \n     /** hold the options */\n-    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n+    private final Map<String, Option> optionMap = new HashMap<String, Option>();\n \n     /** the name of the selected option */\n     private String selected;\ndiff --git a/src/main/java/org/apache/commons/cli/Options.java b/src/main/java/org/apache/commons/cli/Options.java\nindex 796fe5c..721baaf 100644\n--- a/src/main/java/org/apache/commons/cli/Options.java\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n@@ -57,7 +57,7 @@ public class Options implements Serializable\n     private final List<Object> requiredOpts = new ArrayList<Object>();\n \n     /** a map of the option groups */\n-    private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<String, OptionGroup>();\n+    private final Map<String, OptionGroup> optionGroups = new java.util.HashMap<String, OptionGroup>();\n \n     /**\n      * Add the specified option group.\n"}
{"identifier": "Jsoup-90", "buggy_code": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "fixed_code": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                if (end >= input.length)\n                    return false;\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate static boolean looksLikeUtf8(byte[] input)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex 00a1d98..a941e48 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -421,8 +421,6 @@ public class HttpConnection implements Connection {\n                     return false;\n                 }\n \n-                if (end >= input.length)\n-                    return false;\n \n                 while (i < end) {\n                     i++;\n"}
{"identifier": "Math-49", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex 13ebfd2..5db4884 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -342,7 +342,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n@@ -355,7 +355,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n@@ -367,7 +367,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n@@ -380,7 +380,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n"}
{"identifier": "Cli-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex 12d3146..2590de7 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -302,9 +302,8 @@ public class PosixParser extends Parser {\n             }\n             else\n             {\n-                tokens.add(token);\n-                break;\n+                tokens.add(\"-\" + ch);\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Jsoup-10", "buggy_code": "    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n                if (relUrl.startsWith(\"?\"))\n                    relUrl = base.getPath() + relUrl;\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java\nindex 513c0ee..5e6eb8f 100644\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n@@ -170,8 +170,6 @@ public abstract class Node implements Cloneable {\n                     return abs.toExternalForm();\n                 }\n                 // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n-                if (relUrl.startsWith(\"?\"))\n-                    relUrl = base.getPath() + relUrl;\n                 URL abs = new URL(base, relUrl);\n                 return abs.toExternalForm();\n             } catch (MalformedURLException e) {\n"}
{"identifier": "Mockito-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/MockHandler.java b/src/org/mockito/internal/MockHandler.java\nindex b6c1b78..bc18218 100644\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n@@ -17,7 +17,6 @@ import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.stubbing.OngoingStubbingImpl;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n-import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n@@ -74,11 +73,9 @@ public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInte\n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n-            }\n         }\n         \n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\ndiff --git a/src/org/mockito/internal/MockitoCore.java b/src/org/mockito/internal/MockitoCore.java\nindex ae0d72b..fc99ea9 100755\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n@@ -20,7 +20,6 @@ import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.stubbing.OngoingStubbingImpl;\n import org.mockito.internal.stubbing.StubberImpl;\n import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.api.InOrderContext;\n@@ -71,7 +70,7 @@ public class MockitoCore {\n         } else if (!mockUtil.isMock(mock)) {\n             reporter.notAMockPassedToVerify();\n         }\n-        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n+        mockingProgress.verificationStarted(mode);\n         return mock;\n     }\n     \n"}
{"identifier": "Math-3", "buggy_code": "    /**\n     * Compute a linear combination accurately.\n     * This method computes the sum of the products\n     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n     * It does so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects.\n     * <br/>\n     * It is based on the 2005 paper\n     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     *\n     * @param a Factors.\n     * @param b Factors.\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n     * @throws DimensionMismatchException if arrays dimensions don't match\n     */\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n            // Revert to scalar multiplication.\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n", "fixed_code": "    /**\n     * Compute a linear combination accurately.\n     * This method computes the sum of the products\n     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n     * It does so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects.\n     * <br/>\n     * It is based on the 2005 paper\n     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     *\n     * @param a Factors.\n     * @param b Factors.\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n     * @throws DimensionMismatchException if arrays dimensions don't match\n     */\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n        if (len == 1) {\n            // Revert to scalar multiplication.\n            return a[0] * b[0];\n        }\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Compute a linear combination accurately.\n     * This method computes the sum of the products\n     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n     * It does so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects.\n     * <br/>\n     * It is based on the 2005 paper\n     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     *\n     * @param a Factors.\n     * @param b Factors.\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n     * @throws DimensionMismatchException if arrays dimensions don't match\n     */\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 8f83d96..325fd94 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -818,10 +818,7 @@ public class MathArrays {\n             throw new DimensionMismatchException(len, b.length);\n         }\n \n-        if (len == 1) {\n             // Revert to scalar multiplication.\n-            return a[0] * b[0];\n-        }\n \n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n"}
{"identifier": "Mockito-11", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/creation/DelegatingMethod.java b/src/org/mockito/internal/creation/DelegatingMethod.java\nindex 034694f..349719b 100644\n--- a/src/org/mockito/internal/creation/DelegatingMethod.java\n+++ b/src/org/mockito/internal/creation/DelegatingMethod.java\n@@ -52,19 +52,11 @@ public class DelegatingMethod implements MockitoMethod {\n      */\n     @Override\n     public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o instanceof DelegatingMethod) {\n-            DelegatingMethod that = (DelegatingMethod) o;\n-            return method.equals(that.method);\n-        } else {\n             return method.equals(o);\n-        }\n     }\n \n     @Override\n     public int hashCode() {\n-        return method.hashCode();\n+        return 1;\n     }\n }\n\\ No newline at end of file\n"}
{"identifier": "Cli-13", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli2/WriteableCommandLine.java b/src/java/org/apache/commons/cli2/WriteableCommandLine.java\nindex a70c8d6..96ab589 100644\n--- a/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n+++ b/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n@@ -44,7 +44,6 @@ public interface WriteableCommandLine extends CommandLine {\n      * @param option the Option associated with the values\n      * @return a list of values or an empty List if none are found\n      */\n-    List getUndefaultedValues(final Option option);\n \n     /**\n      * Sets the default values for an Option in the CommandLine\ndiff --git a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\nindex 97a5d11..b4e3a39 100644\n--- a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n@@ -129,17 +129,9 @@ public class WriteableCommandLineImpl\n         return valueList;\n     }\n \n-    public List getUndefaultedValues(Option option) {\n       // First grab the command line values\n-      List valueList = (List) values.get(option);\n \n       // Finally use an empty list\n-      if (valueList == null) {\n-        valueList = Collections.EMPTY_LIST;\n-      }\n-\n-      return valueList;\n-    }\n \n     public Boolean getSwitch(final Option option,\n                              final Boolean defaultValue) {\ndiff --git a/src/java/org/apache/commons/cli2/option/ArgumentImpl.java b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\nindex f776f7e..0b05ad7 100644\n--- a/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n@@ -141,7 +141,7 @@ public class ArgumentImpl\n                               final Option option)\n         throws OptionException {\n         // count of arguments processed for this option.\n-        int argumentCount = commandLine.getUndefaultedValues(option).size();\n+        int argumentCount = 0;\n \n         while (arguments.hasNext() && (argumentCount < maximum)) {\n             final String allValuesQuoted = (String) arguments.next();\n"}
{"identifier": "Closure-150", "buggy_code": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          if (parent.getType() == Token.NAME) {\n            return;\n          }\n          defineDeclaredFunction(n, parent);\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n      }\n    }\n", "fixed_code": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 5628a08a..4b841ae8 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1448,7 +1448,21 @@ final class TypedScopeCreator implements ScopeCreator {\n         return;\n       }\n \n-      super.visit(t, n, parent);\n+      attachLiteralTypes(n);\n+      switch (n.getType()) {\n+        case Token.FUNCTION:\n+          if (parent.getType() == Token.NAME) {\n+            return;\n+          }\n+          defineDeclaredFunction(n, parent);\n+          break;\n+        case Token.CATCH:\n+          defineCatch(n, parent);\n+          break;\n+        case Token.VAR:\n+          defineVar(n, parent);\n+          break;\n+      }\n     }\n \n     /** Handle bleeding functions and function parameters. */\n"}
{"identifier": "JacksonDatabind-23", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\nindex 05f7b78e9..c11155e6c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n@@ -51,7 +51,6 @@ public class NumberSerializers\n     protected abstract static class Base<T> extends StdScalarSerializer<T>\n         implements ContextualSerializer\n     {\n-        protected final static Integer EMPTY_INTEGER = Integer.valueOf(0);\n \n         protected final JsonParser.NumberType _numberType;\n         protected final String _schemaType;\n@@ -118,15 +117,10 @@ public class NumberSerializers\n     @JacksonStdImpl\n     public final static class ShortSerializer extends Base<Short>\n     {\n-        private final static Short EMPTY = (short) 0;\n         final static ShortSerializer instance = new ShortSerializer();\n \n         public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, \"number\"); }\n \n-        @Override\n-        public boolean isEmpty(SerializerProvider prov, Short value) {\n-            return EMPTY.equals(value);\n-        }\n \n         @Override\n         public void serialize(Short value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n@@ -162,10 +156,6 @@ public class NumberSerializers\n             serialize(value, gen, provider);            \n         }\n \n-        @Override\n-        public boolean isEmpty(SerializerProvider prov, Object value) {\n-            return EMPTY_INTEGER.equals(value);\n-        }\n     }\n \n     /**\n@@ -182,10 +172,6 @@ public class NumberSerializers\n             super(Number.class, JsonParser.NumberType.INT, \"integer\");\n         }\n \n-        @Override\n-        public boolean isEmpty(SerializerProvider prov, Number value) {\n-            return value.intValue() == 0;\n-        }\n \n         @Override\n         public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n@@ -196,16 +182,11 @@ public class NumberSerializers\n     @JacksonStdImpl\n     public final static class LongSerializer extends Base<Object>\n     {\n-        private final static Long EMPTY = 0L;\n \n         final static LongSerializer instance = new LongSerializer();\n     \n         public LongSerializer() { super(Long.class, JsonParser.NumberType.LONG, \"number\"); }\n \n-        @Override\n-        public boolean isEmpty(SerializerProvider prov, Object value) {\n-            return EMPTY.equals(value);\n-        }\n \n         @Override\n         public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n@@ -216,16 +197,11 @@ public class NumberSerializers\n     @JacksonStdImpl\n     public final static class FloatSerializer extends Base<Object>\n     {\n-        private final static Float EMPTY = 0f;\n \n         final static FloatSerializer instance = new FloatSerializer();\n \n         public FloatSerializer() { super(Float.class, JsonParser.NumberType.FLOAT, \"number\"); }\n \n-        @Override\n-        public boolean isEmpty(SerializerProvider prov, Object value) {\n-            return EMPTY.equals(value);\n-        }\n \n         @Override\n         public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n@@ -243,16 +219,11 @@ public class NumberSerializers\n     @JacksonStdImpl\n     public final static class DoubleSerializer extends Base<Object>\n     {\n-        private final static Double EMPTY = 0d;\n \n         final static DoubleSerializer instance = new DoubleSerializer();\n     \n         public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, \"number\"); }\n \n-        @Override\n-        public boolean isEmpty(SerializerProvider prov, Object value) {\n-            return EMPTY.equals(value);\n-        }\n \n         @Override\n         public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n"}
{"identifier": "Lang-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\nindex 9cf45f8..8ed51bc 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n@@ -28,7 +28,7 @@ import java.util.HashMap;\n  */\n public class LookupTranslator extends CharSequenceTranslator {\n \n-    private final HashMap<String, CharSequence> lookupMap;\n+    private final HashMap<CharSequence, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;\n \n@@ -43,12 +43,12 @@ public class LookupTranslator extends CharSequenceTranslator {\n      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n-        lookupMap = new HashMap<String, CharSequence>();\n+        lookupMap = new HashMap<CharSequence, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n-                this.lookupMap.put(seq[0].toString(), seq[1]);\n+                this.lookupMap.put(seq[0], seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;\n@@ -74,7 +74,7 @@ public class LookupTranslator extends CharSequenceTranslator {\n         // descend so as to get a greedy algorithm\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n-            final CharSequence result = lookupMap.get(subSeq.toString());\n+            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;\n"}
{"identifier": "Lang-19", "buggy_code": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';')\n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }\n", "fixed_code": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n                if(start == seqEnd) {\n                    return 0;\n                }\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n        }\n        return 0;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\nindex 3d4c238..68891ac 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n@@ -37,7 +37,7 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n         // Uses -2 to ensure there is something after the &#\n-        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n+        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n             int start = index + 2;\n             boolean isHex = false;\n \n@@ -47,16 +47,11 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n                 isHex = true;\n \n                 // Check there's more than just an x after the &#\n-                if(start == seqEnd) {\n-                    return 0;\n-                }\n             }\n \n             int end = start;\n             // Note that this supports character codes without a ; on the end\n-            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n-                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n-                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n+            while(input.charAt(end) != ';') \n             {\n                 end++;\n             }\n@@ -81,9 +76,8 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n                 out.write(entityValue);\n             }\n \n-            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n \n-            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n+            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;\n     }\n"}
{"identifier": "Math-5", "buggy_code": "    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return NaN;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex ac8185b..22b23f2 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return INF;\n+            return NaN;\n         }\n \n         if (isInfinite) {\n"}
{"identifier": "Math-33", "buggy_code": "    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n", "fixed_code": "    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 327b2ae..9a6993a 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n+            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n"}
{"identifier": "JacksonDatabind-54", "buggy_code": "    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                        +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        \n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class specifying it; try to find POJO property defaults\n            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (declaredType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (declaredType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n", "fixed_code": "    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                        +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n        \n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class specifying it; try to find POJO property defaults\n            if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\nindex 248633207..9419871d8 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n@@ -131,7 +131,7 @@ public class PropertyBuilder\n             // always suppress nulls\n             suppressNulls = true;\n             // and for referential types, also \"empty\", which in their case means \"absent\"\n-            if (actualType.isReferenceType()) {\n+            if (declaredType.isReferenceType()) {\n                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n             }\n             break;\n@@ -147,7 +147,7 @@ public class PropertyBuilder\n         case ALWAYS: // default\n         default:\n             // we may still want to suppress empty collections, as per [JACKSON-254]:\n-            if (actualType.isContainerType()\n+            if (declaredType.isContainerType()\n                     && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n             }\n"}
{"identifier": "Math-78", "buggy_code": "    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                        // this is a corner case:\n                        // - there was an event near ta,\n                        // - there is another event between ta and tb\n                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                        // about bracketing\n                            // this should never happen\n                         \n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // we were already waiting for this event which was\n                            // found during a previous call for a step that was\n                            // rejected, this step must now be accepted since it\n                            // properly ends exactly at the event occurrence\n                            return false;\n                        }\n                        // either we were not waiting for the event or it has\n                        // moved in such a way the step cannot be accepted\n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }\n", "fixed_code": "    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                    if (ga * gb > 0) {\n                        // this is a corner case:\n                        // - there was an event near ta,\n                        // - there is another event between ta and tb\n                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                        // about bracketing\n                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n                            ta += epsilon;\n                            interpolator.setInterpolatedTime(ta);\n                            ga = handler.g(ta, interpolator.getInterpolatedState());\n                        }\n                        if (ga * gb > 0) {\n                            // this should never happen\n                            throw MathRuntimeException.createInternalError(null);\n                        }\n                    }\n                         \n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // we were already waiting for this event which was\n                            // found during a previous call for a step that was\n                            // rejected, this step must now be accepted since it\n                            // properly ends exactly at the event occurrence\n                            return false;\n                        }\n                        // either we were not waiting for the event or it has\n                        // moved in such a way the step cannot be accepted\n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/ode/events/EventState.java b/src/main/java/org/apache/commons/math/ode/events/EventState.java\nindex ff09646..5006065 100644\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n@@ -188,7 +188,6 @@ public class EventState {\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n-                    if (ga * gb > 0) {\n                         // this is a corner case:\n                         // - there was an event near ta,\n                         // - there is another event between ta and tb\n@@ -196,17 +195,7 @@ public class EventState {\n                         // this implies that the real sign of ga is the same as gb, so we need to slightly\n                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                         // about bracketing\n-                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n-                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n-                            ta += epsilon;\n-                            interpolator.setInterpolatedTime(ta);\n-                            ga = handler.g(ta, interpolator.getInterpolatedState());\n-                        }\n-                        if (ga * gb > 0) {\n                             // this should never happen\n-                            throw MathRuntimeException.createInternalError(null);\n-                        }\n-                    }\n                          \n                     // variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n"}
{"identifier": "Closure-113", "buggy_code": "  /**\n   * Handles a goog.require call.\n   */\n  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n", "fixed_code": "  /**\n   * Handles a goog.require call.\n   */\n  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null || requiresLevel.isOn()) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Handles a goog.require call.\n   */\n  private void processRequireCall(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex 85cee7c..70bf1b0 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -326,7 +326,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null || requiresLevel.isOn()) {\n+      if (provided != null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n"}
{"identifier": "Closure-95", "buggy_code": "    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualfied names.\n      boolean shouldDeclareOnGlobalThis = false;\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n            (parent.getType() == Token.VAR ||\n             parent.getType() == Token.FUNCTION);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      String variableName = n.getQualifiedName();\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n\n      // declared in closest scope?\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          boolean isExtern = input.isExtern();\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), compiler.getInput(sourceName),\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n          }\n        }\n      }\n    }\n", "fixed_code": "    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualfied names.\n      boolean shouldDeclareOnGlobalThis = false;\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n            (parent.getType() == Token.VAR ||\n             parent.getType() == Token.FUNCTION);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      String variableName = n.getQualifiedName();\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // declared in closest scope?\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          boolean isExtern = input.isExtern();\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), compiler.getInput(sourceName),\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n          }\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex c7005b2..4bd6bfb 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -896,16 +896,9 @@ final class TypedScopeCreator implements ScopeCreator {\n       // scope where the root object appears. This helps out people\n       // who declare \"global\" names in an anonymous namespace.\n       Scope scopeToDeclareIn = scope;\n-      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n-          isQnameRootedInGlobalScope(n)) {\n-        Scope globalScope = scope.getGlobalScope();\n \n         // don't try to declare in the global scope if there's\n         // already a symbol there with this name.\n-        if (!globalScope.isDeclared(variableName, false)) {\n-          scopeToDeclareIn = scope.getGlobalScope();\n-        }\n-      }\n \n       // declared in closest scope?\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {\n"}
{"identifier": "Math-46", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex dd0b00a..d55c25a 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -257,7 +257,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n \n         if (divisor.isZero) {\n             // return isZero ? NaN : INF; // See MATH-657\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n@@ -294,7 +294,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n         if (divisor == 0d) {\n             // return isZero ? NaN : INF; // See MATH-657\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n"}
{"identifier": "JacksonDatabind-55", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\nindex 7afcc55f6..7f55a3f29 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n@@ -7,7 +7,6 @@ import java.util.Date;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n-import com.fasterxml.jackson.databind.util.EnumValues;\n \n @SuppressWarnings(\"serial\")\n public class StdKeySerializers\n@@ -80,8 +79,7 @@ public class StdKeySerializers\n                 return new Dynamic();\n             }\n             if (rawKeyType.isEnum()) {\n-                return EnumKeySerializer.construct(rawKeyType,\n-                        EnumValues.constructFromName(config, (Class<Enum<?>>) rawKeyType));\n+                return new Default(Default.TYPE_ENUM, rawKeyType);\n             }\n         }\n         return DEFAULT_KEY_SERIALIZER;\n@@ -214,31 +212,7 @@ public class StdKeySerializers\n      *\n      * @since 2.8\n      */\n-    public static class EnumKeySerializer extends StdSerializer<Object>\n-    {\n-        protected final EnumValues _values;\n \n-        protected EnumKeySerializer(Class<?> enumType, EnumValues values) {\n-            super(enumType, false);\n-            _values = values;\n-        }\n \n-        public static EnumKeySerializer construct(Class<?> enumType,\n-                EnumValues enumValues)\n-        {\n-            return new EnumKeySerializer(enumType, enumValues);\n-        }\n         \n-        @Override\n-        public void serialize(Object value, JsonGenerator g, SerializerProvider serializers)\n-                throws IOException\n-        {\n-            if (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)) {\n-                g.writeFieldName(value.toString());\n-                return;\n-            }\n-            Enum<?> en = (Enum<?>) value;\n-            g.writeFieldName(_values.serializedValueFor(en));\n-        }\n-    }\n }\n"}
{"identifier": "Compress-15", "buggy_code": "    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        String myName = getName();\n        String otherName = other.getName();\n        if (myName == null) {\n            if (otherName != null) {\n                return false;\n            }\n        } else if (!myName.equals(otherName)) {\n            return false;\n        }\n        String myComment = getComment();\n        String otherComment = other.getComment();\n        if (myComment == null) {\n            if (otherComment != null) {\n                return false;\n            }\n        } else if (!myComment.equals(otherComment)) {\n            return false;\n        }\n        return getTime() == other.getTime()\n            && getInternalAttributes() == other.getInternalAttributes()\n            && getPlatform() == other.getPlatform()\n            && getExternalAttributes() == other.getExternalAttributes()\n            && getMethod() == other.getMethod()\n            && getSize() == other.getSize()\n            && getCrc() == other.getCrc()\n            && getCompressedSize() == other.getCompressedSize()\n            && Arrays.equals(getCentralDirectoryExtra(),\n                             other.getCentralDirectoryExtra())\n            && Arrays.equals(getLocalFileDataExtra(),\n                             other.getLocalFileDataExtra())\n            && gpb.equals(other.gpb);\n    }\n", "fixed_code": "    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        String myName = getName();\n        String otherName = other.getName();\n        if (myName == null) {\n            if (otherName != null) {\n                return false;\n            }\n        } else if (!myName.equals(otherName)) {\n            return false;\n        }\n        String myComment = getComment();\n        String otherComment = other.getComment();\n        if (myComment == null) {\n            myComment = \"\";\n        }\n        if (otherComment == null) {\n            otherComment = \"\";\n        }\n        return getTime() == other.getTime()\n            && myComment.equals(otherComment)\n            && getInternalAttributes() == other.getInternalAttributes()\n            && getPlatform() == other.getPlatform()\n            && getExternalAttributes() == other.getExternalAttributes()\n            && getMethod() == other.getMethod()\n            && getSize() == other.getSize()\n            && getCrc() == other.getCrc()\n            && getCompressedSize() == other.getCompressedSize()\n            && Arrays.equals(getCentralDirectoryExtra(),\n                             other.getCentralDirectoryExtra())\n            && Arrays.equals(getLocalFileDataExtra(),\n                             other.getLocalFileDataExtra())\n            && gpb.equals(other.gpb);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex 166ca75f..1833227c 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -666,13 +666,13 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n         String myComment = getComment();\n         String otherComment = other.getComment();\n         if (myComment == null) {\n-            myComment = \"\";\n-        }\n-        if (otherComment == null) {\n-            otherComment = \"\";\n+            if (otherComment != null) {\n+                return false;\n+            }\n+        } else if (!myComment.equals(otherComment)) {\n+            return false;\n         }\n         return getTime() == other.getTime()\n-            && myComment.equals(otherComment)\n             && getInternalAttributes() == other.getInternalAttributes()\n             && getPlatform() == other.getPlatform()\n             && getExternalAttributes() == other.getExternalAttributes()\n"}
{"identifier": "Compress-13", "buggy_code": "    /**\n     * Set the name of the entry.\n     * @param name the name to use\n     */\n    protected void setName(String name) {\n        this.name = name;\n    }\n", "fixed_code": "    /**\n     * Set the name of the entry.\n     * @param name the name to use\n     */\n    protected void setName(String name) {\n        if (name != null && getPlatform() == PLATFORM_FAT\n            && name.indexOf(\"/\") == -1) {\n            name = name.replace('\\\\', '/');\n        }\n        this.name = name;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Set the name of the entry.\n     * @param name the name to use\n     */\n    protected void setName(String name)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex db07960a..88cf183f 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -509,10 +509,6 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n      * @param name the name to use\n      */\n     protected void setName(String name) {\n-        if (name != null && getPlatform() == PLATFORM_FAT\n-            && name.indexOf(\"/\") == -1) {\n-            name = name.replace('\\\\', '/');\n-        }\n         this.name = name;\n     }\n \n"}
{"identifier": "Compress-14", "buggy_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        boolean allNUL = true;\n        for (int i = start; i < end; i++){\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "fixed_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex d989b8a7..8239480f 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -62,7 +62,14 @@ public class TarUtils {\n             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n         }\n \n-        if (buffer[start] == 0) {\n+        boolean allNUL = true;\n+        for (int i = start; i < end; i++){\n+            if (buffer[i] != 0){\n+                allNUL = false;\n+                break;\n+            }\n+        }\n+        if (allNUL) {\n             return 0L;\n         }\n \n"}
{"identifier": "JacksonDatabind-22", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\nindex 302a3854a..732f631b3 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n@@ -577,35 +577,30 @@ public abstract class BasicSerializerFactory\n              */\n             JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n             if (mlt.isTrueMapType()) {\n-                return buildMapSerializer(prov, (MapType) mlt, beanDesc, staticTyping,\n+                return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n                         keySerializer, elementTypeSerializer, elementValueSerializer);\n             }\n             // With Map-like, just 2 options: (1) Custom, (2) Annotations\n             JsonSerializer<?> ser = null;\n-            MapLikeType mlType = (MapLikeType) type;\n             for (Serializers serializers : customSerializers()) { // (1) Custom\n+                MapLikeType mlType = (MapLikeType) type;\n                 ser = serializers.findMapLikeSerializer(config,\n                         mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n-                if (ser != null) {\n-                    break;\n-                }\n-            }\n-            if (ser == null) { // (2) Annotations-based ones:\n-                ser = findSerializerByAnnotations(prov, type, beanDesc);\n-            }\n             if (ser != null) {\n                 if (_factoryConfig.hasSerializerModifiers()) {\n                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n                     }\n+                    }\n+                    return ser;\n                 }\n             }\n-            return ser;\n+            return null;\n         }\n         if (type.isCollectionLikeType()) {\n             CollectionLikeType clt = (CollectionLikeType) type;\n             if (clt.isTrueCollectionType()) {\n-                return buildCollectionSerializer(prov,  (CollectionType) clt, beanDesc, staticTyping,\n+                return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n                         elementTypeSerializer, elementValueSerializer);\n             }\n             // With Map-like, just 2 options: (1) Custom, (2) Annotations\n@@ -614,24 +609,19 @@ public abstract class BasicSerializerFactory\n             for (Serializers serializers : customSerializers()) { // (1) Custom\n                 ser = serializers.findCollectionLikeSerializer(config,\n                         clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n-                if (ser != null) {\n-                    break;\n-                }\n-            }\n-            if (ser == null) { // (2) Annotations-based ones:\n-                ser = findSerializerByAnnotations(prov, type, beanDesc);\n-            }\n             if (ser != null) {\n                 if (_factoryConfig.hasSerializerModifiers()) {\n                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n+                        }\n                     }\n+                    return ser;\n                 }\n             }\n-            return ser;\n+            return null;\n         }\n         if (type.isArrayType()) {\n-            return buildArraySerializer(prov, (ArrayType) type, beanDesc, staticTyping,\n+            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n                     elementTypeSerializer, elementValueSerializer);\n         }\n         return null;\n@@ -643,12 +633,11 @@ public abstract class BasicSerializerFactory\n      * \n      * @since 2.1\n      */\n-    protected JsonSerializer<?> buildCollectionSerializer(SerializerProvider prov,\n+    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n             CollectionType type, BeanDescription beanDesc, boolean staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n         throws JsonMappingException\n     {\n-        SerializationConfig config = prov.getConfig();\n         JsonSerializer<?> ser = null;\n         // Order of lookups:\n         // 1. Custom serializers\n@@ -663,8 +652,6 @@ public abstract class BasicSerializerFactory\n         }\n \n         if (ser == null) {\n-            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n-            if (ser == null) {\n                 // We may also want to use serialize Collections \"as beans\", if (and only if)\n                 // this is specified with `@JsonFormat(shape=Object)`\n                 JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n@@ -701,7 +688,6 @@ public abstract class BasicSerializerFactory\n                     if (ser == null) {\n                         ser = buildCollectionSerializer(type.getContentType(), staticTyping,\n                                 elementTypeSerializer, elementValueSerializer);\n-                    }\n                 }\n             }\n         }\n@@ -748,13 +734,12 @@ public abstract class BasicSerializerFactory\n      * Helper method that handles configuration details when constructing serializers for\n      * {@link java.util.Map} types.\n      */\n-    protected JsonSerializer<?> buildMapSerializer(SerializerProvider prov,\n+    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,\n             MapType type, BeanDescription beanDesc,\n             boolean staticTyping, JsonSerializer<Object> keySerializer,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n         throws JsonMappingException\n     {\n-        final SerializationConfig config = prov.getConfig();\n         JsonSerializer<?> ser = null;\n \n         // Order of lookups:\n@@ -768,8 +753,6 @@ public abstract class BasicSerializerFactory\n             if (ser != null) { break; }\n         }\n         if (ser == null) {\n-            ser = findSerializerByAnnotations(prov, type, beanDesc); // (2) Annotations\n-            if (ser == null) {\n                 // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n                 /*\n                 if (EnumMap.class.isAssignableFrom(type.getRawClass())\n@@ -798,7 +781,6 @@ public abstract class BasicSerializerFactory\n                 }\n                 ser = mapSer;\n             }\n-        }\n         // [databind#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n@@ -846,7 +828,7 @@ public abstract class BasicSerializerFactory\n      * Helper method that handles configuration details when constructing serializers for\n      * <code>Object[]</code> (and subtypes, except for String).\n      */\n-    protected JsonSerializer<?> buildArraySerializer(SerializerProvider prov,\n+    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,\n             ArrayType type, BeanDescription beanDesc,\n             boolean staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n@@ -856,7 +838,6 @@ public abstract class BasicSerializerFactory\n         //   types can not be annotated (in theory I guess we could have mix-ins but... ?)\n         //   so we need not do primary annotation lookup here.\n         //   So all we need is (1) Custom, (2) Default array serializers\n-        SerializationConfig config = prov.getConfig();\n         JsonSerializer<?> ser = null;\n \n         for (Serializers serializers : customSerializers()) { // (1) Custom\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\nindex 063b0ff40..992b364a3 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n@@ -171,7 +171,10 @@ public class BeanSerializerFactory\n             JavaType type, BeanDescription beanDesc, boolean staticTyping)\n         throws JsonMappingException\n     {\n-        JsonSerializer<?> ser = null;\n+        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n+        if (ser != null) {\n+            return ser;\n+        }\n         final SerializationConfig config = prov.getConfig();\n         \n         // Container types differ from non-container types\n@@ -206,9 +209,6 @@ public class BeanSerializerFactory\n             }\n             // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,\n             //    this call was BEFORE custom serializer lookup, which was wrong.\n-            if (ser == null) {\n-                ser = findSerializerByAnnotations(prov, type, beanDesc);\n-            }\n         }\n         \n         if (ser == null) {\n"}
{"identifier": "Closure-137", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\nindex d88520c..79f2247 100644\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n@@ -23,7 +23,7 @@ import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multiset;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n@@ -45,7 +45,6 @@ import java.util.Set;\n class MakeDeclaredNamesUnique\n     implements NodeTraversal.ScopedCallback {\n \n-  public static final String ARGUMENTS = \"arguments\";\n   private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n   private final Renamer rootRenamer;\n \n@@ -233,18 +232,16 @@ class MakeDeclaredNamesUnique\n   /**\n    * Inverts the transformation by {@link ContextualRenamer}, when possible.\n    */\n-  static class ContextualRenameInverter\n-      implements ScopedCallback, CompilerPass {\n+  static class ContextualRenameInverter extends AbstractPostOrderCallback\n+      implements CompilerPass {\n     private final AbstractCompiler compiler;\n \n     // The set of names referenced in the current scope.\n-    private Set<String> referencedNames = ImmutableSet.of();\n \n     // Stack reference sets.\n-    private Deque<Set<String>> referenceStack = new ArrayDeque<Set<String>>();\n \n     // Name are globally unique initially, so we don't need a per-scope map.\n-    private Map<String, List<Node>> nameMap = Maps.newHashMap();\n+    private Map<Var, String> nameMap = Maps.newHashMap();\n \n     private ContextualRenameInverter(AbstractCompiler compiler) {\n       this.compiler = compiler;\n@@ -266,105 +263,85 @@ class MakeDeclaredNamesUnique\n     private boolean containsSeparator(String name) {\n       return name.indexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR) != -1;\n     }\n+    private static String getOrginalNameInternal(String name, int index) {\n+      return name.substring(0, index);\n+    }\n \n     /**\n      * Prepare a set for the new scope.\n      */\n-    public void enterScope(NodeTraversal t) {\n-      if (t.inGlobalScope()) {\n-        return;\n-      }\n \n-      referenceStack.push(referencedNames);\n-      referencedNames = Sets.newHashSet();\n+    private static String getNameSuffix(String name, int index) {\n+      return name.substring(\n+          index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(),\n+          name.length());\n     }\n \n     /**\n      * Rename vars for the current scope, and merge any referenced \n      * names into the parent scope reference set.\n      */\n-    public void exitScope(NodeTraversal t) {\n-      if (t.inGlobalScope()) {\n+    @Override\n+    public void visit(NodeTraversal t, Node node, Node parent) {\n+      if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+          Scope scope = t.getScope();\n+          Var var = t.getScope().getVar(oldName);\n+          if (var == null || var.isGlobal()) {\n         return;\n       }\n \n-      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n-        Var v = it.next();\n-        handleScopeVar(v);\n-      }\n+          if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+          } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n \n       // Merge any names that were referenced but not declared in the current\n       // scope.\n-      Set<String> current = referencedNames;\n-      referencedNames = referenceStack.pop();\n       // If there isn't anything left in the stack we will be going into the\n       // global scope: don't try to build a set of referenced names for the\n       // global scope.\n-      if (!referenceStack.isEmpty()) {\n-        referencedNames.addAll(current);\n-      }\n-    }\n+            boolean recurseScopes = false;\n+            if (!suffix.matches(\"\\\\d+\")) {\n+              recurseScopes = true;\n+            }\n \n     /**\n      * For the Var declared in the current scope determine if it is possible\n      * to revert the name to its orginal form without conflicting with other\n      * values.\n      */\n-    void handleScopeVar(Var v) {\n-      String name  = v.getName();\n-      if (containsSeparator(name)) {\n-        String newName = getOrginalName(name);\n         // Check if the new name is valid and if it would cause conflicts.\n-        if (TokenStream.isJSIdentifier(newName) &&\n-            !referencedNames.contains(newName) && \n-            !newName.equals(ARGUMENTS)) {\n-          referencedNames.remove(name);\n+            if (var.scope.isDeclared(newName, recurseScopes) ||\n+                !TokenStream.isJSIdentifier(newName)) {\n+              newName = oldName;\n+            } else {\n+              var.scope.declare(newName, var.nameNode, null, null);\n           // Adding a reference to the new name to prevent either the parent\n           // scopes or the current scope renaming another var to this new name.\n-          referencedNames.add(newName);\n-          List<Node> references = nameMap.get(name);\n-          Preconditions.checkState(references != null);\n-          for (Node n : references) {\n-            Preconditions.checkState(n.getType() == Token.NAME);\n-            n.setString(newName);\n-          }\n+              Node parentNode = var.getParentNode();\n+              if (parentNode.getType() == Token.FUNCTION &&\n+                  parentNode == var.scope.getRootNode()) {\n+                var.getNameNode().setString(newName);\n+              }\n+              node.setString(newName);\n           compiler.reportCodeChange();\n         }\n-        nameMap.remove(name);\n-      }\n-    }\n \n-    @Override\n-    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      return true;\n-    }\n+            nameMap.put(var, newName);\n \n-    @Override\n-    public void visit(NodeTraversal t, Node node, Node parent) {\n-      if (t.inGlobalScope()) {\n-        return;\n       }\n \n-      if (NodeUtil.isReferenceName(node)) {\n-        String name = node.getString();\n         // Add all referenced names to the set so it is possible to check for\n         // conflicts.\n-        referencedNames.add(name);\n         // Store only references to candidate names in the node map.\n-        if (containsSeparator(name)) {\n-          addCandidateNameReference(name, node);\n         }\n       }\n     }\n \n-    private void addCandidateNameReference(String name, Node n) {\n-      List<Node> nodes = nameMap.get(name);\n-      if (null == nodes) {\n-        nodes = Lists.newLinkedList();\n-        nameMap.put(name, nodes);\n-      }\n-      nodes.add(n);\n-    }\n   }\n \n   /**\n@@ -411,7 +388,6 @@ class MakeDeclaredNamesUnique\n      */\n     @Override\n     public void addDeclaredName(String name) {\n-      if (!name.equals(ARGUMENTS)) {\n         if (global) {\n           reserveName(name);\n         } else {\n@@ -421,9 +397,8 @@ class MakeDeclaredNamesUnique\n             String newName = null;\n             if (id != 0) {\n               newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n           }\n+          declarations.put(name, newName);\n         }\n       }\n     }\n@@ -483,7 +458,6 @@ class MakeDeclaredNamesUnique\n \n     @Override\n     public void addDeclaredName(String name) {\n-      Preconditions.checkState(!name.equals(ARGUMENTS));\n       if (!declarations.containsKey(name)) {\n         declarations.put(name, getUniqueName(name));\n       }\ndiff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 6c3643a..c69d9d1 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1040,9 +1040,6 @@ public final class NodeUtil {\n    * @return Whether the name is a reference to a variable, function or\n    *       function parameter (not a label or a empty anonymous function name).\n    */\n-  static boolean isReferenceName(Node n) {\n-    return isName(n) && !n.getString().isEmpty() && !isLabelName(n);\n-  }\n \n   /** @return Whether the node is a label name. */\n   static boolean isLabelName(Node n) {\ndiff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex 993b68d..a8526b5 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -79,6 +79,7 @@ class Normalize implements CompilerPass {\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root,\n         new NormalizeStatements(compiler, assertOnChange));\n+    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n@@ -98,7 +99,6 @@ class Normalize implements CompilerPass {\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n     // TODO(johnlenz): Introduce a seperate scope for catch nodes. \n-    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n"}
{"identifier": "Chart-8", "buggy_code": "    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n     */\n    public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n", "fixed_code": "    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n     */\n    public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, zone, Locale.getDefault());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/data/time/Week.java b/source/org/jfree/data/time/Week.java\nindex 8228589..3cc4138 100644\n--- a/source/org/jfree/data/time/Week.java\n+++ b/source/org/jfree/data/time/Week.java\n@@ -172,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, zone, Locale.getDefault());\n+        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n"}
{"identifier": "Jsoup-35", "buggy_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask.\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        // todo: refactor these lookups\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            for (int si = 0; si < stack.size() && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "fixed_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask.\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        // todo: refactor these lookups\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            for (int si = 0; si < stack.size() && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nboolean process(Token t, HtmlTreeBuilder tb)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex 24bef3b..aebbe44 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -723,7 +723,6 @@ enum HtmlTreeBuilderState {\n                             }\n \n                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n-                            adopter.attributes().addAll(formatEl.attributes());\n                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                             for (Node childNode : childNodes) {\n                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n"}
{"identifier": "Jsoup-67", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 011a704..b07e47f 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -39,7 +39,6 @@ public class HtmlTreeBuilder extends TreeBuilder {\n         \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n         \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"});\n \n-    public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages\n \n     private HtmlTreeBuilderState state; // the current state\n     private HtmlTreeBuilderState originalState; // original / marked state\n@@ -466,9 +465,6 @@ public class HtmlTreeBuilder extends TreeBuilder {\n \n     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n         int depth = stack.size() -1;\n-        if (depth > MaxScopeSearchDepth) {\n-            depth = MaxScopeSearchDepth;\n-        }\n         for (int pos = depth; pos >= 0; pos--) {\n             Element el = stack.get(pos);\n             String elName = el.nodeName();\n"}
{"identifier": "Math-43", "buggy_code": "    /**\n     * Add a value to the data\n     * @param value the value to add\n     */\n    public void addValue(double value) {\n        sumImpl.increment(value);\n        sumsqImpl.increment(value);\n        minImpl.increment(value);\n        maxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        // If mean, variance or geomean have been overridden,\n        // need to increment these\n        if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n        if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }\n        if (!(geoMeanImpl instanceof GeometricMean)) {\n            geoMeanImpl.increment(value);\n        }\n        n++;\n    }\n", "fixed_code": "    /**\n     * Add a value to the data\n     * @param value the value to add\n     */\n    public void addValue(double value) {\n        sumImpl.increment(value);\n        sumsqImpl.increment(value);\n        minImpl.increment(value);\n        maxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        // If mean, variance or geomean have been overridden,\n        // need to increment these\n        if (meanImpl != mean) {\n            meanImpl.increment(value);\n        }\n        if (varianceImpl != variance) {\n            varianceImpl.increment(value);\n        }\n        if (geoMeanImpl != geoMean) {\n            geoMeanImpl.increment(value);\n        }\n        n++;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Add a value to the data\n     * @param value the value to add\n     */\n    public void addValue(double value)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex da987cd..1203d51 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -155,13 +155,13 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (meanImpl != mean) {\n+        if (!(meanImpl instanceof Mean)) {\n             meanImpl.increment(value);\n         }\n-        if (varianceImpl != variance) {\n+        if (!(varianceImpl instanceof Variance)) {\n             varianceImpl.increment(value);\n         }\n-        if (geoMeanImpl != geoMean) {\n+        if (!(geoMeanImpl instanceof GeometricMean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n"}
{"identifier": "Cli-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli2/Option.java b/src/java/org/apache/commons/cli2/Option.java\nindex 0102573..2b53098 100644\n--- a/src/java/org/apache/commons/cli2/Option.java\n+++ b/src/java/org/apache/commons/cli2/Option.java\n@@ -203,7 +203,6 @@ public interface Option {\n      *\n      * @return the parent of this option\n      */\n-    Option getParent();\n \n     /**\n      * Sets the parent of this option. This method is called when the option is\n@@ -214,5 +213,4 @@ public interface Option {\n      *\n      * @param parent the parent option\n      */\n-    void setParent(Option parent);\n }\ndiff --git a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\nindex ec97eab..337eeb6 100644\n--- a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n@@ -71,11 +71,6 @@ public class WriteableCommandLineImpl\n         }\n \n         // ensure that all parent options are also added\n-        Option parent = option.getParent();\n-        while (parent != null && !options.contains(parent)) {\n-            options.add(parent);\n-            parent = parent.getParent();\n-        }\n     }\n \n     public void addValue(final Option option,\ndiff --git a/src/java/org/apache/commons/cli2/option/GroupImpl.java b/src/java/org/apache/commons/cli2/option/GroupImpl.java\nindex 38fc6c2..e3b69f8 100644\n--- a/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n@@ -89,7 +89,6 @@ public class GroupImpl\n         // process the options\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n-            option.setParent(this);\n \n             if (option instanceof Argument) {\n                 i.remove();\ndiff --git a/src/java/org/apache/commons/cli2/option/OptionImpl.java b/src/java/org/apache/commons/cli2/option/OptionImpl.java\nindex f74313d..f75d470 100644\n--- a/src/java/org/apache/commons/cli2/option/OptionImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/OptionImpl.java\n@@ -33,7 +33,6 @@ import org.apache.commons.cli2.resource.ResourceHelper;\n public abstract class OptionImpl implements Option {\n     private final int id;\n     private final boolean required;\n-    private Option parent;\n \n     /**\n      * Creates an OptionImpl with the specified id\n@@ -126,13 +125,7 @@ public abstract class OptionImpl implements Option {\n         // nothing to do normally\n     }\n \n-    public Option getParent() {\n-        return parent;\n-    }\n \n-    public void setParent(Option parent) {\n-        this.parent = parent;\n-    }\n \n     protected void checkPrefixes(final Set prefixes) {\n         // nothing to do if empty prefix list\n"}
{"identifier": "Jsoup-60", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/TokenQueue.java b/src/main/java/org/jsoup/parser/TokenQueue.java\nindex ffcb4a4..fc22b04 100644\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n@@ -286,9 +286,6 @@ public class TokenQueue {\n             last = c;\n         } while (depth > 0);\n         final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n-        if (depth > 0) {// ran out of queue before seeing enough )\n-            Validate.fail(\"Did not find balanced maker at \" + out);\n-        }\n         return out;\n     }\n     \ndiff --git a/src/main/java/org/jsoup/select/QueryParser.java b/src/main/java/org/jsoup/select/QueryParser.java\nindex d3a2041..923cfe9 100644\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n@@ -35,12 +35,8 @@ public class QueryParser {\n      * @return Evaluator\n      */\n     public static Evaluator parse(String query) {\n-        try {\n             QueryParser p = new QueryParser(query);\n             return p.parse();\n-        } catch (IllegalArgumentException e) {\n-            throw new Selector.SelectorParseException(e.getMessage());\n-        }\n     }\n \n     /**\n"}
{"identifier": "Lang-58", "buggy_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex eb74e72..c0f06a4 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,7 +451,8 @@ public class NumberUtils {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && isDigits(numeric.substring(1))\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n"}
{"identifier": "Jsoup-44", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/TreeBuilder.java b/src/main/java/org/jsoup/parser/TreeBuilder.java\nindex c6f5f20..3984e87 100644\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n@@ -58,25 +58,16 @@ abstract class TreeBuilder {\n     protected abstract boolean process(Token token);\n \n     protected boolean processStartTag(String name) {\n-        if (currentToken == start) { // don't recycle an in-use token\n-            return process(new Token.StartTag().name(name));\n-        }\n         return process(start.reset().name(name));\n     }\n \n     public boolean processStartTag(String name, Attributes attrs) {\n-        if (currentToken == start) { // don't recycle an in-use token\n-            return process(new Token.StartTag().nameAttr(name, attrs));\n-        }\n         start.reset();\n         start.nameAttr(name, attrs);\n         return process(start);\n     }\n \n     protected boolean processEndTag(String name) {\n-        if (currentToken == end) { // don't recycle an in-use token\n-            return process(new Token.EndTag().name(name));\n-        }\n         return process(end.reset().name(name));\n     }\n \n"}
{"identifier": "Closure-71", "buggy_code": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = t.inGlobalScope() &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n      if (isOverride) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n\n        // Check that (a) the property *can* be overridden, and\n        // (b) that the visibility of the override is the same as the\n        // visibility of the original property.\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        if (sameInput) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (visibility == Visibility.PRIVATE &&\n            (currentClass == null || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          // private access is not allowed outside the file from a different\n          // enclosing class.\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          // There are 3 types of legal accesses of a protected property:\n          // 1) Accesses in the same file\n          // 2) Overriding the property in a subclass\n          // 3) Accessing the property from inside a subclass\n          // The first two have already been checked for.\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }\n", "fixed_code": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = parent.getJSDocInfo() != null &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n      if (isOverride) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n\n        // Check that (a) the property *can* be overridden, and\n        // (b) that the visibility of the override is the same as the\n        // visibility of the original property.\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        if (sameInput) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (visibility == Visibility.PRIVATE &&\n            (currentClass == null || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          // private access is not allowed outside the file from a different\n          // enclosing class.\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          // There are 3 types of legal accesses of a protected property:\n          // 1) Accesses in the same file\n          // 2) Overriding the property in a subclass\n          // 3) Accessing the property from inside a subclass\n          // The first two have already been checked for.\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CheckAccessControls.java b/src/com/google/javascript/jscomp/CheckAccessControls.java\nindex 09eaa26..b23fd7a 100644\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n@@ -413,7 +413,7 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = parent.getJSDocInfo() != null &&\n+      boolean isOverride = t.inGlobalScope() &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n"}
{"identifier": "Closure-152", "buggy_code": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n", "fixed_code": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex cf2d3e86..fc2578d8 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -868,10 +868,7 @@ public class FunctionType extends PrototypeObjectType {\n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis instanceof ObjectType) {\n-      typeOfThis = (ObjectType) maybeTypeOfThis;\n-    }\n+    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n"}
{"identifier": "Closure-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex e2f0538..26fb230 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -167,23 +167,17 @@ class ScopedAliases implements HotSwapCompilerPass {\n \n   private class AliasedTypeNode implements AliasUsage {\n     private final Node typeReference;\n-    private final Node aliasDefinition;\n     private final String aliasName;\n \n-    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n+    AliasedTypeNode(Node typeReference,\n         String aliasName) {\n       this.typeReference = typeReference;\n-      this.aliasDefinition = aliasDefinition;\n       this.aliasName = aliasName;\n     }\n \n     @Override\n     public void applyAlias() {\n-      String typeName = typeReference.getString();\n-      String aliasExpanded =\n-          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n-      Preconditions.checkState(typeName.startsWith(aliasName));\n-      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n+      typeReference.setString(aliasName);\n     }\n   }\n \n@@ -471,7 +465,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n-          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n+          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n         }\n       }\n \n"}
{"identifier": "JacksonDatabind-88", "buggy_code": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }\n", "fixed_code": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n            }\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\nindex d1418eb0a..142fc3629 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n@@ -55,11 +55,7 @@ public class ClassNameIdResolver\n             //    compatibility -- needed later anyway, and not doing so may open\n             //    security issues.\n             JavaType t = tf.constructFromCanonical(id);\n-            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n                 // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n-                throw new IllegalArgumentException(String.format(\n-                        \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType));\n-            }\n             return t;\n         }\n         Class<?> cls;\n"}
{"identifier": "JacksonDatabind-58", "buggy_code": "    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        if (ctxt.canOverrideAccessModifiers()) {\n            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n            // never needed and attempts may cause problems on some platforms.\n            // !!! NOTE: should be handled better for 2.8 and later\n                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        // did type change?\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n", "fixed_code": "    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        if (ctxt.canOverrideAccessModifiers()) {\n            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n            // never needed and attempts may cause problems on some platforms.\n            // !!! NOTE: should be handled better for 2.8 and later\n            if ((mutator instanceof AnnotatedField)\n                    && \"cause\".equals(mutator.getName())) {\n                ;\n            } else {\n                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        // did type change?\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex 128e46267..df861215c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -712,12 +712,7 @@ public class BeanDeserializerFactory\n             // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n             // never needed and attempts may cause problems on some platforms.\n             // !!! NOTE: should be handled better for 2.8 and later\n-            if ((mutator instanceof AnnotatedField)\n-                    && \"cause\".equals(mutator.getName())) {\n-                ;\n-            } else {\n                 mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-            }\n         }\n         // note: this works since we know there's exactly one argument for methods\n         BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n"}
{"identifier": "Closure-123", "buggy_code": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context,\n            getContextForNoInOperator(context), 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        Context rhsContext = Context.OTHER;\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\n            && TokenStream.isKeyword(last.getString())) {\n          // Check for ECMASCRIPT3 keywords.\n          add(\"[\");\n          add(last);\n          add(\"]\");\n        } else {\n          add(\".\");\n          addIdentifier(last.getString());\n        }\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString()\n                && !(languageMode == LanguageMode.ECMASCRIPT3\n                    && TokenStream.isKeyword(key))\n                && TokenStream.isJSIdentifier(key)\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                && NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n", "fixed_code": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context,\n            getContextForNoInOperator(context), 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        Context rhsContext = getContextForNoInOperator(context);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, rhsContext);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, rhsContext);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\n            && TokenStream.isKeyword(last.getString())) {\n          // Check for ECMASCRIPT3 keywords.\n          add(\"[\");\n          add(last);\n          add(\"]\");\n        } else {\n          add(\".\");\n          addIdentifier(last.getString());\n        }\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString()\n                && !(languageMode == LanguageMode.ECMASCRIPT3\n                    && TokenStream.isKeyword(key))\n                && TokenStream.isJSIdentifier(key)\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                && NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid add(Node n, Context context)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 8d268b6..54eb5cf 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -282,7 +282,7 @@ class CodeGenerator {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = getContextForNoInOperator(context);\n+        Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n"}
{"identifier": "JacksonDatabind-73", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\nindex fd6a613e6..3d36b0ffc 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n@@ -4,7 +4,6 @@ import java.lang.reflect.Modifier;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonAnySetter;\n-import com.fasterxml.jackson.annotation.JsonProperty.Access;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n@@ -729,10 +728,7 @@ public class POJOPropertiesCollector\n         while (it.hasNext()) {\n             POJOPropertyBuilder prop = it.next();\n             // 26-Jan-2017, tatu: [databind#935]: need to denote removal of\n-            Access acc = prop.removeNonVisible(inferMutators);\n-            if (!_forSerialization && (acc == Access.READ_ONLY)) {\n-                _collectIgnorals(prop.getName());\n-            }\n+            prop.removeNonVisible(inferMutators);\n         }\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\nindex b9a403c13..954f5dd46 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n@@ -641,7 +641,7 @@ public class POJOPropertyBuilder\n      * @param inferMutators Whether mutators can be \"pulled in\" by visible\n      *    accessors or not. \n      */\n-    public JsonProperty.Access removeNonVisible(boolean inferMutators)\n+    public void removeNonVisible(boolean inferMutators)\n     {\n         /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition\n          *  of explicit access type for property; if not \"AUTO\", it will\n@@ -680,7 +680,6 @@ public class POJOPropertyBuilder\n                 _setters = _removeNonVisible(_setters);\n             }\n         }\n-        return acc;\n     }\n \n     /**\n"}
{"identifier": "JacksonDatabind-106", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\nindex 151aefaad..2e2b10041 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n@@ -305,18 +305,12 @@ public class TreeTraversingParser extends ParserMinimalBase\n     @Override\n     public int getIntValue() throws IOException {\n         final NumericNode node = (NumericNode) currentNumericNode();\n-        if (!node.canConvertToInt()) {\n-            reportOverflowInt();\n-        }\n         return node.intValue();\n     }\n \n     @Override\n     public long getLongValue() throws IOException {\n         final NumericNode node = (NumericNode) currentNumericNode();\n-        if (!node.canConvertToInt()) {\n-            reportOverflowLong();\n-        }\n         return node.longValue();\n     }\n \n"}
{"identifier": "Collections-26", "buggy_code": "    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    private Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n", "fixed_code": "    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    protected Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    private Object readResolve()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\nindex 2b08d8a7..794677c5 100644\n--- a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\n@@ -274,7 +274,7 @@ public class MultiKey<K> implements Serializable {\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    protected Object readResolve() {\n+    private Object readResolve() {\n         calculateHashCode(keys);\n         return this;\n     }\n"}
{"identifier": "JacksonDatabind-84", "buggy_code": "", "fixed_code": "    @Override\n    public JavaType getSuperClass() {\n    \tif (_referencedType != null) {\n    \t\treturn _referencedType.getSuperClass();\n    \t}\n    \treturn super.getSuperClass();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\nindex 12162c57f..30807836d 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\n@@ -26,13 +26,6 @@ public class ResolvedRecursiveType extends TypeBase\n         _referencedType = ref;\n     }\n    \n-    @Override\n-    public JavaType getSuperClass() {\n-    \tif (_referencedType != null) {\n-    \t\treturn _referencedType.getSuperClass();\n-    \t}\n-    \treturn super.getSuperClass();\n-    }\n \n     public JavaType getSelfReferencedType() { return _referencedType; }\n \n"}
{"identifier": "Math-106", "buggy_code": "    /**\n     * Parses a string to produce a {@link Fraction} object.  This method\n     * expects the string to be formatted as a proper fraction.\n     * <p>\n     * Minus signs are only allowed in the whole number part - i.e.,\n     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n     * will result in a <code>ParseException</code>.\n     * \n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Fraction} object.\n     */\n    public Fraction parse(String source, ParsePosition pos) {\n        // try to parse improper fraction\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        \n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse whole\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n        \n        // parse numerator\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n            // minus signs should be leading, invalid expression\n\n        // parse '/'\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        switch (c) {\n        case 0 :\n            // no '/'\n            // return num as a fraction\n            return new Fraction(num.intValue(), 1);\n        case '/' :\n            // found '/', continue parsing denominator\n            break;\n        default :\n            // invalid '/'\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse denominator\n        Number den = getDenominatorFormat().parse(source, pos);\n        if (den == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n            // minus signs must be leading, invalid\n\n        int w = whole.intValue();\n        int n = num.intValue();\n        int d = den.intValue();\n        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n    }\n", "fixed_code": "    /**\n     * Parses a string to produce a {@link Fraction} object.  This method\n     * expects the string to be formatted as a proper fraction.\n     * <p>\n     * Minus signs are only allowed in the whole number part - i.e.,\n     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n     * will result in a <code>ParseException</code>.\n     * \n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Fraction} object.\n     */\n    public Fraction parse(String source, ParsePosition pos) {\n        // try to parse improper fraction\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        \n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse whole\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n        \n        // parse numerator\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n        if (num.intValue() < 0) {\n            // minus signs should be leading, invalid expression\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse '/'\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        switch (c) {\n        case 0 :\n            // no '/'\n            // return num as a fraction\n            return new Fraction(num.intValue(), 1);\n        case '/' :\n            // found '/', continue parsing denominator\n            break;\n        default :\n            // invalid '/'\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse denominator\n        Number den = getDenominatorFormat().parse(source, pos);\n        if (den == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n        if (den.intValue() < 0) {\n            // minus signs must be leading, invalid\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        int w = whole.intValue();\n        int n = num.intValue();\n        int d = den.intValue();\n        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parses a string to produce a\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\nindex a98b665..df2713d 100644\n--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n@@ -162,11 +162,7 @@ public class ProperFractionFormat extends FractionFormat {\n             return null;\n         }\n         \n-        if (num.intValue() < 0) {\n             // minus signs should be leading, invalid expression\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n \n         // parse '/'\n         int startIndex = pos.getIndex();\n@@ -201,11 +197,7 @@ public class ProperFractionFormat extends FractionFormat {\n             return null;\n         }\n         \n-        if (den.intValue() < 0) {\n             // minus signs must be leading, invalid\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n \n         int w = whole.intValue();\n         int n = num.intValue();\n"}
{"identifier": "Closure-134", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/AmbiguateProperties.java b/src/com/google/javascript/jscomp/AmbiguateProperties.java\nindex 14fe1c32..aad743ff 100644\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n@@ -207,6 +207,7 @@ class AmbiguateProperties implements CompilerPass {\n     for (Property p : propertyMap.values()) {\n       if (!p.skipAmbiguating) {\n         ++numRenamedPropertyNames;\n+        computeRelatedTypes(p.type);\n         propsByFreq.add(p);\n       } else {\n         ++numSkippedPropertyNames;\n@@ -352,7 +353,7 @@ class AmbiguateProperties implements CompilerPass {\n       if (typesRelatedToSet.intersects(prop.typesSet)) {\n         return false;\n       }\n-      return !prop.relatedTypesSet.intersects(typesInSet);\n+      return !getRelated(prop.type).intersects(typesInSet);\n     }\n \n     /**\n@@ -362,7 +363,7 @@ class AmbiguateProperties implements CompilerPass {\n      */\n     public void addNode(Property prop) {\n       typesInSet.or(prop.typesSet);\n-      typesRelatedToSet.or(prop.relatedTypesSet);\n+      typesRelatedToSet.or(getRelated(prop.type));\n     }\n \n     /**\n@@ -549,11 +550,11 @@ class AmbiguateProperties implements CompilerPass {\n   /** Encapsulates the information needed for renaming a property. */\n   private class Property {\n     final String oldName;\n+    JSType type;\n     String newName;\n     int numOccurrences;\n     boolean skipAmbiguating;\n     JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size());\n-    JSTypeBitSet relatedTypesSet = new JSTypeBitSet(intForType.size());\n \n     Property(String name) {\n       this.oldName = name;\n@@ -590,12 +591,12 @@ class AmbiguateProperties implements CompilerPass {\n         return;\n       }\n \n-      int typeInt = getIntForType(newType);\n-      if (!typesSet.get(typeInt)) {\n-        computeRelatedTypes(newType);\n-        typesSet.set(typeInt);\n-        relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));\n+      if (type == null) {\n+        type = newType;\n+      } else {\n+        type = type.getLeastSupertype(newType);\n       }\n+      typesSet.set(getIntForType(newType));\n     }\n   }\n \ndiff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 9d2f7dda..5fdec75e 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -557,17 +557,9 @@ final class TypedScopeCreator implements ScopeCreator {\n       JSType propType = ownerType.getPropertyType(propName);\n       if (propType instanceof FunctionType) {\n         return (FunctionType) propType;\n-      } else {\n+      }\n         // If it's not, then check to see if it's implemented\n         // on an implemented interface.\n-        for (ObjectType iface :\n-                 ownerType.getCtorImplementedInterfaces()) {\n-          propType = iface.getPropertyType(propName);\n-          if (propType instanceof FunctionType) {\n-            return (FunctionType) propType;\n-          }\n-        }\n-      }\n \n       return null;\n     }\n"}
{"identifier": "Math-75", "buggy_code": "    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n    }\n", "fixed_code": "    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getPct(Object v) {\n        return getPct((Comparable<?>) v);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex 68c8bf2..c45d728 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getPct((Comparable<?>) v);\n+        return getCumPct((Comparable<?>) v);\n     }\n \n     /**\n"}
{"identifier": "JacksonDatabind-10", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\nindex 9fe4077cd..2cd7bb7b6 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n@@ -21,20 +21,16 @@ public class AnyGetterWriter\n      */\n     protected final AnnotatedMember _accessor;\n \n-    protected JsonSerializer<Object> _serializer;\n \n     protected MapSerializer _mapSerializer;\n     \n     @SuppressWarnings(\"unchecked\")\n     public AnyGetterWriter(BeanProperty property,\n-            AnnotatedMember accessor, JsonSerializer<?> serializer)\n+            AnnotatedMember accessor, MapSerializer serializer)\n     {\n         _accessor = accessor;\n         _property = property;\n-        _serializer = (JsonSerializer<Object>) serializer;\n-        if (serializer instanceof MapSerializer) {\n             _mapSerializer = (MapSerializer) serializer;\n-        }\n     }\n \n     public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n@@ -53,7 +49,6 @@ public class AnyGetterWriter\n             _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);\n             return;\n         }\n-        _serializer.serialize(value, gen, provider);\n     }\n \n     /**\n@@ -77,7 +72,6 @@ public class AnyGetterWriter\n             return;\n         }\n         // ... not sure how custom handler would do it\n-        _serializer.serialize(value, gen, provider);\n     }\n     \n     // Note: NOT part of ResolvableSerializer...\n@@ -85,12 +79,6 @@ public class AnyGetterWriter\n     public void resolve(SerializerProvider provider) throws JsonMappingException\n     {\n         // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-        if (_serializer instanceof ContextualSerializer) {\n-            JsonSerializer<?> ser = provider.handlePrimaryContextualization(_serializer, _property);\n-            _serializer = (JsonSerializer<Object>) ser;\n-            if (ser instanceof MapSerializer) {\n-                _mapSerializer = (MapSerializer) ser;\n-            }\n-        }\n+        _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n     }\n }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\nindex ec540cc6d..25e7e3f93 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n@@ -392,12 +392,8 @@ public class BeanSerializerFactory\n             TypeSerializer typeSer = createTypeSerializer(config, valueType);\n             // last 2 nulls; don't know key, value serializers (yet)\n             // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);\n-            if (anySer == null) {\n+            MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n                 // TODO: support '@JsonIgnoreProperties' with any setter?\n-                anySer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n-                        typeSer, null, null, /*filterId*/ null);\n-            }\n             // TODO: can we find full PropertyName?\n             PropertyName name = new PropertyName(anyGetter.getName());\n             BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,\n"}
{"identifier": "Jsoup-34", "buggy_code": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n", "fixed_code": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex f8e0eb0..dc1b114 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -88,7 +88,7 @@ class CharacterReader {\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length && last <= length) {\n+            if (offset < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n"}
{"identifier": "Compress-44", "buggy_code": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\n        this.checksum = checksum;\n        this.in = in;\n    }\n", "fixed_code": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n        if ( checksum == null ){\n            throw new NullPointerException(\"Parameter checksum must not be null\");\n        }\n\n        if ( in == null ){\n            throw new NullPointerException(\"Parameter in must not be null\");\n        }\n\n        this.checksum = checksum;\n        this.in = in;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\nindex 4a408a56..10c7d68d 100644\n--- a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n@@ -32,13 +32,7 @@\n \n     public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n \n-        if ( checksum == null ){\n-            throw new NullPointerException(\"Parameter checksum must not be null\");\n-        }\n \n-        if ( in == null ){\n-            throw new NullPointerException(\"Parameter in must not be null\");\n-        }\n \n         this.checksum = checksum;\n         this.in = in;\n"}
{"identifier": "Closure-126", "buggy_code": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n", "fixed_code": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function ()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex bc9befe..4146f17 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,6 +138,10 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n+      if (NodeUtil.hasFinally(n)) {\n+        Node finallyBlock = n.getLastChild();\n+        tryMinimizeExits(finallyBlock, exitType, labelName);\n+      }\n     }\n \n     // Just a 'label'.\n"}
{"identifier": "JacksonDatabind-59", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/JavaType.java b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\nindex 292cc3939..4ac467b34 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n@@ -137,18 +137,6 @@ public abstract class JavaType\n      *\n      * @since 2.8.4\n      */\n-    public JavaType withHandlersFrom(JavaType src) {\n-        JavaType type = this;\n-        Object h = src.getTypeHandler();\n-        if (h != _typeHandler) {\n-            type = type.withTypeHandler(h);\n-        }\n-        h = src.getValueHandler();\n-        if (h != _valueHandler) {\n-            type = type.withValueHandler(h);\n-        }\n-        return type;\n-    }\n \n     /**\n      * Mutant factory method that may be called on structured types\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\nindex f35516036..be19bdfcd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n@@ -133,18 +133,6 @@ public class CollectionLikeType extends TypeBase\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n \n-    @Override\n-    public JavaType withHandlersFrom(JavaType src) {\n-        JavaType type = super.withHandlersFrom(src);\n-        JavaType srcCt = src.getContentType();\n-        if (srcCt != null) {\n-            JavaType ct = _elementType.withHandlersFrom(srcCt);\n-            if (ct != _elementType) {\n-                type = type.withContentType(ct);\n-            }\n-        }\n-        return type;\n-    }\n     \n     @Override\n     public CollectionLikeType withStaticTyping() {\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\nindex f1d1ee088..e10ae4ca3 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n@@ -145,28 +145,7 @@ public class MapLikeType extends TypeBase {\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n \n-    @Override\n-    public JavaType withHandlersFrom(JavaType src) {\n-        JavaType type = super.withHandlersFrom(src);\n-        JavaType srcKeyType = src.getKeyType();\n         // \"withKeyType()\" not part of JavaType, hence must verify:\n-        if (type instanceof MapLikeType) {\n-            if (srcKeyType != null) {\n-                JavaType ct = _keyType.withHandlersFrom(srcKeyType);\n-                if (ct != _keyType) {\n-                    type = ((MapLikeType) type).withKeyType(ct);\n-                }\n-            }\n-        }\n-        JavaType srcCt = src.getContentType();\n-        if (srcCt != null) {\n-            JavaType ct = _valueType.withHandlersFrom(srcCt);\n-            if (ct != _valueType) {\n-                type = type.withContentType(ct);\n-            }\n-        }\n-        return type;\n-    }\n \n     @Override\n     public MapLikeType withStaticTyping() {\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\nindex b8acda873..8bf10e83f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n@@ -425,7 +425,6 @@ public final class TypeFactory\n \n         // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n         //   copied as well\n-        newType = newType.withHandlersFrom(baseType);\n         return newType;\n \n         // 20-Oct-2015, tatu: Old simplistic approach\n"}
{"identifier": "Collections-27", "buggy_code": "", "fixed_code": "        private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {\n            is.defaultReadObject();\n            // ensure that the de-serialized class is a Collection, COLLECTIONS-580\n            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n                throw new UnsupportedOperationException();\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java b/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java\nindex 3c690ab0..d131af27 100644\n--- a/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java\n@@ -565,13 +565,6 @@ public class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> impleme\n             }\n         }\n \n-        private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {\n-            is.defaultReadObject();\n-            // ensure that the de-serialized class is a Collection, COLLECTIONS-580\n-            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n-                throw new UnsupportedOperationException();\n-            }\n-        }\n     }\n \n }\n"}
{"identifier": "Mockito-31", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\nindex 4942d7c..10d3b0f 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n@@ -6,7 +6,6 @@ package org.mockito.internal.stubbing.defaultanswers;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n-import java.util.Arrays;\n \n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.MethodInterceptor;\n@@ -58,8 +57,7 @@ public class ReturnsSmartNulls implements Answer<Object>, Serializable {\n         }\n \n \t\tprivate String formatMethodCall() {\n-\t\t\tString args = Arrays.toString(invocation.getArguments());\n-\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\n+\t\t\treturn invocation.getMethod().getName() + \"()\";\n \t\t}\n     }\n \n"}
{"identifier": "Closure-20", "buggy_code": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }\n", "fixed_code": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate Node tryFoldSimpleFunctionCall(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 86521bd..bfa1707 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -217,8 +217,7 @@ class PeepholeSubstituteAlternateSyntax\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null && value.getNext() == null &&\n-          NodeUtil.isImmutableValue(value)) {\n+      if (value != null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n"}
{"identifier": "JacksonCore-25", "buggy_code": "    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n", "fixed_code": "    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex f38e4aae..2c1f5a23 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -1960,7 +1960,7 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i < maxCode) {\n+            if (i <= maxCode) {\n                 if (codes[i] != 0) {\n                     break;\n                 }\n"}
{"identifier": "Closure-34", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex d50320a..f28378c 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -119,7 +119,9 @@ class CodeGenerator {\n         cc.addOp(opstr, true);\n         addExpr(last, p, rhsContext);\n       } else {\n-        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n+        addExpr(first, p, context);\n+        cc.addOp(opstr, true);\n+        addExpr(last, p + 1, rhsContext);\n       }\n       return;\n     }\n@@ -749,7 +751,7 @@ class CodeGenerator {\n     Node current = firstNonOperator;\n     do {\n       current = current.getParent();\n-      cc.addOp(opStr, true);\n+      cc.listSeparator();\n       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n     } while (current != n);\n   }\ndiff --git a/src/com/google/javascript/jscomp/CodePrinter.java b/src/com/google/javascript/jscomp/CodePrinter.java\nindex 31c62d9..52dfa9b 100644\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n@@ -331,7 +331,7 @@ class CodePrinter {\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n-        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n+        if (getLastChar() != ' ') {\n           append(\" \");\n         }\n         append(op);\n"}
{"identifier": "Closure-59", "buggy_code": "  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n", "fixed_code": "  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 1d6e494..b3ca246 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -252,8 +252,7 @@ public class Compiler extends AbstractCompiler {\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn() &&\n-        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n+    if (options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n"}
{"identifier": "JacksonXml-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\nindex 5e03896..fe37ee9 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n@@ -59,7 +59,6 @@ public class XmlTokenStream\n      *\n      * @since 2.8\n      */\n-    protected boolean _mixedText;\n \n     /**\n      * Index of the next attribute of the current START_ELEMENT\n@@ -322,24 +321,15 @@ public class XmlTokenStream\n             }\n             // otherwise need to find START/END_ELEMENT or text\n             String text = _collectUntilTag();\n-            final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT;\n             // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n-            if (startElementNext) {\n-                if (text == null || _allWs(text)) {\n-                    _mixedText = false;\n+            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n                     return _initStartElement();\n-                }\n-                _mixedText = true;\n-                _textValue = text;\n-                return (_currentState = XML_TEXT);\n             }\n             // For END_ELEMENT we will return text, if any\n             if (text != null) {\n-                _mixedText = false;\n                 _textValue = text;\n                 return (_currentState = XML_TEXT);\n             }\n-            _mixedText = false;\n             return _handleEndElement();\n \n         case XML_ATTRIBUTE_NAME:\n@@ -347,10 +337,6 @@ public class XmlTokenStream\n             return (_currentState = XML_ATTRIBUTE_VALUE);\n         case XML_TEXT:\n             // mixed text with other elements\n-            if (_mixedText){\n-                _mixedText = false;\n-                return _initStartElement();\n-            }\n             // text followed by END_ELEMENT\n             return _handleEndElement();\n         case XML_END:\n@@ -517,18 +503,6 @@ public class XmlTokenStream\n     }\n \n \n-    protected boolean _allWs(String str)\n-    {\n-        final int len = (str == null) ? 0 : str.length();\n-        if (len > 0) {\n-            for (int i = 0; i < len; ++i) {\n-                if (str.charAt(i) > ' ') {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n     \n     // for DEBUGGING\n     @Override\n"}
{"identifier": "JxPath-8", "buggy_code": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n", "fixed_code": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        if (Double.isNaN(ld)) {\n            return false;\n        }\n        double rd = InfoSetUtil.doubleValue(right);\n        if (Double.isNaN(rd)) {\n            return false;\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate boolean compute(Object left, Object right)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\nindex 3711fb9..c6e0041 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n@@ -73,13 +73,7 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n             return containsMatch((Iterator) right, left);\n         }\n         double ld = InfoSetUtil.doubleValue(left);\n-        if (Double.isNaN(ld)) {\n-            return false;\n-        }\n         double rd = InfoSetUtil.doubleValue(right);\n-        if (Double.isNaN(rd)) {\n-            return false;\n-        }\n         return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n     }\n \n"}
{"identifier": "Closure-130", "buggy_code": "  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }\n", "fixed_code": "  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex f86625f..ab2d2c7 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,7 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n+      if (name.globalSets == 1 && name.localSets == 0 &&\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n"}
{"identifier": "JacksonDatabind-49", "buggy_code": "    public Object generateId(Object forPojo) {\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n        //    need to use existing id if there is one:\n            id = generator.generateId(forPojo);\n        return id;\n    }\n", "fixed_code": "    public Object generateId(Object forPojo) {\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n        //    need to use existing id if there is one:\n        if (id == null) {\n            id = generator.generateId(forPojo);\n        }\n        return id;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic Object generateId(Object forPojo)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\nindex d84269445..af141e12a 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n@@ -47,9 +47,7 @@ public final class WritableObjectId\n         // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n         //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n         //    need to use existing id if there is one:\n-        if (id == null) {\n             id = generator.generateId(forPojo);\n-        }\n         return id;\n     }\n \n"}
{"identifier": "Mockito-30", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/exceptions/Reporter.java b/src/org/mockito/exceptions/Reporter.java\nindex 5900574..5e46a2b 100644\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n@@ -435,11 +435,10 @@ public class Reporter {\n                 ));\n     }\n \n-    public void smartNullPointerException(Object obj, Location location) {\n+    public void smartNullPointerException(Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n-                obj,\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"\ndiff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\nindex 928f314..4942d7c 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n@@ -53,7 +53,7 @@ public class ReturnsSmartNulls implements Answer<Object>, Serializable {\n                 return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n             }\n \n-            new Reporter().smartNullPointerException(obj, location);\n+            new Reporter().smartNullPointerException(location);\n             return null;\n         }\n \n"}
{"identifier": "Csv-13", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 8c71f3a..847f30a 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -316,7 +316,7 @@ public final class CSVFormat implements Serializable {\n      *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n     public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n-            .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");\n+            .withQuote(null).withRecordSeparator(LF);\n \n     /**\n      * Returns true if the given character is a line break character.\ndiff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex 0e9a2de..ac4234b 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -136,9 +136,7 @@ public final class CSVPrinter implements Flushable, Closeable {\n         if (!newRecord) {\n             out.append(format.getDelimiter());\n         }\n-        if (object == null) {\n-            out.append(value);\n-        } else if (format.isQuoteCharacterSet()) {\n+        if (format.isQuoteCharacterSet()) {\n             // the original object is needed so can check for Number\n             printAndQuote(object, value, offset, len);\n         } else if (format.isEscapeCharacterSet()) {\n"}
{"identifier": "Closure-169", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/ArrowType.java b/src/com/google/javascript/rhino/jstype/ArrowType.java\nindex 8919efa1a..c4109b08f 100644\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n@@ -174,7 +174,7 @@ final class ArrowType extends JSType {\n    * @return True if our parameter spec is equal to {@code that}'s parameter\n    *     spec.\n    */\n-  boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {\n+  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n     Node thisParam = parameters.getFirstChild();\n     Node otherParam = that.parameters.getFirstChild();\n     while (thisParam != null && otherParam != null) {\n@@ -184,7 +184,7 @@ final class ArrowType extends JSType {\n         // Both parameter lists give a type for this param, it should be equal\n         if (otherParamType != null &&\n             !thisParamType.checkEquivalenceHelper(\n-                otherParamType, eqMethod)) {\n+                otherParamType, tolerateUnknowns)) {\n           return false;\n         }\n       } else {\n@@ -201,12 +201,12 @@ final class ArrowType extends JSType {\n   }\n \n   boolean checkArrowEquivalenceHelper(\n-      ArrowType that, EquivalenceMethod eqMethod) {\n+      ArrowType that, boolean tolerateUnknowns) {\n     // Please keep this method in sync with the hashCode() method below.\n-    if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) {\n+    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n       return false;\n     }\n-    return hasEqualParameters(that, eqMethod);\n+    return hasEqualParameters(that, tolerateUnknowns);\n   }\n \n   @Override\ndiff --git a/src/com/google/javascript/rhino/jstype/EquivalenceMethod.java b/src/com/google/javascript/rhino/jstype/EquivalenceMethod.java\ndeleted file mode 100644\nindex b6c374457..000000000\n--- a/src/com/google/javascript/rhino/jstype/EquivalenceMethod.java\n+++ /dev/null\n@@ -1,83 +0,0 @@\n-/*\n- *\n- * ***** BEGIN LICENSE BLOCK *****\n- * Version: MPL 1.1/GPL 2.0\n- *\n- * The contents of this file are subject to the Mozilla Public License Version\n- * 1.1 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- * http://www.mozilla.org/MPL/\n- *\n- * Software distributed under the License is distributed on an \"AS IS\" basis,\n- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n- * for the specific language governing rights and limitations under the\n- * License.\n- *\n- * The Original Code is Rhino code, released\n- * May 6, 1999.\n- *\n- * The Initial Developer of the Original Code is\n- * Netscape Communications Corporation.\n- * Portions created by the Initial Developer are Copyright (C) 1997-1999\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Nick Santos\n- *   Google Inc.\n- *\n- * Alternatively, the contents of this file may be used under the terms of\n- * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n- * case the provisions of the GPL are applicable instead of those above. If\n- * you wish to allow use of your version of this file only under the terms of\n- * the GPL and not to allow others to use your version of this file under the\n- * MPL, indicate your decision by deleting the provisions above and replacing\n- * them with the notice and other provisions required by the GPL. If you do\n- * not delete the provisions above, a recipient may use your version of this\n- * file under either the MPL or the GPL.\n- *\n- * ***** END LICENSE BLOCK ***** */\n-\n-package com.google.javascript.rhino.jstype;\n-\n-/**\n- * Represents different ways for comparing equality among types.\n- * @author nicksantos@google.com (Nick Santos)\n- */\n-enum EquivalenceMethod {\n-  /**\n-   * Indicates that the two types should behave exactly the same under\n-   * all type operations.\n-   *\n-   * Thus, {string} != {?} and {Unresolved} != {?}\n-   */\n-  IDENTITY,\n-\n-  /**\n-   * Indicates that the two types are almost exactly the same, and that a\n-   * data flow analysis algorithm comparing them should consider them equal.\n-   *\n-   * In traditional type inference, the types form a finite lattice, and this\n-   * ensures that type inference will terminate.\n-   *\n-   * In our type system, the unknown types do not obey the lattice rules. So\n-   * if we continue to perform inference over the unknown types, we may\n-   * never terminate.\n-   *\n-   * By treating all unknown types as equivalent for the purposes of data\n-   * flow analysis, we ensure that the algorithm will terminate.\n-   *\n-   * Thus, {string} != {?} and {Unresolved} ~= {?}\n-   */\n-  DATA_FLOW,\n-\n-  /**\n-   * Indicates that two types are invariant.\n-   *\n-   * In a type system without unknown types, this would be the same\n-   * as IDENTITY. But we always want to consider type A invariant with type B\n-   * if B is unknown.\n-   *\n-   * Thus, {string} ~= {?} and {Unresolved} ~= {?}\n-   */\n-  INVARIANT\n-}\ndiff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex 4c62e156c..e354e564d 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -789,7 +789,7 @@ public class FunctionType extends PrototypeObjectType {\n   private FunctionType tryMergeFunctionPiecewise(\n       FunctionType other, boolean leastSuper) {\n     Node newParamsNode = null;\n-    if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {\n+    if (call.hasEqualParameters(other.call, false)) {\n       newParamsNode = call.parameters;\n     } else {\n       // If the parameters are not equal, don't try to merge them.\n@@ -887,7 +887,7 @@ public class FunctionType extends PrototypeObjectType {\n    * have signatures, two interfaces are equal if their names match.\n    */\n   boolean checkFunctionEquivalenceHelper(\n-      FunctionType that, EquivalenceMethod eqMethod) {\n+      FunctionType that, boolean tolerateUnknowns) {\n     if (isConstructor()) {\n       if (that.isConstructor()) {\n         return this == that;\n@@ -905,8 +905,8 @@ public class FunctionType extends PrototypeObjectType {\n     }\n \n     return typeOfThis.checkEquivalenceHelper(\n-        that.typeOfThis, eqMethod) &&\n-        call.checkArrowEquivalenceHelper(that.call, eqMethod);\n+        that.typeOfThis, tolerateUnknowns) &&\n+        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n   }\n \n   @Override\n@@ -915,8 +915,7 @@ public class FunctionType extends PrototypeObjectType {\n   }\n \n   public boolean hasEqualCallType(FunctionType otherType) {\n-    return this.call.checkArrowEquivalenceHelper(\n-        otherType.call, EquivalenceMethod.IDENTITY);\n+    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n   }\n \n   /**\ndiff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex 9c8e98979..081a3d768 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -489,7 +489,7 @@ public abstract class JSType implements Serializable {\n    * Checks if two types are equivalent.\n    */\n   public final boolean isEquivalentTo(JSType that) {\n-    return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);\n+    return checkEquivalenceHelper(that, false);\n   }\n \n   /**\n@@ -497,7 +497,7 @@ public abstract class JSType implements Serializable {\n    * @see EquivalenceMethod\n    */\n   public final boolean isInvariant(JSType that) {\n-    return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);\n+    return checkEquivalenceHelper(that, false);\n   }\n \n   /**\n@@ -511,13 +511,13 @@ public abstract class JSType implements Serializable {\n    *     unknowns</a>\n    */\n   public final boolean differsFrom(JSType that) {\n-    return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW);\n+    return !checkEquivalenceHelper(that, true);\n   }\n \n   /**\n    * An equivalence visitor.\n    */\n-  boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {\n+  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n     if (this == that) {\n       return true;\n     }\n@@ -525,11 +525,9 @@ public abstract class JSType implements Serializable {\n     boolean thisUnknown = isUnknownType();\n     boolean thatUnknown = that.isUnknownType();\n     if (thisUnknown || thatUnknown) {\n-      if (eqMethod == EquivalenceMethod.INVARIANT) {\n+      if (tolerateUnknowns) {\n         // If we're checking for invariance, the unknown type is invariant\n         // with everyone.\n-        return true;\n-      } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {\n         // If we're checking data flow, then two types are the same if they're\n         // both unknown.\n         return thisUnknown && thatUnknown;\n@@ -544,17 +542,17 @@ public abstract class JSType implements Serializable {\n \n     if (isUnionType() && that.isUnionType()) {\n       return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n-          that.toMaybeUnionType(), eqMethod);\n+          that.toMaybeUnionType(), tolerateUnknowns);\n     }\n \n     if (isFunctionType() && that.isFunctionType()) {\n       return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n-          that.toMaybeFunctionType(), eqMethod);\n+          that.toMaybeFunctionType(), tolerateUnknowns);\n     }\n \n     if (isRecordType() && that.isRecordType()) {\n       return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n-          that.toMaybeRecordType(), eqMethod);\n+          that.toMaybeRecordType(), tolerateUnknowns);\n     }\n \n     ParameterizedType thisParamType = toMaybeParameterizedType();\n@@ -564,14 +562,14 @@ public abstract class JSType implements Serializable {\n       boolean paramsMatch = false;\n       if (thisParamType != null && thatParamType != null) {\n         paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n-            thatParamType.getParameterType(), eqMethod);\n-      } else if (eqMethod == EquivalenceMethod.IDENTITY) {\n-        paramsMatch = false;\n-      } else {\n+            thatParamType.getParameterType(), tolerateUnknowns);\n+      } else if (tolerateUnknowns) {\n         // If one of the type parameters is unknown, but the other is not,\n         // then we consider these the same for the purposes of data flow\n         // and invariance.\n         paramsMatch = true;\n+      } else {\n+        paramsMatch = false;\n       }\n \n       JSType thisRootType = thisParamType == null ?\n@@ -579,7 +577,7 @@ public abstract class JSType implements Serializable {\n       JSType thatRootType = thatParamType == null ?\n           that : thatParamType.getReferencedTypeInternal();\n       return paramsMatch &&\n-          thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);\n+          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n     }\n \n     if (isNominalType() && that.isNominalType()) {\n@@ -591,13 +589,13 @@ public abstract class JSType implements Serializable {\n     if (this instanceof ProxyObjectType) {\n       return ((ProxyObjectType) this)\n           .getReferencedTypeInternal().checkEquivalenceHelper(\n-              that, eqMethod);\n+              that, tolerateUnknowns);\n     }\n \n     if (that instanceof ProxyObjectType) {\n       return checkEquivalenceHelper(\n           ((ProxyObjectType) that).getReferencedTypeInternal(),\n-          eqMethod);\n+          tolerateUnknowns);\n     }\n \n     // Relies on the fact that for the base {@link JSType}, only one\ndiff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nindex d70db704f..50423d5b1 100755\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -115,7 +115,7 @@ class RecordType extends PrototypeObjectType {\n   }\n \n   boolean checkRecordEquivalenceHelper(\n-      RecordType otherRecord, EquivalenceMethod eqMethod) {\n+      RecordType otherRecord, boolean tolerateUnknowns) {\n     Set<String> keySet = properties.keySet();\n     Map<String, JSType> otherProps = otherRecord.properties;\n     if (!otherProps.keySet().equals(keySet)) {\n@@ -123,7 +123,7 @@ class RecordType extends PrototypeObjectType {\n     }\n     for (String key : keySet) {\n       if (!otherProps.get(key).checkEquivalenceHelper(\n-              properties.get(key), eqMethod)) {\n+              properties.get(key), tolerateUnknowns)) {\n         return false;\n       }\n     }\n@@ -201,7 +201,8 @@ class RecordType extends PrototypeObjectType {\n           JSType altPropType = alt.getPropertyType(propName);\n           if (altPropType != null && !alt.isEquivalentTo(this) &&\n               alt.isSubtype(that) &&\n-              propType.isInvariant(altPropType)) {\n+              (propType.isUnknownType() || altPropType.isUnknownType() ||\n+                  altPropType.isEquivalentTo(propType))) {\n             builder.addAlternate(alt);\n           }\n         }\n@@ -264,6 +265,7 @@ class RecordType extends PrototypeObjectType {\n \n       JSType propA = typeA.getPropertyType(property);\n       JSType propB = typeB.getPropertyType(property);\n+      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n       if (typeA.isPropertyTypeDeclared(property)) {\n         // If one declared property isn't invariant,\n         // then the whole record isn't covariant.\n@@ -275,6 +277,7 @@ class RecordType extends PrototypeObjectType {\n         // then the whole record isn't covariant.\n         if (!propA.isSubtype(propB)) {\n           return false;\n+          }\n         }\n       }\n     }\ndiff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex 0fd8b2470..5a816988d 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -331,22 +331,22 @@ public class UnionType extends JSType {\n    * and all alternates are equal.\n    */\n   boolean checkUnionEquivalenceHelper(\n-      UnionType that, EquivalenceMethod eqMethod) {\n-    if (eqMethod == EquivalenceMethod.IDENTITY\n+      UnionType that, boolean tolerateUnknowns) {\n+    if (!tolerateUnknowns\n         && alternates.size() != that.alternates.size()) {\n       return false;\n     }\n     for (JSType alternate : that.alternates) {\n-      if (!hasAlternate(alternate, eqMethod)) {\n+      if (!hasAlternate(alternate, tolerateUnknowns)) {\n         return false;\n       }\n     }\n     return true;\n   }\n \n-  private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) {\n+  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n     for (JSType alternate : alternates) {\n-      if (alternate.checkEquivalenceHelper(type, eqMethod)) {\n+      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n         return true;\n       }\n     }\n"}
{"identifier": "Compress-17", "buggy_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NULs or spaces\n        trailer = buffer[end - 1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "fixed_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NULs or spaces\n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 0a383367..c5532494 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -132,9 +132,8 @@ public class TarUtils {\n         }\n         // May have additional NULs or spaces\n         trailer = buffer[end - 1];\n-        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n+        if (trailer == 0 || trailer == ' '){\n             end--;\n-            trailer = buffer[end - 1];\n         }\n \n         for ( ;start < end; start++) {\n"}
{"identifier": "Closure-168", "buggy_code": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 2) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }\n", "fixed_code": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 1) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n          // Be careful of bleeding functions, which create variables\n          // in the inner scope, not the scope where the name appears.\n          !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override public void visit(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 36f83466e..cf87eaaf0 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1993,7 +1993,7 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 1) {\n+      if (t.getScopeDepth() <= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n"}
{"identifier": "Chart-26", "buggy_code": "    /**\n     * Draws the axis label.\n     *\n     * @param label  the label text.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     * @param state  the axis state (<code>null</code> not permitted).\n     * @param plotState  the plot state (<code>null</code> permitted).\n     *\n     * @return Information about the axis.\n     */\n    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }\n", "fixed_code": "    /**\n     * Draws the axis label.\n     *\n     * @param label  the label text.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     * @param state  the axis state (<code>null</code> not permitted).\n     * @param plotState  the plot state (<code>null</code> permitted).\n     *\n     * @return Information about the axis.\n     */\n    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n            if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n            }\n        }\n        return state;\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Draws the axis label.\n     *\n     * @param label  the label text.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     * @param state  the axis state (<code>null</code> not permitted).\n     * @param plotState  the plot state (<code>null</code> permitted).\n     *\n     * @return Information about the axis.\n     */\n    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/axis/Axis.java b/source/org/jfree/chart/axis/Axis.java\nindex 3f74811..78a6c66 100644\n--- a/source/org/jfree/chart/axis/Axis.java\n+++ b/source/org/jfree/chart/axis/Axis.java\n@@ -1189,13 +1189,11 @@ public abstract class Axis implements Cloneable, Serializable {\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n-            if (owner != null) {\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n                 }\n-            }\n         }\n         return state;\n \n"}
{"identifier": "JxPath-11", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\nindex f9785f6..f4c2ac6 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n@@ -19,7 +19,6 @@ package org.apache.commons.jxpath.ri.model.dom;\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.commons.jxpath.ri.NamespaceResolver;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n@@ -109,9 +108,7 @@ public class DOMAttributeIterator implements NodeIterator {\n         String testNS = null;\n \n         if (testPrefix != null) {\n-            NamespaceResolver nsr = parent.getNamespaceResolver();\n-            testNS = nsr == null ? null : nsr.getNamespaceURI(testPrefix);\n-            testNS = testNS == null ? parent.getNamespaceURI(testPrefix) : testNS;\n+            testNS = parent.getNamespaceURI(testPrefix);\n         }\n \n         if (testNS != null) {\ndiff --git a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\nindex 84c0afd..cfa6da3 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n@@ -20,7 +20,6 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n-import org.apache.commons.jxpath.ri.NamespaceResolver;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n@@ -50,21 +49,12 @@ public class JDOMAttributeIterator implements NodeIterator {\n                     ns = Namespace.XML_NAMESPACE;\n                 }\n                 else {\n-                    NamespaceResolver nsr = parent.getNamespaceResolver();\n-                    if (nsr != null) {\n-                        String uri = nsr.getNamespaceURI(prefix);\n-                        if (uri != null) {\n-                            ns = Namespace.getNamespace(prefix, uri);\n-                        }\n-                    }\n-                    if (ns == null) {\n                         ns = element.getNamespace(prefix);\n                         if (ns == null) {\n                             // TBD: no attributes\n                             attributes = Collections.EMPTY_LIST;\n                             return;\n                         }\n-                    }\n                 }\n             }\n             else {\n@@ -121,4 +111,4 @@ public class JDOMAttributeIterator implements NodeIterator {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "JacksonXml-1", "buggy_code": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                    //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                /* One more refinement (pronunced like \"hack\") is that if\n                 * we had an empty String (or all white space), and we are\n                 * deserializing an array, we better hide the empty text.\n                 */\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        \n        // should never get here\n        _throwInternal();\n        return null;\n    }\n", "fixed_code": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                if (_parsingContext.inArray()) {\n                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                    //    expose as empty Object, not null\n                    _nextToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                /* One more refinement (pronunced like \"hack\") is that if\n                 * we had an empty String (or all white space), and we are\n                 * deserializing an array, we better hide the empty text.\n                 */\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        \n        // should never get here\n        _throwInternal();\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public JsonToken nextToken() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\nindex 58618b4..91b14dd 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n@@ -509,13 +509,8 @@ public class FromXmlParser\n             // Simple, except that if this is a leaf, need to suppress end:\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n-                if (_parsingContext.inArray()) {\n                     // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                     //    expose as empty Object, not null\n-                    _nextToken = JsonToken.END_OBJECT;\n-                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n-                    return (_currToken = JsonToken.START_OBJECT);\n-                }\n                 return (_currToken = JsonToken.VALUE_NULL);\n             }\n             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n@@ -552,9 +547,10 @@ public class FromXmlParser\n                         // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                         //    expose as empty Object, not null (or, worse, as used to\n                         //    be done, by swallowing the token)\n-                        _nextToken = JsonToken.END_OBJECT;\n-                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n-                        return (_currToken = JsonToken.START_OBJECT);\n+                        _currToken = JsonToken.END_ARRAY;\n+                        _parsingContext = _parsingContext.getParent();\n+                        _namesToWrap = _parsingContext.getNamesToWrap();\n+                        return _currToken;\n                     }\n                 }\n                 return (_currToken = JsonToken.VALUE_STRING);\n"}
{"identifier": "Compress-18", "buggy_code": "    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n", "fixed_code": "    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        while (name.endsWith(\"/\")) {\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n            name = name.substring(0, name.length() - 1);\n        }\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\nindex 5a7e4a3b..4c57133d 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n@@ -454,11 +454,8 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n     void writePaxHeaders(String entryName,\n                          Map<String, String> headers) throws IOException {\n         String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n-        while (name.endsWith(\"/\")) {\n             // TarEntry's constructor would think this is a directory\n             // and not allow any data to be written\n-            name = name.substring(0, name.length() - 1);\n-        }\n         if (name.length() >= TarConstants.NAMELEN) {\n             name = name.substring(0, TarConstants.NAMELEN - 1);\n         }\n"}
{"identifier": "Gson-1", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/TypeInfoFactory.java b/gson/src/main/java/com/google/gson/TypeInfoFactory.java\nindex 3085e8a..eaf3a10 100644\n--- a/gson/src/main/java/com/google/gson/TypeInfoFactory.java\n+++ b/gson/src/main/java/com/google/gson/TypeInfoFactory.java\n@@ -90,16 +90,8 @@ final class TypeInfoFactory {\n         int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n         Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n         return actualTypeArguments[indexOfActualTypeArgument];\n-      } else if (typeToEvaluate instanceof TypeVariable<?>) {\n-        Type theSearchedType = null;\n \n-        do {\n-          theSearchedType = extractTypeForHierarchy(parentType, (TypeVariable<?>) typeToEvaluate);\n-        } while ((theSearchedType != null) && (theSearchedType instanceof TypeVariable<?>));\n \n-        if (theSearchedType != null) {\n-          return theSearchedType;\n-        }\n       }\n \n       throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n@@ -114,43 +106,11 @@ final class TypeInfoFactory {\n     }\n   }\n \n-  private static Type extractTypeForHierarchy(Type parentType, TypeVariable<?> typeToEvaluate) {\n-    Class<?> rawParentType = null;\n-    if (parentType instanceof Class<?>) {\n-      rawParentType = (Class<?>) parentType;\n-    } else if (parentType instanceof ParameterizedType) {\n-      ParameterizedType parentTypeAsPT = (ParameterizedType) parentType;\n-      rawParentType = (Class<?>) parentTypeAsPT.getRawType();\n-    } else {\n-      return null;\n-    }\n \n-    Type superClass = rawParentType.getGenericSuperclass();\n-    if (superClass instanceof ParameterizedType\n-        && ((ParameterizedType) superClass).getRawType() == typeToEvaluate.getGenericDeclaration()) {\n       // Evaluate type on this type\n-      TypeVariable<?>[] classTypeVariables =\n-          ((Class<?>) ((ParameterizedType) superClass).getRawType()).getTypeParameters();\n-      int indexOfActualTypeArgument = getIndex(classTypeVariables, typeToEvaluate);\n-\n-      Type[] actualTypeArguments = null;\n-      if (parentType instanceof Class<?>) {\n-        actualTypeArguments = ((ParameterizedType) superClass).getActualTypeArguments();\n-      } else if (parentType instanceof ParameterizedType) {\n-        actualTypeArguments = ((ParameterizedType) parentType).getActualTypeArguments();\n-      } else {\n-        return null;\n-      }\n \n-      return actualTypeArguments[indexOfActualTypeArgument];\n-    }\n \n-    Type searchedType = null;\n-    if (superClass != null) {\n-      searchedType = extractTypeForHierarchy(superClass, typeToEvaluate);\n-    }\n-    return searchedType;\n-  }\n+\n \n   private static Type[] extractRealTypes(\n       Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {\n"}
{"identifier": "Csv-4", "buggy_code": "    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n", "fixed_code": "    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex e97a364..9d56f1a 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -285,7 +285,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n+        return new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n"}
{"identifier": "Chart-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex 5d831f7..dc7d06b 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,9 +2163,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2448,9 +2445,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\ndiff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 243f94b..50cf416 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,9 +2290,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2529,9 +2526,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n"}
{"identifier": "Jsoup-49", "buggy_code": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren(index);\n    }\n", "fixed_code": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n            reindexChildren(index);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected void addChildren(int index, Node... children)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java\nindex b6bdb93..01a4cd1 100644\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n@@ -442,8 +442,8 @@ public abstract class Node implements Cloneable {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n-            reindexChildren(index);\n         }\n+        reindexChildren(index);\n     }\n \n     protected void ensureChildNodes() {\n"}
{"identifier": "Cli-7", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli2/builder/PatternBuilder.java b/src/java/org/apache/commons/cli2/builder/PatternBuilder.java\nindex 2b4c1b5..6910017 100644\n--- a/src/java/org/apache/commons/cli2/builder/PatternBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/PatternBuilder.java\n@@ -16,8 +16,8 @@\n  */\n package org.apache.commons.cli2.builder;\n \n+import java.util.HashSet;\n import java.util.Iterator;\n-import java.util.LinkedHashSet;\n import java.util.Set;\n \n import org.apache.commons.cli2.Argument;\n@@ -64,7 +64,7 @@ public class PatternBuilder {\n         this.abuilder = abuilder;\n     }\n \n-    private final Set options = new LinkedHashSet();\n+    private final Set options = new HashSet();\n \n     /**\n      * Creates a new Option instance.\n"}
{"identifier": "Chart-3", "buggy_code": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n", "fixed_code": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.minY = Double.NaN;\n        copy.maxY = Double.NaN;\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 72bb2ea..795d791 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -1054,8 +1054,6 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             throw new IllegalArgumentException(\"Requires start <= end.\");\n         }\n         TimeSeries copy = (TimeSeries) super.clone();\n-        copy.minY = Double.NaN;\n-        copy.maxY = Double.NaN;\n         copy.data = new java.util.ArrayList();\n         if (this.data.size() > 0) {\n             for (int index = start; index <= end; index++) {\n"}
{"identifier": "Math-1", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\nindex 4ca33eb..ed4108d 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n@@ -303,9 +303,6 @@ public class BigFraction\n             if ((p2 > overflow) || (q2 > overflow)) {\n                 // in maxDenominator mode, if the last fraction was very close to the actual value\n                 // q2 may overflow in the next iteration; in this case return the last one.\n-                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n-                    break;\n-                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \ndiff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex 002dae9..8065885 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -212,9 +212,6 @@ public class Fraction\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 // in maxDenominator mode, if the last fraction was very close to the actual value\n                 // q2 may overflow in the next iteration; in this case return the last one.\n-                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n-                    break;\n-                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n"}
{"identifier": "Compress-31", "buggy_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte == 0) {\n                break;\n            }\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "fixed_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 94e175c2..40e7871f 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -132,6 +132,9 @@ public class TarUtils {\n \n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n+            if (currentByte == 0) {\n+                break;\n+            }\n             // CheckStyle:MagicNumber OFF\n             if (currentByte < '0' || currentByte > '7'){\n                 throw new IllegalArgumentException(\n"}
{"identifier": "JacksonCore-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\nindex 128fbcf4..a4148391 100644\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n@@ -50,7 +50,6 @@ public abstract class GeneratorBase extends JsonGenerator\n      * \n      * @since 2.7.7\n      */\n-    protected final static int MAX_BIG_DECIMAL_SCALE = 9999;\n     \n     /*\n     /**********************************************************\n@@ -432,16 +431,7 @@ public abstract class GeneratorBase extends JsonGenerator\n      * @since 2.7.7\n      */\n     protected String _asString(BigDecimal value) throws IOException {\n-        if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n             // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n-            int scale = value.scale();\n-            if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) {\n-                _reportError(String.format(\n-\"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\",\n-scale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE));\n-            }\n-            return value.toPlainString();\n-        }\n         return value.toString();\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\nindex 55246913..cf6ca3a6 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n@@ -907,7 +907,10 @@ public class UTF8JsonGenerator\n         if (value == null) {\n             _writeNull();\n         } else  if (_cfgNumbersAsStrings) {\n-            _writeQuotedRaw(_asString(value));\n+            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n+            _writeQuotedRaw(raw);\n+        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n+            writeRaw(value.toPlainString());\n         } else {\n             writeRaw(_asString(value));\n         }\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\nindex 2340ea20..156d997b 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n@@ -684,7 +684,10 @@ public final class WriterBasedJsonGenerator\n         if (value == null) {\n             _writeNull();\n         } else  if (_cfgNumbersAsStrings) {\n-            _writeQuotedRaw(_asString(value));\n+            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n+            _writeQuotedRaw(raw);\n+        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n+            writeRaw(value.toPlainString());\n         } else {\n             writeRaw(_asString(value));\n         }\n"}
{"identifier": "Jsoup-29", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Document.java b/src/main/java/org/jsoup/nodes/Document.java\nindex d1d0dfd..c5814af 100644\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n@@ -1,6 +1,5 @@\n package org.jsoup.nodes;\n \n-import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n@@ -67,7 +66,7 @@ public class Document extends Element {\n     public String title() {\n         // title is a preserve whitespace tag (for document output), but normalised here\n         Element titleEl = getElementsByTag(\"title\").first();\n-        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : \"\";\n+        return titleEl != null ? titleEl.text().trim() : \"\";\n     }\n \n     /**\n"}
{"identifier": "Lang-48", "buggy_code": "    /**\n     * <p>Test if two <code>Object</code>s are equal using their\n     * <code>equals</code> method.</p>\n     *\n     * @param lhs  the left hand object\n     * @param rhs  the right hand object\n     * @return EqualsBuilder - used to chain calls.\n     */\n    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n                // The simple case, not an array, just test the element\n                isEquals = lhs.equals(rhs);\n        } else if (lhs.getClass() != rhs.getClass()) {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // Not an array of primitives\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }\n", "fixed_code": "    /**\n     * <p>Test if two <code>Object</code>s are equal using their\n     * <code>equals</code> method.</p>\n     *\n     * @param lhs  the left hand object\n     * @param rhs  the right hand object\n     * @return EqualsBuilder - used to chain calls.\n     */\n    public EqualsBuilder append(Object lhs, Object rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        Class lhsClass = lhs.getClass();\n        if (!lhsClass.isArray()) {\n            if (lhs instanceof java.math.BigDecimal) {\n                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n            } else {\n                // The simple case, not an array, just test the element\n                isEquals = lhs.equals(rhs);\n            }\n        } else if (lhs.getClass() != rhs.getClass()) {\n            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n            this.setEquals(false);\n        }\n        // 'Switch' on type of array, to dispatch to the correct handler\n        // This handles multi dimensional arrays of the same depth\n        else if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // Not an array of primitives\n            append((Object[]) lhs, (Object[]) rhs);\n        }\n        return this;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Test if two <code>Object</code>s are equal using their\n     * <code>equals</code> method.</p>\n     *\n     * @param lhs  the left hand object\n     * @param rhs  the right hand object\n     * @return EqualsBuilder - used to chain calls.\n     */\n    public EqualsBuilder append(Object lhs, Object rhs)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\nindex 6901c8e..a783b35 100644\n--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n@@ -377,12 +377,8 @@ public class EqualsBuilder {\n         }\n         Class lhsClass = lhs.getClass();\n         if (!lhsClass.isArray()) {\n-            if (lhs instanceof java.math.BigDecimal) {\n-                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n-            } else {\n                 // The simple case, not an array, just test the element\n                 isEquals = lhs.equals(rhs);\n-            }\n         } else if (lhs.getClass() != rhs.getClass()) {\n             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n             this.setEquals(false);\n"}
{"identifier": "Jsoup-77", "buggy_code": "    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n", "fixed_code": "    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.normalName();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex 0851833..65d3045 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -114,7 +114,7 @@ public class XmlTreeBuilder extends TreeBuilder {\n      * @param endTag tag to close\n      */\n     private void popStackToClose(Token.EndTag endTag) {\n-        String elName = endTag.normalName();\n+        String elName = endTag.name();\n         Element firstFound = null;\n \n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n"}
{"identifier": "Math-65", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 5a60da8..30ebfff 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -237,7 +237,12 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul\n      * @return RMS value\n      */\n     public double getRMS() {\n-        return Math.sqrt(getChiSquare() / rows);\n+        double criterion = 0;\n+        for (int i = 0; i < rows; ++i) {\n+            final double residual = residuals[i];\n+            criterion += residual * residual * residualsWeights[i];\n+        }\n+        return Math.sqrt(criterion / rows);\n     }\n \n     /**\n@@ -250,7 +255,7 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual * residualsWeights[i];\n+            chiSquare += residual * residual / residualsWeights[i];\n         }\n         return chiSquare;\n     }\n"}
{"identifier": "Jsoup-62", "buggy_code": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName();\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "fixed_code": "        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nboolean anyOtherEndTag(Token t, HtmlTreeBuilder tb)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex e641a21..c515462 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -761,7 +761,7 @@ enum HtmlTreeBuilderState {\n         }\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n-            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n+            String name = t.asEndTag().normalName();\n             ArrayList<Element> stack = tb.getStack();\n             for (int pos = stack.size() -1; pos >= 0; pos--) {\n                 Element node = stack.get(pos);\n"}
{"identifier": "Math-30", "buggy_code": "    /**\n     * @param Umin smallest Mann-Whitney U value\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final int n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }\n", "fixed_code": "    /**\n     * @param Umin smallest Mann-Whitney U value\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final double n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * @param Umin smallest Mann-Whitney U value\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\nindex a161737..ce694ce 100644\n--- a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n@@ -170,7 +170,7 @@ public class MannWhitneyUTest {\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final double n1n2prod = n1 * n2;\n+        final int n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n"}
{"identifier": "Codec-15", "buggy_code": "    /**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */\n    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            final char hwChar = str.charAt(index - 1);\n            if ('H' == hwChar || 'W' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                    return 0;\n                }\n            }\n        }\n        return mappedChar;\n    }\n", "fixed_code": "    /**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */\n    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        final char mappedChar = this.map(str.charAt(index));\n        // HW rule check\n        if (index > 1 && mappedChar != '0') {\n            for (int i=index-1 ; i>=0 ; i--) {\n                final char prevChar = str.charAt(i);\n                if (this.map(prevChar)==mappedChar) {\n                    return 0;\n                }\n                if ('H'!=prevChar && 'W'!=prevChar) {\n                    break;\n                }\n            }\n        }\n        return mappedChar;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */\n    private char getMappingCode(final String str, final int index)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/language/Soundex.java b/src/main/java/org/apache/commons/codec/language/Soundex.java\nindex 404384db..71d1f07f 100644\n--- a/src/main/java/org/apache/commons/codec/language/Soundex.java\n+++ b/src/main/java/org/apache/commons/codec/language/Soundex.java\n@@ -185,14 +185,13 @@ public class Soundex implements StringEncoder {\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            for (int i=index-1 ; i>=0 ; i--) {\n-                final char prevChar = str.charAt(i);\n-                if (this.map(prevChar)==mappedChar) {\n+            final char hwChar = str.charAt(index - 1);\n+            if ('H' == hwChar || 'W' == hwChar) {\n+                final char preHWChar = str.charAt(index - 2);\n+                final char firstCode = this.map(preHWChar);\n+                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n-                if ('H'!=prevChar && 'W'!=prevChar) {\n-                    break;\n-                }\n             }\n         }\n         return mappedChar;\n"}
{"identifier": "Compress-7", "buggy_code": "    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char) buffer[i]);\n        }\n\n        return result.toString();\n    }\n", "fixed_code": "    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            byte b = buffer[i];\n            if (b == 0) { // Trailing null\n                break;\n            }\n            result.append((char) (b & 0xFF)); // Allow for sign-extension\n        }\n\n        return result.toString();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 8aba2e24..069b0391 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -95,11 +95,10 @@ public class TarUtils {\n         int          end = offset + length;\n \n         for (int i = offset; i < end; ++i) {\n-            byte b = buffer[i];\n-            if (b == 0) { // Trailing null\n+            if (buffer[i] == 0) {\n                 break;\n             }\n-            result.append((char) (b & 0xFF)); // Allow for sign-extension\n+            result.append((char) buffer[i]);\n         }\n \n         return result.toString();\n"}
{"identifier": "Math-45", "buggy_code": "    /**\n     * Build a sparse matrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows of the matrix.\n     * @param columnDimension Number of columns of the matrix.\n     */\n    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n        super(rowDimension, columnDimension);\n        this.rows = rowDimension;\n        this.columns = columnDimension;\n        this.entries = new OpenIntToDoubleHashMap(0.0);\n    }\n", "fixed_code": "    /**\n     * Build a sparse matrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows of the matrix.\n     * @param columnDimension Number of columns of the matrix.\n     */\n    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n        super(rowDimension, columnDimension);\n        long lRow = (long) rowDimension;\n        long lCol = (long) columnDimension;\n        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n        }\n        this.rows = rowDimension;\n        this.columns = columnDimension;\n        this.entries = new OpenIntToDoubleHashMap(0.0);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Build a sparse matrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows of the matrix.\n     * @param columnDimension Number of columns of the matrix.\n     */\n    public OpenMapRealMatrix(int rowDimension, int columnDimension)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\nindex f05c878..174eda6 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n@@ -47,11 +47,6 @@ public class OpenMapRealMatrix extends AbstractRealMatrix\n      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n-        long lRow = (long) rowDimension;\n-        long lCol = (long) columnDimension;\n-        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n-            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n-        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n"}
{"identifier": "JacksonDatabind-97", "buggy_code": "    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            gen.writeObject(_value);\n        }\n    }\n", "fixed_code": "    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            ctxt.defaultSerializeValue(_value, gen);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\nindex 06c315cfb..91fe5120a 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n@@ -111,7 +111,7 @@ public class POJONode\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            ctxt.defaultSerializeValue(_value, gen);\n+            gen.writeObject(_value);\n         }\n     }\n \n"}
{"identifier": "Codec-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/binary/Base32.java b/src/main/java/org/apache/commons/codec/binary/Base32.java\nindex e40d6525..185a662b 100644\n--- a/src/main/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java\n@@ -96,7 +96,7 @@ public class Base32 extends BaseNCodec {\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31,                                     // 50-57 P-V\n+            25, 26, 27, 28, 29, 30, 31, 32,\n     };\n \n     /**\n"}
{"identifier": "Cli-24", "buggy_code": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" +\n                                            \"- no room for the description\");\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "fixed_code": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = width - 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 028ff5c..9993a07 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -822,7 +822,8 @@ public class HelpFormatter\n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n+                                            \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n"}
{"identifier": "Math-87", "buggy_code": "    /**\n     * Checks whether the given column is basic.\n     * @param col index of the column to check\n     * @return the row that the variable is basic in.  null if the column is not basic\n     */\n    private Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                if (row == null) {\n                row = i;\n                } else {\n                return null;\n                }\n            }\n        }\n        return row;\n    }\n", "fixed_code": "    /**\n     * Checks whether the given column is basic.\n     * @param col index of the column to check\n     * @return the row that the variable is basic in.  null if the column is not basic\n     */\n    private Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                row = i;\n            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                return null;\n            }\n        }\n        return row;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Checks whether the given column is basic.\n     * @param col index of the column to check\n     * @return the row that the variable is basic in.  null if the column is not basic\n     */\n    private Integer getBasicRow(final int col)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex b0d114e..0ab790c 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -272,10 +272,12 @@ class SimplexTableau implements Serializable {\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n+            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+                if (row == null) {\n                 row = i;\n-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+                } else {\n                 return null;\n+                }\n             }\n         }\n         return row;\n"}
{"identifier": "Chart-7", "buggy_code": "    /**\n     * Update the index values for the maximum and minimum bounds.\n     * \n     * @param period  the time period.\n     * @param index  the index of the time period.\n     */\n    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }\n", "fixed_code": "    /**\n     * Update the index values for the maximum and minimum bounds.\n     * \n     * @param period  the time period.\n     * @param index  the index of the time period.\n     */\n    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Update the index values for the maximum and minimum bounds.\n     * \n     * @param period  the time period.\n     * @param index  the index of the time period.\n     */\n    private void updateBounds(TimePeriod period, int index)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "Index: source/org/jfree/data/time/TimePeriodValues.java\n===================================================================\n--- source/org/jfree/data/time/TimePeriodValues.java\t(revision 1087)\n+++ source/org/jfree/data/time/TimePeriodValues.java\t(revision 1086)\n@@ -297,9 +296,9 @@\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n+            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n-            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n"}
{"identifier": "Closure-148", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex f3d95836..1df9098b 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -179,9 +179,6 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n       case Token.ARRAYLIT:\n         typeNameString = \"object\";\n         break;\n-      case Token.VOID:\n-        typeNameString = \"undefined\";\n-        break;\n       case Token.NAME:\n         // We assume here that programs don't change the value of the\n         // keyword undefined to something other than the value undefined.\ndiff --git a/src/com/google/javascript/jscomp/SourceMap.java b/src/com/google/javascript/jscomp/SourceMap.java\nindex 698dfdec..ff61bddf 100644\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n@@ -38,7 +38,6 @@ import java.util.List;\n  */\n public class SourceMap {\n \n-  private final static int UNMAPPED = -1;\n \n   /**\n    * A mapping from a given position in an input source file to a given position\n@@ -48,7 +47,7 @@ public class SourceMap {\n     /**\n      * A unique ID for this mapping for record keeping purposes.\n      */\n-    int id = UNMAPPED;\n+    int id;\n \n     /**\n      * The input source file.\n@@ -83,67 +82,38 @@ public class SourceMap {\n     /**\n      * Whether the mapping is actually used by the source map.\n      */\n-    boolean used = false;\n-  }\n \n-  private class MappingWriter {\n     /**\n      * Cache of escaped source file name.\n      */\n-    private String lastSourceFile = null;\n-    private String lastSourceFileEscaped = null;\n-    private int lastLine = 0;\n-    private String lastLineString = String.valueOf(0);\n \n     /**\n      * Appends the mapping to the given buffer.\n      */\n-    private void appendMappingTo(\n-        Mapping m, Appendable out) throws IOException {\n+    void appendTo(Appendable out) throws IOException {\n       out.append(\"[\");\n \n-      String sourceFile = m.sourceFile;\n+      out.append(sourceFile);\n       // The source file rarely changes, so cache the escaped string.\n-      String escapedSourceFile;\n-      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)\n-        lastSourceFile = sourceFile;\n-        lastSourceFileEscaped = escapeString(sourceFile);\n-      }\n-      escapedSourceFile = lastSourceFileEscaped;\n \n-      out.append(escapedSourceFile);\n       out.append(\",\");\n \n-      int line = m.originalPosition.getLineNumber();\n-      if (line != lastLine) {\n-        lastLineString = String.valueOf(line);\n-      }\n-      String lineValue = lastLineString;\n \n-      out.append(lineValue);\n+      out.append(String.valueOf(originalPosition.getLineNumber()));\n \n       out.append(\",\");\n-      out.append(String.valueOf(\n-          m.originalPosition.getCharacterIndex()));\n+      out.append(String.valueOf(originalPosition.getCharacterIndex()));\n \n-      if (m.originalName != null) {\n+      if (originalName != null) {\n         out.append(\",\");\n-        out.append(escapeString(m.originalName));\n+        out.append(originalName);\n       }\n \n-      out.append(\"]\\n\");\n+      out.append(\"]\");\n     }\n-\n     /**\n      * Add used mappings to the supplied Appendable.\n      */\n-    void appendMappings(Appendable out) throws IOException {\n-      for (Mapping m : mappings) {\n-        if (m.used) {\n-          appendMappingTo(m, out);\n-        }\n-      }\n-    }\n   }\n \n   /**\n@@ -170,6 +140,8 @@ public class SourceMap {\n   private static String escapeString(String value) {\n     return CodeGenerator.escapeToDoubleQuotedJsString(value);\n   }\n+  private String lastSourceFile = null;\n+  private String lastSourceFileEscaped = null;\n \n   /**\n    * Adds a mapping for the given node.  Mappings must be added in order.\n@@ -188,21 +160,23 @@ public class SourceMap {\n       return;\n     }\n \n+    String escapedSourceFile;\n+    if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n+      lastSourceFile = sourceFile;\n+      lastSourceFileEscaped = escapeString(sourceFile);\n+    }\n+    escapedSourceFile = lastSourceFileEscaped;\n     // Create the new mapping.\n     Mapping mapping = new Mapping();\n-    mapping.sourceFile = sourceFile;\n+    mapping.id = mappings.size();\n+    mapping.sourceFile = escapedSourceFile;\n     mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n \n     String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n     if (originalName != null) {\n-      mapping.originalName = originalName;\n+      mapping.originalName = escapeString(originalName);\n     }\n \n-    if (offsetPosition.getLineNumber() == 0\n-        && offsetPosition.getCharacterIndex() == 0) {\n-      mapping.startPosition = startPosition;\n-      mapping.endPosition = endPosition;\n-    } else {\n       // If the mapping is found on the first line, we need to offset\n       // its character position by the number of characters found on\n       // the *last* line of the source file to which the code is\n@@ -226,7 +200,6 @@ public class SourceMap {\n       mapping.endPosition =\n           new Position(endPosition.getLineNumber() + offsetLine,\n                        endPosition.getCharacterIndex() + endOffsetPosition);\n-    }\n \n     mappings.add(mapping);\n   }\n@@ -281,6 +254,14 @@ public class SourceMap {\n     prefixPosition = new Position(0, 0);\n   }\n \n+  private int findLastLine() {\n+    int maxLine = 0;\n+    for (Mapping mapping : mappings) {\n+      int endPositionLine = mapping.endPosition.getLineNumber();\n+      maxLine = Math.max(maxLine, endPositionLine);\n+    }\n+    return maxLine + prefixPosition.getLineNumber();\n+  }\n   /**\n    * Appends the source map in LavaBug format to the given buffer.\n    *\n@@ -320,7 +301,7 @@ public class SourceMap {\n     // 11) [\"c.js\", 1, 4]\n     // 12) [\"d.js\", 3, 78, \"foo\"]\n \n-    int maxLine = prepMappings();\n+    int maxLine = findLastLine();\n \n     // Add the line character maps.\n     out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n@@ -342,42 +323,32 @@ public class SourceMap {\n     // Add the mappings themselves.\n     out.append(\"/** Begin mapping definitions. **/\\n\");\n \n-    (new MappingWriter()).appendMappings(out);\n+    for (Mapping mapping : mappings) {\n+      mapping.appendTo(out);\n+      out.append(\"\\n\");\n+    }\n   }\n \n   /**\n    * Assigns sequential ids to used mappings, and returns the last line mapped.\n    */\n-  private int prepMappings() throws IOException {\n     // Mark any unused mappings.\n-    (new MappingTraversal()).traverse(new UsedMappingCheck());\n \n     // Renumber used mappings and keep track of the last line.\n-    int id = 0;\n-    int maxLine = 0;\n-    for (Mapping m : mappings) {\n-      if (m.used) {\n-        m.id = id++;\n-        int endPositionLine = m.endPosition.getLineNumber();\n-        maxLine = Math.max(maxLine, endPositionLine);\n-      }\n-    }\n \n     // Adjust for the prefix.\n-    return maxLine + prefixPosition.getLineNumber();\n-  }\n \n-  private class LineMapper implements MappingVisitor {\n+  private class LineMapper {\n     // The destination.\n     private final Appendable out;\n-\n+    private int line;\n+    private int col;\n     // Whether the current line has had a value written yet.\n     private boolean firstChar = true;\n \n     private final static String UNMAPPED_STRING = \"-1\";\n \n-    private int lastId = UNMAPPED;\n-    private String lastIdString = UNMAPPED_STRING;\n+    private final static int UNMAPPED = -1;\n \n     LineMapper(Appendable out) {\n       this.out = out;\n@@ -386,30 +357,11 @@ public class SourceMap {\n     /**\n      * As each segment is visited write out the appropriate line mapping.\n      */\n-    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n-      throws IOException {\n \n-      int id = (m != null) ? m.id : UNMAPPED;\n-      if (lastId != id) {\n         // Prevent the creation of unnecessary temporary stings for often\n         // repeated values.\n-        lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n-        lastId = id;\n-      }\n-      String idString = lastIdString;\n \n-      for (int i = line; i <= nextLine; i++) {\n-        if (i == nextLine) {\n-          for (int j = col; j < nextCol; j++) {\n-            addCharEntry(idString);\n-          }\n-          break;\n-        }\n \n-        closeLine();\n-        openLine();\n-      }\n-    }\n \n     // Append the line mapping entries.\n     void appendLineMappings() throws IOException {\n@@ -418,64 +370,29 @@ public class SourceMap {\n       // Start the first line.\n       openLine();\n \n-      (new MappingTraversal()).traverse(this);\n \n       // And close the final line.\n-      closeLine();\n-    }\n \n     /**\n      * Begin the entry for a new line.\n      */\n-    private void openLine() throws IOException {\n-      if (out != null) {\n-        out.append(\"[\");\n-        this.firstChar = true;\n-      }\n-    }\n \n     /**\n      * End the entry for a line.\n      */\n-    private void closeLine() throws IOException {\n-      if (out != null) {\n-        out.append(\"]\\n\");\n-      }\n-    }\n \n     /**\n      * Add a new char position entry.\n      * @param id The mapping id to record.\n      */\n-    private void addCharEntry(String id) throws IOException {\n-      if (out != null) {\n-        if (firstChar) {\n-          firstChar = false;\n-        } else {\n-          out.append(\",\");\n-        }\n-        out.append(id);\n-      }\n-    }\n-  }\n \n   /**\n    * Mark any visited mapping as \"used\".\n    */\n-  private class UsedMappingCheck implements MappingVisitor {\n     /**\n      * @throws IOException\n      */\n-    @Override\n-    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n-        throws IOException {\n-      if (m != null) {\n-        m.used = true;\n-      }\n-    }\n-  }\n \n-  private interface MappingVisitor {\n     /**\n      * @param m The mapping for the current code segment. null if the segment\n      *     is unmapped.\n@@ -485,25 +402,15 @@ public class SourceMap {\n      * @param endCol The ending column\n      * @throws IOException\n      */\n-    void visit(Mapping m, int line, int col, int endLine, int endCol)\n-        throws IOException;\n-  }\n \n   /**\n    * Walk the mappings and visit each segment of the mappings, unmapped\n    * segments are visited with a null mapping, unused mapping are not visited.\n    */\n-  private class MappingTraversal {\n     // The last line and column written\n-    private int line;\n-    private int col;\n \n-    MappingTraversal() {\n-    }\n \n     // Append the line mapping entries.\n-    void traverse(MappingVisitor v) throws IOException {\n-      Preconditions.checkState(!mappings.isEmpty());\n \n       // The mapping list is ordered as a pre-order traversal.  The mapping\n       // positions give us enough information to rebuild the stack and this\n@@ -516,13 +423,13 @@ public class SourceMap {\n         // closed in the reverse order of when they encountered.\n         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n           Mapping previous = stack.pop();\n-          maybeVisit(v, previous);\n+          writeClosedMapping(previous);\n         }\n \n         // Any gaps between the current line position and the start of the\n         // current mapping belong to the parent.\n         Mapping parent = stack.peek();\n-        maybeVisitParent(v, parent, m);\n+        writeCharsBetween(parent, m);\n \n         stack.push(m);\n       }\n@@ -531,8 +438,24 @@ public class SourceMap {\n       // mappings in the reverse order of when they encountered.\n       while (!stack.isEmpty()) {\n         Mapping m = stack.pop();\n-        maybeVisit(v, m);\n+        writeClosedMapping(m);\n+      }\n+      closeLine();\n+    }\n+    private void openLine() throws IOException {\n+      out.append(\"[\");\n+      this.firstChar = true;\n+    }\n+    private void closeLine() throws IOException {\n+      out.append(\"]\\n\");\n+    }\n+    private void addCharEntry(String id) throws IOException {\n+      if (firstChar) {\n+        firstChar = false;\n+      } else {\n+        out.append(\",\");\n       }\n+      out.append(id);\n     }\n \n     /**\n@@ -570,47 +493,54 @@ public class SourceMap {\n      * Write any needed entries from the current position to the end of the\n      * provided mapping.\n      */\n-    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n+    private void writeClosedMapping(Mapping m) throws IOException {\n       int nextLine = getAdjustedLine(m.endPosition);\n       int nextCol = getAdjustedCol(m.endPosition);\n       // If this anything remaining in this mapping beyond the\n       // current line and column position, write it out now.\n       if (line < nextLine || (line == nextLine && col < nextCol)) {\n-        visit(v, m, nextLine, nextCol);\n+        writeCharsUpTo(nextLine, nextCol, m.id);\n       }\n     }\n \n     /**\n      * Write any needed entries to complete the provided mapping.\n      */\n-    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n+    private void writeCharsBetween(Mapping prev, Mapping next)\n         throws IOException {\n-      int nextLine = getAdjustedLine(m.startPosition);\n-      int nextCol = getAdjustedCol(m.startPosition);\n+      int nextLine = getAdjustedLine(next.startPosition);\n+      int nextCol = getAdjustedCol(next.startPosition);\n       // If the previous value is null, no mapping exists.\n-      Preconditions.checkState(line < nextLine || col <= nextCol);\n-      if (line < nextLine || (line == nextLine && col < nextCol)) {\n-        visit(v, parent, nextLine, nextCol);\n-      }\n+      int id = (prev != null) ? prev.id : UNMAPPED;\n+      writeCharsUpTo(nextLine, nextCol, id);\n     }\n \n     /**\n      * Write any entries needed between the current position the next position\n      * and update the current position.\n      */\n-    private void visit(MappingVisitor v, Mapping m,\n-        int nextLine, int nextCol)\n+    private void writeCharsUpTo(\n+        int nextLine, int nextCol, int id)\n         throws IOException {\n-      Preconditions.checkState(line <= nextLine);\n-      Preconditions.checkState(line < nextLine || col < nextCol);\n+      Preconditions.checkState(line <= nextLine, \"\");\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n \n       if (line == nextLine && col == nextCol) {\n         // Nothing to do.\n-        Preconditions.checkState(false);\n         return;\n       }\n \n-      v.visit(m, line, col, nextLine, nextCol);\n+      String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          for (int j = col; j < nextCol; j++) {\n+            addCharEntry(idString);\n+          }\n+          break;\n+        }\n+        closeLine();\n+        openLine();\n+      }\n \n       line = nextLine;\n       col = nextCol;\n"}
{"identifier": "Closure-54", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 5bccc06..8654ae6 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1410,13 +1410,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           // then they are responsible for making sure that the object literal's\n           // implicit prototype is set up appropriately. We just obey\n           // the @extends tag.\n-          ObjectType qVarType = ObjectType.cast(qVar.getType());\n-          if (qVarType != null &&\n-              rhsValue != null &&\n-              rhsValue.getType() == Token.OBJECTLIT) {\n-            typeRegistry.resetImplicitPrototype(\n-                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n-          } else if (!qVar.isTypeInferred()) {\n+          if (!qVar.isTypeInferred()) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to some arbitrary expression,\n             // there's not much we can do. We just ignore the expression,\ndiff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex a87be07..b65d8b1 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -338,6 +338,7 @@ public class FunctionType extends PrototypeObjectType {\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() ||\n+        baseType.isUnknownType() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {\n@@ -362,18 +363,14 @@ public class FunctionType extends PrototypeObjectType {\n       return false;\n     }\n \n-    PrototypeObjectType oldPrototype = this.prototype;\n-    boolean replacedPrototype = oldPrototype != null;\n+    boolean replacedPrototype = prototype != null;\n \n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n \n-    if (oldPrototype != null) {\n       // Disassociating the old prototype makes this easier to debug--\n       // we don't have to worry about two prototypes running around.\n-      oldPrototype.setOwnerFunction(null);\n-    }\n \n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();\n"}
{"identifier": "JacksonDatabind-26", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\nindex acaa17809..2093b7bcb 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n@@ -36,11 +36,9 @@ import com.fasterxml.jackson.databind.util.NameTransformer;\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty,\n-        java.io.Serializable // since 2.6.2\n+    implements BeanProperty\n {\n     // as of 2.6.2\n-    private static final long serialVersionUID = 4603296144163950020L;\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n"}
{"identifier": "JacksonCore-17", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\nindex a638519a..4f4394c8 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n@@ -525,33 +525,17 @@ public class UTF8JsonGenerator\n         final char[] buf = _charBuffer;\n \n         // minor optimization: see if we can just get and copy\n-        if (len <= buf.length) {\n-            text.getChars(offset, offset+len, buf, 0);\n-            _writeRawSegment(buf, 0, len);\n-            return;\n-        }\n \n         // If not, need segmented approach. For speed, let's also use input buffer\n         // size that is guaranteed to fit in output buffer; each char can expand to\n         // at most 3 bytes, so at most 1/3 of buffer size.\n-        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16\n-        final int maxBytes = maxChunk * 3;\n \n         while (len > 0) {\n-            int len2 = Math.min(maxChunk, len);\n+            int len2 = Math.min(buf.length, len);\n             text.getChars(offset, offset+len2, buf, 0);\n-            if ((_outputTail + maxBytes) > _outputEnd) {\n-                _flushBuffer();\n-            }\n+            writeRaw(buf, 0, len2);\n             // If this is NOT the last segment and if the last character looks like\n             // split surrogate second half, drop it\n-            if (len > 0) {\n-                char ch = buf[len2-1];\n-                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n-                    --len2;\n-                }\n-            }\n-            _writeRawSegment(buf, 0, len2);\n             offset += len2;\n             len -= len2;\n         }\n@@ -685,30 +669,6 @@ public class UTF8JsonGenerator\n      *\n      * @since 2.8.2\n      */\n-    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException\n-    {\n-        main_loop:\n-        while (offset < end) {\n-            inner_loop:\n-            while (true) {\n-                int ch = (int) cbuf[offset];\n-                if (ch > 0x7F) {\n-                    break inner_loop;\n-                }\n-                _outputBuffer[_outputTail++] = (byte) ch;\n-                if (++offset >= end) {\n-                    break main_loop;\n-                }\n-            }\n-            char ch = cbuf[offset++];\n-            if (ch < 0x800) { // 2-byte?\n-                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n-                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n-            } else {\n-                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n-            }\n-        }\n-    }\n \n     /*\n     /**********************************************************\n@@ -1924,8 +1884,7 @@ public class UTF8JsonGenerator\n             if (ch <= SURR2_LAST) { // yes, outside of BMP\n                 // Do we have second part?\n                 if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n-                    _reportError(String.format(\n-\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n+                    _reportError(\"Split surrogate on writeRaw() input (last character)\");\n                 }\n                 _outputSurrogates(ch, cbuf[inputOffset]);\n                 return inputOffset+1;\n"}
{"identifier": "Mockito-8", "buggy_code": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n", "fixed_code": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (typeParameter != actualTypeArgument) {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected void registerTypeVariablesOn(Type classType)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nindex 8046052..152e942 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -76,7 +76,7 @@ public abstract class GenericMetadataSupport {\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else if (typeParameter != actualTypeArgument) {\n+            } else {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n"}
{"identifier": "Math-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex fd1ce2d..3778120 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -79,7 +79,6 @@ import java.io.PrintStream;\n  */\n public class FastMath {\n     /** StrictMath.log(Double.MAX_VALUE): {@value} */\n-    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n \n     /** Archimede's constant PI, ratio of circle circumference to diameter. */\n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n@@ -392,21 +391,12 @@ public class FastMath {\n       // exp(-z) can be ignored in comparison with exp(z)\n \n       if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n               return 0.5 * exp(x);\n           }\n-      } else if (x < -20) {\n-          if (x <= -LOG_MAX_VALUE) {\n+      if (x < -20) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(-0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n               return 0.5 * exp(-x);\n-          }\n       }\n \n       final double hiPrec[] = new double[2];\n@@ -462,21 +452,12 @@ public class FastMath {\n       // exp(-z) can be ignored in comparison with exp(z)\n \n       if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n               return 0.5 * exp(x);\n           }\n-      } else if (x < -20) {\n-          if (x <= -LOG_MAX_VALUE) {\n+      if (x < -20) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(-0.5 * x);\n-              return (-0.5 * t) * t;\n-          } else {\n               return -0.5 * exp(-x);\n-          }\n       }\n \n       if (x == 0) {\n"}
{"identifier": "Cli-3", "buggy_code": "    /**\n     * <p>Create a number from a String. If a . is present, it creates a \n     *    Double, otherwise a Long. </p>\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>, if <code>str</code>\n     * is not a number, null is returned.\n     */\n    public static Number createNumber(String str)\n    {\n        try\n        {\n            return org.apache.commons.lang.math.NumberUtils.createNumber(str);\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }\n", "fixed_code": "    /**\n     * <p>Create a number from a String. If a . is present, it creates a \n     *    Double, otherwise a Long. </p>\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>, if <code>str</code>\n     * is not a number, null is returned.\n     */\n    public static Number createNumber(String str)\n    {\n        try\n        {\n            if( str != null )\n            {\n                if( str.indexOf('.') != -1 )\n                {\n                    return Double.valueOf(str);\n                }\n                else\n                {\n                    return Long.valueOf(str);\n                }\n            }\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Create a number from a String. If a . is present, it creates a \n     *    Double, otherwise a Long. </p>\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>, if <code>str</code>\n     * is not a number, null is returned.\n     */\n    public static Number createNumber(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/TypeHandler.java b/src/java/org/apache/commons/cli/TypeHandler.java\nindex 0a0aa72..addf90b 100644\n--- a/src/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n@@ -158,17 +158,7 @@ public class TypeHandler {\n     {\n         try\n         {\n-            if( str != null )\n-            {\n-                if( str.indexOf('.') != -1 )\n-                {\n-                    return Double.valueOf(str);\n-                }\n-                else\n-                {\n-                    return Long.valueOf(str);\n-                }\n-            }\n+            return org.apache.commons.lang.math.NumberUtils.createNumber(str);\n         }\n         catch (NumberFormatException nfe)\n         {\n"}
{"identifier": "JacksonDatabind-70", "buggy_code": "    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(prop.getName());\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n", "fixed_code": "    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(_hashArea[i-1]);\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\nindex 8031ee0aa..dc791897b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n@@ -437,7 +437,7 @@ System.err.println(\"And new propr #\"+slot+\" '\"+key+\"'\");\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(_hashArea[i-1]);\n+                found = key.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n"}
{"identifier": "JacksonDatabind-72", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\nindex 4a9ca99b9..021a3cf46 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n@@ -90,8 +90,6 @@ public final class InnerClassProperty\n     @Override\n     public int getPropertyIndex() { return _delegate.getPropertyIndex(); }\n \n-    @Override\n-    public int getCreatorIndex() { return _delegate.getCreatorIndex(); }\n     \n     // // // BeanProperty impl\n     \n@@ -166,4 +164,4 @@ public final class InnerClassProperty\n         }\n         return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null));\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Jsoup-31", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java\nindex 1679007..2d5643b 100644\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n@@ -168,7 +168,6 @@ abstract class Token {\n \n     static class Comment extends Token {\n         final StringBuilder data = new StringBuilder();\n-        boolean bogus = false;\n \n         Comment() {\n             type = TokenType.Comment;\ndiff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex cad7933..2a46cf2 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -1091,7 +1091,6 @@ enum TokeniserState {\n             // rewind to capture character that lead us here\n             r.unconsume();\n             Token.Comment comment = new Token.Comment();\n-            comment.bogus = true;\n             comment.data.append(r.consumeTo('>'));\n             // todo: replace nullChar with replaceChar\n             t.emit(comment);\ndiff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex dd2cb9f..11eae8b 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -64,13 +64,6 @@ public class XmlTreeBuilder extends TreeBuilder {\n     void insert(Token.Comment commentToken) {\n         Comment comment = new Comment(commentToken.getData(), baseUri);\n         Node insert = comment;\n-        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n-            String data = comment.getData();\n-            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n-                String declaration = data.substring(1);\n-                insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(\"!\"));\n-            }\n-        }\n         insertNode(insert);\n     }\n \n"}
{"identifier": "JacksonDatabind-112", "buggy_code": "    /*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            // [databind#2324]: check both array-delegating and delegating\n            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n            if (delegateCreator != null) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            // [databind#125]: May have a content converter\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n            // And we may also need to get deserializer for String\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }\n", "fixed_code": "    /*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n            // [databind#2324]: check both array-delegating and delegating\n            AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator();\n            if (delegateCreator != null) {\n                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {\n                JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                delegate = findDeserializer(ctxt, delegateType, property);\n            }\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            // [databind#125]: May have a content converter\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n            // And we may also need to get deserializer for String\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\nindex 0bf2e12a1..f50ca3629 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n@@ -104,11 +104,8 @@ public final class StringCollectionDeserializer\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator();\n+            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n             if (delegateCreator != null) {\n-                JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n-                delegate = findDeserializer(ctxt, delegateType, property);\n-            } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n"}
{"identifier": "JacksonDatabind-12", "buggy_code": "    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n", "fixed_code": "    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueDeserializer == null)\n                && (_keyDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\nindex a01167fe7..4785e3ff4 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n@@ -300,9 +300,7 @@ public class MapDeserializer\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueDeserializer == null)\n-                && (_keyDeserializer == null)\n-                && (_valueTypeDeserializer == null)\n+        return (_valueTypeDeserializer == null)\n                 && (_ignorableProperties == null);\n     }\n \n"}
{"identifier": "Mockito-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/exceptions/Reporter.java b/src/org/mockito/exceptions/Reporter.java\nindex d57e33d..9581a54 100644\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n@@ -421,7 +421,7 @@ public class Reporter {\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n-                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n+                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));\n@@ -431,7 +431,7 @@ public class Reporter {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n-                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n+                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                 undesired.getLocation()\n         ));\n     }\n@@ -674,9 +674,6 @@ public class Reporter {\n     }\n \n     private String exceptionCauseMessageIfAvailable(Exception details) {\n-        if (details.getCause() == null) {\n-            return details.getMessage();\n-        }\n         return details.getCause().getMessage();\n     }\n \n"}
{"identifier": "Math-54", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/dfp/Dfp.java b/src/main/java/org/apache/commons/math/dfp/Dfp.java\nindex 54aabc4..73f1ea3 100644\n--- a/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n@@ -270,9 +270,6 @@ public class Dfp implements FieldElement<Dfp> {\n             // Zero or sub-normal\n             if (x == 0) {\n                 // make sure 0 has the right sign\n-                if ((bits & 0x8000000000000000L) != 0) {\n-                    sign = -1;\n-                }\n                 return;\n             }\n \n@@ -2319,10 +2316,7 @@ public class Dfp implements FieldElement<Dfp> {\n \n         Dfp y = this;\n         boolean negate = false;\n-        int cmp0 = compare(this, getZero());\n-        if (cmp0 == 0) {\n-            return sign < 0 ? -0.0 : +0.0;\n-        } else if (cmp0 < 0) {\n+        if (lessThan(getZero())) {\n             y = negate();\n             negate = true;\n         }\n"}
{"identifier": "Lang-41", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/ClassUtils.java b/src/java/org/apache/commons/lang/ClassUtils.java\nindex 478b377..d5de42b 100644\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n@@ -188,23 +188,10 @@ public class ClassUtils {\n             return StringUtils.EMPTY;\n         }\n \n-        StringBuffer arrayPrefix = new StringBuffer();\n \n         // Handle array encoding\n-        if (className.startsWith(\"[\")) {\n-            while (className.charAt(0) == '[') {\n-                className = className.substring(1);\n-                arrayPrefix.append(\"[]\");\n-            }\n             // Strip Object type encoding\n-            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n-                className = className.substring(1, className.length() - 1);\n-            }\n-        }\n \n-        if (reverseAbbreviationMap.containsKey(className)) {\n-            className = reverseAbbreviationMap.get(className);\n-        }\n \n         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         int innerIdx = className.indexOf(\n@@ -213,7 +200,7 @@ public class ClassUtils {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n-        return out + arrayPrefix;\n+        return out;\n     }\n \n     // Package name\n@@ -255,18 +242,12 @@ public class ClassUtils {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(String className) {\n-        if (className == null || className.length() == 0) {\n+        if (className == null) {\n             return StringUtils.EMPTY;\n         }\n \n         // Strip array encoding\n-        while (className.charAt(0) == '[') {\n-            className = className.substring(1);\n-        }\n         // Strip Object type encoding\n-        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n-            className = className.substring(1);\n-        }\n \n         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {\n"}
{"identifier": "Lang-29", "buggy_code": "    /**\n     * <p>\n     * Converts the given Java version string to an <code>int</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>120</code> for Java 1.2</li>\n     * <li><code>131</code> for Java 1.3.1</li>\n     * <li><code>160</code> for Java 1.6.0_20</li>\n     * </ul>\n     * \n     * <p>\n     * Patch releases are not reported.\n     * </p>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example 131 for Java 1.3.1\n     */\n    static float toJavaVersionInt(String version) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Converts the given Java version string to an <code>int</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>120</code> for Java 1.2</li>\n     * <li><code>131</code> for Java 1.3.1</li>\n     * <li><code>160</code> for Java 1.6.0_20</li>\n     * </ul>\n     * \n     * <p>\n     * Patch releases are not reported.\n     * </p>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example 131 for Java 1.3.1\n     */\n    static int toJavaVersionInt(String version) {\n        return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Converts the given Java version string to an <code>int</code>.\n     * </p>\n     * \n     * <p>\n     * Example return values:\n     * </p>\n     * <ul>\n     * <li><code>120</code> for Java 1.2</li>\n     * <li><code>131</code> for Java 1.3.1</li>\n     * <li><code>160</code> for Java 1.6.0_20</li>\n     * </ul>\n     * \n     * <p>\n     * Patch releases are not reported.\n     * </p>\n     * <p>\n     * This method is package private instead of private to support unit test invocation.\n     * </p>\n     * \n     * @return the version, for example 131 for Java 1.3.1\n     */\n    static float toJavaVersionInt(String version)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/SystemUtils.java b/src/main/java/org/apache/commons/lang3/SystemUtils.java\nindex 2116f7c..0c73f42 100644\n--- a/src/main/java/org/apache/commons/lang3/SystemUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SystemUtils.java\n@@ -1669,7 +1669,7 @@ public class SystemUtils {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n-    static int toJavaVersionInt(String version) {\n+    static float toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }\n \n"}
{"identifier": "JacksonDatabind-111", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\nindex f9badf80a..f93a9dbfa 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n@@ -132,8 +132,7 @@ public class CreatorProperty\n             return this;\n         }\n         // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n-        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n-        return new CreatorProperty(this, deser, nvp);\n+        return new CreatorProperty(this, deser, _nullProvider);\n     }\n \n     @Override\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\nindex 973c85b54..b51b1ea45 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n@@ -90,8 +90,7 @@ public final class FieldProperty\n             return this;\n         }\n         // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n-        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n-        return new FieldProperty(this, deser, nvp);\n+        return new FieldProperty(this, deser, _nullProvider);\n     }\n \n     @Override\n@@ -215,4 +214,4 @@ public final class FieldProperty\n     Object readResolve() {\n         return new FieldProperty(this);\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\nindex 08111d4b4..2bad734aa 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\n@@ -81,8 +81,7 @@ public final class MethodProperty\n             return this;\n         }\n         // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n-        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n-        return new MethodProperty(this, deser, nvp);\n+        return new MethodProperty(this, deser, _nullProvider);\n     }\n \n     @Override\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\nindex 449cc7990..b96ce7ad5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n@@ -51,8 +51,7 @@ public class ObjectIdReferenceProperty extends SettableBeanProperty\n             return this;\n         }\n         // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n-        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n-        return new ObjectIdReferenceProperty(this, deser, nvp);\n+        return new ObjectIdReferenceProperty(this, deser, _nullProvider);\n     }\n \n     @Override\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\nindex 7fe91fcf1..206f4ae75 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n@@ -52,8 +52,7 @@ public final class ObjectIdValueProperty\n             return this;\n         }\n         // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n-        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n-        return new ObjectIdValueProperty(this, deser, nvp);\n+        return new ObjectIdValueProperty(this, deser, _nullProvider);\n     }\n \n     @Override\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\nindex a901f079f..f5596615e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n@@ -65,8 +65,7 @@ public final class SetterlessProperty\n             return this;\n         }\n         // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n-        NullValueProvider nvp = (_valueDeserializer == _nullProvider) ? deser : _nullProvider;\n-        return new SetterlessProperty(this, deser, nvp);\n+        return new SetterlessProperty(this, deser, _nullProvider);\n     }\n \n     @Override\n@@ -154,4 +153,4 @@ public final class SetterlessProperty\n         set(instance, value);\n         return instance;\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\nindex 486106c65..9d5c3ded5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n@@ -40,7 +40,7 @@ public class AtomicReferenceDeserializer\n \n     @Override\n     public AtomicReference<Object> getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n-        return new AtomicReference<Object>(_valueDeserializer.getNullValue(ctxt));\n+        return new AtomicReference<Object>();\n     }\n \n     @Override\n"}
{"identifier": "Math-55", "buggy_code": "  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n  }\n", "fixed_code": "  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n      final double n1 = v1.getNormSq();\n      final double n2 = v2.getNormSq();\n      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n          return ZERO;\n      }\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n      final double rho   = FastMath.rint(256 * ratio) / 256;\n\n      final double x3 = x1 - rho * x2;\n      final double y3 = y1 - rho * y2;\n      final double z3 = z1 - rho * z2;\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/geometry/Vector3D.java b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\nindex 2d915e5..3c741e9 100644\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n@@ -456,21 +456,9 @@ public class Vector3D implements Serializable {\n    */\n   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n \n-      final double n1 = v1.getNormSq();\n-      final double n2 = v2.getNormSq();\n-      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n-          return ZERO;\n-      }\n \n       // rescale both vectors without losing precision,\n       // to ensure their norm are the same order of magnitude\n-      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n-      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n-      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n-      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n-      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n-      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n-      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n \n       // we reduce cancellation errors by preconditioning,\n       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n@@ -479,15 +467,10 @@ public class Vector3D implements Serializable {\n       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n-      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n-      final double rho   = FastMath.rint(256 * ratio) / 256;\n \n-      final double x3 = x1 - rho * x2;\n-      final double y3 = y1 - rho * y2;\n-      final double z3 = z1 - rho * z2;\n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n+      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n \n   }\n \n"}
{"identifier": "Chart-6", "buggy_code": "    /**\n     * Tests the list for equality with another object (typically also a list).\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ShapeList)) {\n            return false;\n        }\n        return super.equals(obj);\n\n    }\n", "fixed_code": "    /**\n     * Tests the list for equality with another object (typically also a list).\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ShapeList)) {\n            return false;\n        }\n        ShapeList that = (ShapeList) obj;\n        int listSize = size();\n        for (int i = 0; i < listSize; i++) {\n           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n               return false;\n           }\n        }\n        return true;\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Tests the list for equality with another object (typically also a list).\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/util/ShapeList.java b/source/org/jfree/chart/util/ShapeList.java\nindex 73ece1c..85f1c81 100644\n--- a/source/org/jfree/chart/util/ShapeList.java\n+++ b/source/org/jfree/chart/util/ShapeList.java\n@@ -108,14 +108,7 @@ public class ShapeList extends AbstractObjectList {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        ShapeList that = (ShapeList) obj;\n-        int listSize = size();\n-        for (int i = 0; i < listSize; i++) {\n-           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n-               return false;\n-           }\n-        }\n-        return true;\n+        return super.equals(obj);\n \n     }\n \n"}
{"identifier": "Closure-21", "buggy_code": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n", "fixed_code": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult() || n.isBlock()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public void visit(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..0d1e95a 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,7 +98,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (n.isExprResult()) {\n       return;\n     }\n \n@@ -110,7 +110,24 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n+    if (parent.getType() == Token.COMMA) {\n+      if (isResultUsed) {\n+        return;\n+      }\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA) continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n+          else break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n+        return;\n+      }\n+    }\n+    if (\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n"}
{"identifier": "Closure-62", "buggy_code": "  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n", "fixed_code": "  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate String format(JSError error, boolean warning)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 420dbc0..5a4f884 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno <= sourceExcerpt.length()) {\n+          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n"}
{"identifier": "Math-64", "buggy_code": "    /** {@inheritDoc} */\n    @Override\n    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost();\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n            incrementIterationsCounter();\n\n            // compute the Q.R. decomposition of the jacobian matrix\n            VectorialPointValuePair previous = current;\n            updateJacobian();\n            qrDecomposition();\n\n            // compute Qt.res\n            qTy(residuals);\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * residuals[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // convergence has been reached\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            // inner loop\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                // evaluate the function at x + p and calculate its norm\n                updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n\n                    // tests for convergence.\n                    // we use the vectorial convergence checker\n                } else {\n                    // failed iteration, reset the previous values\n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                }\n                if (checker==null) {\n                \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                        (preRed <= costRelativeTolerance) &&\n                        (ratio <= 2.0)) ||\n                       (delta <= parRelativeTolerance * xNorm)) {\n                       return current;\n                   }\n                } else {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                }\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                            orthoTolerance);\n                }\n\n            }\n\n        }\n\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    @Override\n    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] oldObj  = new double[rows];\n        double[] qtf     = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost();\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n            for (int i=0;i<rows;i++) {\n                qtf[i]=residuals[i];\n            }\n            incrementIterationsCounter();\n\n            // compute the Q.R. decomposition of the jacobian matrix\n            VectorialPointValuePair previous = current;\n            updateJacobian();\n            qrDecomposition();\n\n            // compute Qt.res\n            qTy(qtf);\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // convergence has been reached\n            \tupdateResidualsAndCost();\n            \tcurrent = new VectorialPointValuePair(point, objective);\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            // inner loop\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = objective;\n                objective = oldObj;\n                oldObj    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                // evaluate the function at x + p and calculate its norm\n                updateResidualsAndCost();\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n                    current = new VectorialPointValuePair(point, objective);\n\n                    // tests for convergence.\n                    if (checker != null) {\n                    // we use the vectorial convergence checker\n                    \tif (checker.converged(getIterations(), previous, current)) {\n                    \t\treturn current;\n                    \t}\n                    }\n                } else {\n                    // failed iteration, reset the previous values\n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = objective;\n                    objective = oldObj;\n                    oldObj    = tmpVec;\n                }\n                if (checker==null) {\n                \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                        (preRed <= costRelativeTolerance) &&\n                        (ratio <= 2.0)) ||\n                       (delta <= parRelativeTolerance * xNorm)) {\n                       return current;\n                   }\n                }\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                            orthoTolerance);\n                }\n\n            }\n\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\nindex b41456e..5091493 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -255,8 +255,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n-        double[] oldObj  = new double[rows];\n-        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];\n@@ -269,9 +267,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n-            for (int i=0;i<rows;i++) {\n-                qtf[i]=residuals[i];\n-            }\n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n@@ -280,7 +275,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n             qrDecomposition();\n \n             // compute Qt.res\n-            qTy(qtf);\n+            qTy(residuals);\n             // now we don't need Q anymore,\n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n@@ -318,7 +313,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += jacobian[i][pj] * qtf[i];\n+                            sum += jacobian[i][pj] * residuals[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }\n@@ -326,8 +321,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-            \tupdateResidualsAndCost();\n-            \tcurrent = new VectorialPointValuePair(point, objective);\n                 return current;\n             }\n \n@@ -348,12 +341,9 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n-                tmpVec    = objective;\n-                objective = oldObj;\n-                oldObj    = tmpVec;\n \n                 // determine the Levenberg-Marquardt parameter\n-                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n+                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n \n                 // compute the new point and the norm of the evolution direction\n                 double lmNorm = 0;\n@@ -372,6 +362,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n+                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -427,15 +418,9 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n-                    current = new VectorialPointValuePair(point, objective);\n \n                     // tests for convergence.\n-                    if (checker != null) {\n                     // we use the vectorial convergence checker\n-                    \tif (checker.converged(getIterations(), previous, current)) {\n-                    \t\treturn current;\n-                    \t}\n-                    }\n                 } else {\n                     // failed iteration, reset the previous values\n                     cost = previousCost;\n@@ -446,9 +431,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n-                    tmpVec    = objective;\n-                    objective = oldObj;\n-                    oldObj    = tmpVec;\n                 }\n                 if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n@@ -457,6 +439,10 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n+                } else {\n+                    if (checker.converged(getIterations(), previous, current)) {\n+                        return current;\n+                    }\n                 }\n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n"}
{"identifier": "Closure-124", "buggy_code": "  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n      node = node.getFirstChild();\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }\n", "fixed_code": "  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n    while (node.isGetProp()) {\n      node = node.getFirstChild();\n    }\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ExploitAssigns.java b/src/com/google/javascript/jscomp/ExploitAssigns.java\nindex 1639f2c..0f03e35 100644\n--- a/src/com/google/javascript/jscomp/ExploitAssigns.java\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n@@ -210,9 +210,7 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-    while (node.isGetProp()) {\n       node = node.getFirstChild();\n-    }\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n"}
{"identifier": "Closure-8", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\nindex e0466ea..f2d36f5 100644\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n@@ -201,14 +201,10 @@ class CollapseVariableDeclarations implements CompilerPass {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n-          && !isNamedParameter(var)\n           && !blacklistedVars.contains(var);\n     }\n   }\n \n-  private boolean isNamedParameter(Var v) {\n-    return v.getParentNode().isParamList();\n-  }\n \n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {\n"}
{"identifier": "Mockito-36", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/invocation/Invocation.java b/src/org/mockito/internal/invocation/Invocation.java\nindex 5e9b795..94d4612 100644\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n@@ -8,7 +8,6 @@ import java.util.*;\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.matchers.*;\n@@ -200,9 +199,6 @@ public class Invocation implements PrintableInvocation, InvocationOnMock, Printi\n     }\n \n     public Object callRealMethod() throws Throwable {\n-        if (this.getMethod().getDeclaringClass().isInterface()) {\n-            new Reporter().cannotCallRealMethodOnInterface();\n-        }\n         return realMethod.invoke(mock, rawArguments);\n     }\n \n"}
{"identifier": "Jsoup-69", "buggy_code": "", "fixed_code": "    @Override\n    protected void removeChild(Node out) {\n        super.removeChild(out);\n        elements.remove(out);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/FormElement.java b/src/main/java/org/jsoup/nodes/FormElement.java\nindex f5c59d3..e498975 100644\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n@@ -46,11 +46,6 @@ public class FormElement extends Element {\n         return this;\n     }\n \n-    @Override\n-    protected void removeChild(Node out) {\n-        super.removeChild(out);\n-        elements.remove(out);\n-    }\n \n     /**\n      * Prepare to submit this form. A Connection object is created with the request set up from the form values. You\n"}
{"identifier": "Jsoup-39", "buggy_code": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                        try {\n                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n                                foundCharset = meta.attr(\"charset\");\n                            }\n                        } catch (IllegalCharsetNameException e) {\n                            foundCharset = null;\n                        }\n                    }\n                } else {\n                    foundCharset = meta.attr(\"charset\");\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n", "fixed_code": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                        try {\n                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n                                foundCharset = meta.attr(\"charset\");\n                            }\n                        } catch (IllegalCharsetNameException e) {\n                            foundCharset = null;\n                        }\n                    }\n                } else {\n                    foundCharset = meta.attr(\"charset\");\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex 44f85be..d43bfe4 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -116,7 +116,6 @@ public class DataUtil {\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             docData = docData.substring(1);\n             charsetName = defaultCharset;\n-            doc = null;\n         }\n         if (doc == null) {\n             doc = parser.parseInput(docData, baseUri);\n"}
{"identifier": "Lang-61", "buggy_code": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = thisBuf.length - strLen;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n", "fixed_code": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = size - strLen + 1;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex c7cbfb3..0e88989 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1773,7 +1773,7 @@ public class StrBuilder implements Cloneable {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = size - strLen + 1;\n+        int len = thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n"}
{"identifier": "Compress-28", "buggy_code": "    /**\n     * Reads bytes from the current tar archive entry.\n     *\n     * This method is aware of the boundaries of the current\n     * entry in the archive and will deal with them as if they\n     * were this stream's start and EOF.\n     *\n     * @param buf The buffer into which to place bytes read.\n     * @param offset The offset at which to place bytes read.\n     * @param numToRead The number of bytes to read.\n     * @return The number of bytes read, or -1 at EOF.\n     * @throws IOException on error\n     */\n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        count(totalRead);\n        \n        if (totalRead == -1) {\n            hasHitEOF = true;\n        } else {\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n", "fixed_code": "    /**\n     * Reads bytes from the current tar archive entry.\n     *\n     * This method is aware of the boundaries of the current\n     * entry in the archive and will deal with them as if they\n     * were this stream's start and EOF.\n     *\n     * @param buf The buffer into which to place bytes read.\n     * @param offset The offset at which to place bytes read.\n     * @param numToRead The number of bytes to read.\n     * @return The number of bytes read, or -1 at EOF.\n     * @throws IOException on error\n     */\n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        \n        if (totalRead == -1) {\n            if (numToRead > 0) {\n                throw new IOException(\"Truncated TAR archive\");\n            }\n            hasHitEOF = true;\n        } else {\n            count(totalRead);\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Reads bytes from the current tar archive entry.\n     *\n     * This method is aware of the boundaries of the current\n     * entry in the archive and will deal with them as if they\n     * were this stream's start and EOF.\n     *\n     * @param buf The buffer into which to place bytes read.\n     * @param offset The offset at which to place bytes read.\n     * @param numToRead The number of bytes to read.\n     * @return The number of bytes read, or -1 at EOF.\n     * @throws IOException on error\n     */\n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex 6f0c6a42..fe2c1133 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -580,14 +580,11 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n         numToRead = Math.min(numToRead, available());\n         \n         totalRead = is.read(buf, offset, numToRead);\n+        count(totalRead);\n         \n         if (totalRead == -1) {\n-            if (numToRead > 0) {\n-                throw new IOException(\"Truncated TAR archive\");\n-            }\n             hasHitEOF = true;\n         } else {\n-            count(totalRead);\n             entryOffset += totalRead;\n         }\n \n"}
{"identifier": "Math-67", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\nindex 26fd5e0..d0dada3 100644\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n@@ -89,12 +89,12 @@ public class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimize\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimaValues[0];\n+        return optimizer.getFunctionValue();\n     }\n \n     /** {@inheritDoc} */\n     public double getResult() {\n-        return optima[0];\n+        return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n"}
{"identifier": "Math-68", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\nindex 28aee43..d1b36ea 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -163,7 +163,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         setMaxIterations(1000);\n \n         // default values for the tuning parameters\n-        setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);\n@@ -245,13 +244,11 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         // outer loop\n         lmPar = 0;\n         boolean firstIteration = true;\n-        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n \n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n-            VectorialPointValuePair previous = current;\n             updateJacobian();\n             qrDecomposition();\n \n@@ -303,7 +300,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-                return current;\n+                return new VectorialPointValuePair(point, objective);\n             }\n \n             // rescale if necessary\n@@ -345,7 +342,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n-                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -414,20 +410,14 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                 }\n \n                 // tests for convergence.\n-                if (checker != null) {\n                     // we use the vectorial convergence checker\n-                    if (checker.converged(getIterations(), previous, current)) {\n-                        return current;                        \n-                    }\n-                } else {\n                     // we use the Levenberg-Marquardt specific convergence parameters\n                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                          (preRed <= costRelativeTolerance) &&\n                          (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n-                        return current;\n+                        return new VectorialPointValuePair(point, objective);\n                     }\n-                }\n \n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n"}
{"identifier": "JacksonDatabind-96", "buggy_code": "    /**\n     * Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n", "fixed_code": "    /**\n     * Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex 042cf0afd..7057c5427 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -732,7 +732,7 @@ nonAnnotatedParamIndex, ctor);\n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.paramName(0);\n+            paramName = candidate.findImplicitParamName(0);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n"}
{"identifier": "Jsoup-26", "buggy_code": "    /**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n", "fixed_code": "    /**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/safety/Cleaner.java b/src/main/java/org/jsoup/safety/Cleaner.java\nindex 8110836..7d7f316 100644\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n@@ -40,7 +40,6 @@ public class Cleaner {\n         Validate.notNull(dirtyDocument);\n \n         Document clean = Document.createShell(dirtyDocument.baseUri());\n-        if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.\n             copySafeNodes(dirtyDocument.body(), clean.body());\n \n         return clean;\n"}
{"identifier": "Csv-12", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 0338732..66dcbf8 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -216,7 +216,7 @@ public final class CSVFormat implements Serializable {\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);\n+    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n"}
{"identifier": "Jsoup-15", "buggy_code": "        boolean process(Token t, TreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        Element form = tb.insert(startTag);\n                        tb.setFormElement(form);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask.\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        TreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        // todo: refactor these lookups\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            for (int si = 0; si < stack.size(); si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "fixed_code": "        boolean process(Token t, TreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        Element form = tb.insert(startTag);\n                        tb.setFormElement(form);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask.\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        TreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        // todo: refactor these lookups\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            for (int si = 0; si < stack.size(); si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nboolean process(Token t, TreeBuilder tb)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/TreeBuilderState.java b/src/main/java/org/jsoup/parser/TreeBuilderState.java\nindex 4ae01e1..e82eed5 100644\n--- a/src/main/java/org/jsoup/parser/TreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilderState.java\n@@ -280,7 +280,7 @@ enum TreeBuilderState {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n+                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n"}
{"identifier": "Closure-13", "buggy_code": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        traverse(c);\n        Node next = c.getNext();\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }\n", "fixed_code": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void traverse(Node node)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\nindex eeeb6a9..b51c088 100644\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n@@ -123,8 +123,8 @@ class PeepholeOptimizationsPass\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n-        Node next = c.getNext();\n         traverse(c);\n+        Node next = c.getNext();\n         c = next;\n       }\n \n"}
{"identifier": "JacksonDatabind-8", "buggy_code": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify\n                // otherwise only verify if neither explicitly annotated.\n            }\n\n            // one more thing: ok to override in sub-class\n            if (oldOne.getClass() == newOne.getClass()) {\n                // [databind#667]: avoid one particular class of bogus problems\n\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                // otherwise, which one to choose?\n                    // new type more generic, use old\n                // new type more specific, use it\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n", "fixed_code": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n            boolean verify;\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify\n                verify = true;\n            } else {\n                // otherwise only verify if neither explicitly annotated.\n                verify = !explicit;\n            }\n\n            // one more thing: ok to override in sub-class\n            if (verify && (oldOne.getClass() == newOne.getClass())) {\n                // [databind#667]: avoid one particular class of bogus problems\n                Class<?> oldType = oldOne.getRawParameterType(0);\n                Class<?> newType = newOne.getRawParameterType(0);\n\n                if (oldType == newType) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                // otherwise, which one to choose?\n                if (newType.isAssignableFrom(oldType)) {\n                    // new type more generic, use old\n                    return;\n                }\n                // new type more specific, use it\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\nindex 1a99abc5e..39514f63f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n@@ -280,7 +280,6 @@ public class CreatorCollector\n         AnnotatedWithParams oldOne = _creators[typeIndex];\n         // already had an explicitly marked one?\n         if (oldOne != null) {\n-            boolean verify;\n \n             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                 // but skip, if new one not annotated\n@@ -288,27 +287,17 @@ public class CreatorCollector\n                     return;\n                 }\n                 // both explicit: verify\n-                verify = true;\n-            } else {\n                 // otherwise only verify if neither explicitly annotated.\n-                verify = !explicit;\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (verify && (oldOne.getClass() == newOne.getClass())) {\n+            if (oldOne.getClass() == newOne.getClass()) {\n                 // [databind#667]: avoid one particular class of bogus problems\n-                Class<?> oldType = oldOne.getRawParameterType(0);\n-                Class<?> newType = newOne.getRawParameterType(0);\n \n-                if (oldType == newType) {\n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n-                }\n                 // otherwise, which one to choose?\n-                if (newType.isAssignableFrom(oldType)) {\n                     // new type more generic, use old\n-                    return;\n-                }\n                 // new type more specific, use it\n             }\n         }\n"}
{"identifier": "Compress-38", "buggy_code": "    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n", "fixed_code": "    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\nindex a5050bfa..941bbbd3 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n@@ -856,7 +856,7 @@ public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n             return true;\n         }\n \n-        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n+        if (getName().endsWith(\"/\")) {\n             return true;\n         }\n \n"}
{"identifier": "Lang-5", "buggy_code": "    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 2) {\n                return new Locale(str);\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            final char ch4 = str.charAt(4);\n            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            }\n            if (len < 7) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }\n", "fixed_code": "    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n        if (ch0 == '_') {\n            if (len < 3) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch1 = str.charAt(1);\n            final char ch2 = str.charAt(2);\n            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 3) {\n                return new Locale(\"\", str.substring(1, 3));\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(3) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(\"\", str.substring(1, 3), str.substring(4));\n        } else {\n            final char ch1 = str.charAt(1);\n            if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 2) {\n                return new Locale(str);\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            final char ch4 = str.charAt(4);\n            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            }\n            if (len < 7) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(final String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/LocaleUtils.java b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\nindex a7a6051..bc779d0 100644\n--- a/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n@@ -94,26 +94,6 @@ public class LocaleUtils {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch0 = str.charAt(0);\n-        if (ch0 == '_') {\n-            if (len < 3) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            final char ch1 = str.charAt(1);\n-            final char ch2 = str.charAt(2);\n-            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            if (len == 3) {\n-                return new Locale(\"\", str.substring(1, 3));\n-            }\n-            if (len < 5) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            if (str.charAt(3) != '_') {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            return new Locale(\"\", str.substring(1, 3), str.substring(4));\n-        } else {\n             final char ch1 = str.charAt(1);\n             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n@@ -145,7 +125,6 @@ public class LocaleUtils {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n"}
{"identifier": "JacksonDatabind-95", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\nindex 46910eb45..41ffafb2b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n@@ -352,7 +352,7 @@ public final class TypeFactory\n         // also: if we start from untyped, not much to save\n         do { // bogus loop to be able to break\n             if (rawBase == Object.class) {\n-                newType = _fromClass(null, subclass, EMPTY_BINDINGS);\n+                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                 break;\n             }\n             if (!rawBase.isAssignableFrom(subclass)) {\n@@ -363,7 +363,7 @@ public final class TypeFactory\n \n             // (1) Original target type has no generics -- just resolve subtype\n             if (baseType.getBindings().isEmpty()) {\n-                newType = _fromClass(null, subclass, EMPTY_BINDINGS);     \n+                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                 break;\n             }\n             // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n@@ -893,7 +893,7 @@ public final class TypeFactory\n         int len = parameterClasses.length;\n         JavaType[] pt = new JavaType[len];\n         for (int i = 0; i < len; ++i) {\n-            pt[i] = _fromClass(null, parameterClasses[i], EMPTY_BINDINGS);\n+            pt[i] = _fromClass(null, parameterClasses[i], null);\n         }\n         return constructParametricType(parametrized, pt);\n     }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\nindex 1817e0aad..c3697f5e5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\n@@ -56,7 +56,7 @@ public class TypeParser\n             // can be comma that separates types, or closing '>'\n             tokens.pushBack(token);\n         }\n-        return _factory._fromClass(null, base, TypeBindings.emptyBindings());\n+        return _factory._fromClass(null, base, null);\n     }\n \n     protected List<JavaType> parseTypes(MyTokenizer tokens)\n"}
{"identifier": "Closure-90", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\nindex 3394fa6..99c9fce 100644\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n@@ -181,7 +181,7 @@ final class FunctionTypeBuilder {\n       // create interfaces JSType, ObjectType, FunctionType etc and have\n       // separate implementation instead of the class hierarchy, so that\n       // union types can also be object types, etc.\n-      if (!type.restrictByNotNullOrUndefined().isSubtype(\n+      if (!type.isSubtype(\n               typeRegistry.getNativeType(OBJECT_TYPE))) {\n         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n         return false;\ndiff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex de1d1c2..3f0d245 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -877,9 +877,6 @@ public class FunctionType extends PrototypeObjectType {\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis != null) {\n-      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n-    }\n     if (maybeTypeOfThis instanceof ObjectType) {\n       typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n"}
{"identifier": "Chart-5", "buggy_code": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0 && !this.allowDuplicateXValues) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }\n", "fixed_code": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(x, y);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Adds or updates an item in the series and sends a\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/data/xy/XYSeries.java b/source/org/jfree/data/xy/XYSeries.java\nindex b26e11e..0b37e6e 100644\n--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -541,15 +541,11 @@ public class XYSeries extends Series implements Cloneable, Serializable {\n         if (x == null) {\n             throw new IllegalArgumentException(\"Null 'x' argument.\");\n         }\n-        if (this.allowDuplicateXValues) {\n-            add(x, y);\n-            return null;\n-        }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0) {\n+        if (index >= 0 && !this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n"}
{"identifier": "Gson-7", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex 7a5e9cbb..d375ba15 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -951,12 +951,8 @@ public class JsonReader implements Closeable {\n     if (p == PEEKED_NUMBER) {\n       peekedString = new String(buffer, pos, peekedNumberLength);\n       pos += peekedNumberLength;\n-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n-      if (p == PEEKED_UNQUOTED) {\n-        peekedString = nextUnquotedValue();\n-      } else {\n+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n-      }\n       try {\n         long result = Long.parseLong(peekedString);\n         peeked = PEEKED_NONE;\n@@ -1183,12 +1179,8 @@ public class JsonReader implements Closeable {\n     if (p == PEEKED_NUMBER) {\n       peekedString = new String(buffer, pos, peekedNumberLength);\n       pos += peekedNumberLength;\n-    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n-      if (p == PEEKED_UNQUOTED) {\n-        peekedString = nextUnquotedValue();\n-      } else {\n+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n-      }\n       try {\n         result = Integer.parseInt(peekedString);\n         peeked = PEEKED_NONE;\n"}
{"identifier": "Cli-40", "buggy_code": "    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n", "fixed_code": "    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            throw new ParseException(\"Unable to handle the class: \" + clazz);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/TypeHandler.java b/src/main/java/org/apache/commons/cli/TypeHandler.java\nindex 9ed8beb..6bd84b0 100644\n--- a/src/main/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n@@ -100,7 +100,7 @@ public class TypeHandler\n         }\n         else\n         {\n-            throw new ParseException(\"Unable to handle the class: \" + clazz);\n+            return null;\n         }\n     }\n \n"}
{"identifier": "Closure-79", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex 8bee886..6738b10 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -119,7 +119,7 @@ class Normalize implements CompilerPass {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(\n         compiler, new NormalizeStatements(compiler, assertOnChange))\n-        .traverseRoots(externs, root);\n+        .traverse(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\ndiff --git a/src/com/google/javascript/jscomp/VarCheck.java b/src/com/google/javascript/jscomp/VarCheck.java\nindex f8ebfa3..c8196b1 100644\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n@@ -218,7 +218,6 @@ class VarCheck extends AbstractPostOrderCallback implements CompilerPass {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n"}
{"identifier": "Closure-17", "buggy_code": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                // If rValue has a type-cast, we use the type in the type-cast.\n                // If rValue's type was already computed during scope creation,\n                // then we can safely use that.\n                return rValue.getJSType();\n              } else if (rValue.isOr()) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n", "fixed_code": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n              if (rValueInfo != null && rValueInfo.hasType()) {\n                // If rValue has a type-cast, we use the type in the type-cast.\n                return rValueInfo.getType().evaluate(scope, typeRegistry);\n              } else if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                // If rValue's type was already computed during scope creation,\n                // then we can safely use that.\n                return rValue.getJSType();\n              } else if (rValue.isOr()) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 8bc7bda..efaba2c 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1288,12 +1288,8 @@ final class TypedScopeCreator implements ScopeCreator {\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n-              if (rValueInfo != null && rValueInfo.hasType()) {\n+              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n-                return rValueInfo.getType().evaluate(scope, typeRegistry);\n-              } else if (rValue.getJSType() != null\n-                  && !rValue.getJSType().isUnknownType()) {\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n"}
{"identifier": "Math-9", "buggy_code": "    /** Get a line with reversed direction.\n     * @return a new instance, with reversed direction\n     */\n    public Line revert() {\n        final Line reverted = new Line(zero, zero.subtract(direction));\n        return reverted;\n    }\n", "fixed_code": "    /** Get a line with reversed direction.\n     * @return a new instance, with reversed direction\n     */\n    public Line revert() {\n        final Line reverted = new Line(this);\n        reverted.direction = reverted.direction.negate();\n        return reverted;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Get a line with reversed direction.\n     * @return a new instance, with reversed direction\n     */\n    public Line revert()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\nindex 7c9a28f..674c4aa 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n@@ -84,8 +84,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(this);\n-        reverted.direction = reverted.direction.negate();\n+        final Line reverted = new Line(zero, zero.subtract(direction));\n         return reverted;\n     }\n \n"}
{"identifier": "Math-85", "buggy_code": "     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n", "fixed_code": "     /**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding {a, b}.\n     * @throws ConvergenceException if the algorithm fails to find a and b\n     * satisfying the desired conditions\n     * @throws FunctionEvaluationException if an error occurs evaluating the \n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */\n    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb > 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * This method attempts to find two values a and b satisfying <ul>\n     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> maximumIterations</code> iterations elapse \n     * -- ConvergenceException </li></ul></p>\n     * \n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @param maximumIterations maximum number of iterations to perform\n     * @return a two element array holding\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex e6398f6..bf3e4bf 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb > 0.0 ) {\n+        if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n"}
{"identifier": "Codec-18", "buggy_code": "    /**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex e5fb7187..bef55f70 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -78,7 +78,7 @@ public class StringUtils {\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n \n     /**\n"}
{"identifier": "JacksonDatabind-50", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\nindex 8360b5118..21bd1288d 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n@@ -6,7 +6,6 @@ import java.util.*;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n-import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n@@ -385,7 +384,6 @@ public class BeanDeserializer\n         TokenBuffer unknown = null;\n \n         JsonToken t = p.getCurrentToken();\n-        List<BeanReferring> referrings = null;\n         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n@@ -428,18 +426,10 @@ public class BeanDeserializer\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                try {\n                     buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n-                } catch (UnresolvedForwardReference reference) {\n                     // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                     //    handling of forward references here. Not exactly sure why existing\n                     //    facilities did not cover, but this does appear to solve the problem\n-                    BeanReferring referring = handleUnresolvedReference(p, prop, buffer, reference);\n-                    if (referrings == null) {\n-                        referrings = new ArrayList<BeanReferring>();\n-                    }\n-                    referrings.add(referring);\n-                }\n                 continue;\n             }\n             // Things marked as ignorable should not be passed to any setter\n@@ -472,11 +462,6 @@ public class BeanDeserializer\n             wrapInstantiationProblem(e, ctxt);\n             bean = null; // never gets here\n         }\n-        if (referrings != null) {\n-            for (BeanReferring referring : referrings) {\n-               referring.setBean(bean);\n-            }\n-        }\n         if (unknown != null) {\n             // polymorphic?\n             if (bean.getClass() != _beanType.getRawClass()) {\n@@ -491,16 +476,6 @@ public class BeanDeserializer\n     /**\n      * @since 2.8\n      */\n-    private BeanReferring handleUnresolvedReference(JsonParser p,\n-            SettableBeanProperty prop, PropertyValueBuffer buffer,\n-            UnresolvedForwardReference reference)\n-        throws JsonMappingException\n-    {\n-        BeanReferring referring = new BeanReferring(reference, prop.getType().getRawClass(),\n-                buffer, prop);\n-        reference.getRoid().appendReferring(referring);\n-        return referring;\n-    }\n \n     protected final Object _deserializeWithErrorWrapping(JsonParser p,\n             DeserializationContext ctxt, SettableBeanProperty prop)\n@@ -955,24 +930,7 @@ public class BeanDeserializer\n     /**\n      * @since 2.8\n      */\n-    static class BeanReferring extends Referring {\n-        private final SettableBeanProperty _prop;\n-        private Object _bean;\n \n-        public void setBean(Object bean) {\n-            _bean = bean;\n-        }\n \n-        BeanReferring(UnresolvedForwardReference ref,\n-                Class<?> valueType, PropertyValueBuffer buffer, SettableBeanProperty prop)\n-        {\n-            super(ref, valueType);\n-            _prop = prop;\n-        }\n \n-        @Override\n-        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n-            _prop.set(_bean, value);\n-        }\n-    }\n }\n"}
{"identifier": "Closure-142", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CoalesceVariableNames.java b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\nindex e990c82e..78c27b30 100644\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n@@ -105,9 +105,6 @@ class CoalesceVariableNames extends AbstractPostOrderCallback implements\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n-    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n-      liveness.markAllParametersEscaped();\n-    }\n     liveness.analyze();\n \n     UndiGraph<Var, Void> interferenceGraph =\ndiff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex 216740b8..cdcd2ff4 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1165,8 +1165,6 @@ public final class JsDocInfoParser {\n         case EOF:\n           // When we're capturing a license block, annotations\n           // in the block are ok.\n-          if (!(option == WhitespaceOption.PRESERVE &&\n-                token == JsDocToken.ANNOTATION)) {\n             String multilineText = builder.toString();\n \n             if (option != WhitespaceOption.PRESERVE) {\n@@ -1182,7 +1180,6 @@ public final class JsDocInfoParser {\n             }\n \n             return new ExtractionInfo(multilineText, token);\n-          }\n \n           // FALL THROUGH\n \n"}
{"identifier": "Gson-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java\nindex 51dc1f3a..502d5ab9 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java\n@@ -159,13 +159,6 @@ public final class JsonTreeWriter extends JsonWriter {\n     return this;\n   }\n \n-  @Override public JsonWriter value(Boolean value) throws IOException {\n-    if (value == null) {\n-      return nullValue();\n-    }\n-    put(new JsonPrimitive(value));\n-    return this;\n-  }\n \n   @Override public JsonWriter value(double value) throws IOException {\n     if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\nindex 23ab8a13..0d6d013c 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n@@ -162,6 +162,10 @@ public final class TypeAdapters {\n     }\n     @Override\n     public void write(JsonWriter out, Boolean value) throws IOException {\n+      if (value == null) {\n+        out.nullValue();\n+        return;\n+      }\n       out.value(value);\n     }\n   };\ndiff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\nindex e2fc1961..a4178eee 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n@@ -473,15 +473,6 @@ public class JsonWriter implements Closeable, Flushable {\n    *\n    * @return this writer.\n    */\n-  public JsonWriter value(Boolean value) throws IOException {\n-    if (value == null) {\n-      return nullValue();\n-    }\n-    writeDeferredName();\n-    beforeValue();\n-    out.write(value ? \"true\" : \"false\");\n-    return this;\n-  }\n \n   /**\n    * Encodes {@code value}.\n"}
{"identifier": "Closure-116", "buggy_code": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n", "fixed_code": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;  // empty function case\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(\n            stmt.getFirstChild(), compiler);\n      }\n    }\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex accf4c5..c3fc14b 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -694,15 +694,6 @@ class FunctionInjector {\n \n     Node block = fnNode.getLastChild();\n \n-    boolean hasSideEffects = false;  // empty function case\n-    if (block.hasChildren()) {\n-      Preconditions.checkState(block.hasOneChild());\n-      Node stmt = block.getFirstChild();\n-      if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(\n-            stmt.getFirstChild(), compiler);\n-      }\n-    }\n \n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n@@ -729,9 +720,6 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n \n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n"}
{"identifier": "Chart-4", "buggy_code": "    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }\n", "fixed_code": "    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                if (r != null) {\n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n                }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 6536d1d..ec26162 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,7 +4490,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                if (r != null) {\n                     Collection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n@@ -4499,7 +4498,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                             includedAnnotations.add(a);\n                         }\n                     }\n-                }\n             }\n         }\n \n"}
{"identifier": "JacksonDatabind-64", "buggy_code": "    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n                _defaultInclusion);\n\n        // property annotation override\n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n\n            // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (_useRealPropertyDefaults) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n", "fixed_code": "    /**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n                _defaultInclusion);\n\n        // property annotation override\n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        \n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            Object defaultBean;\n\n            // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * @param contentTypeSer Optional explicit type information serializer\n     *    to use for contained values (only used for properties that are\n     *    of container type)\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\nindex 6363421ef..2bd24051f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n@@ -149,22 +149,17 @@ public class PropertyBuilder\n             //    whereas for global defaults OR per-property overrides, we have more\n             //    static definition. Sigh.\n             // First: case of class/type specifying it; try to find POJO property defaults\n-            Object defaultBean;\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n+            if (_useRealPropertyDefaults) {\n                 // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                 if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                     am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                 }\n-                try {\n-                    valueToSuppress = am.getValue(defaultBean);\n-                } catch (Exception e) {\n-                    _throwWrapped(e, propDef.getName(), defaultBean);\n-                }\n+                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n"}
{"identifier": "Jsoup-74", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/StringUtil.java b/src/main/java/org/jsoup/helper/StringUtil.java\nindex 9d2e744..439a7d6 100644\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n@@ -128,10 +128,7 @@ public final class StringUtil {\n         // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n     }\n \n-    public static boolean isInvisibleChar(int c) {\n-        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n         // zero width sp, zw non join, zw join, soft hyphen\n-    }\n \n     /**\n      * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n@@ -165,7 +162,7 @@ public final class StringUtil {\n                 accum.append(' ');\n                 lastWasWhite = true;\n             }\n-            else if (!isInvisibleChar(c)) {\n+            else {\n                 accum.appendCodePoint(c);\n                 lastWasWhite = false;\n                 reachedNonWhite = true;\n"}
{"identifier": "JacksonDatabind-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\nindex 5475ba564..fdfeecb2e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n@@ -63,7 +63,7 @@ public final class StringArrayDeserializer\n             if (t == JsonToken.VALUE_STRING) {\n                 value = jp.getText();\n             } else if (t == JsonToken.VALUE_NULL) {\n-                value = null; // since we have established that '_elementDeserializer == null' earlier\n+                value = _elementDeserializer.getNullValue();\n             } else {\n                 value = _parseString(jp, ctxt);\n             }\n@@ -92,7 +92,7 @@ public final class StringArrayDeserializer\n         \n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n             // Ok: no need to convert Strings, but must recognize nulls\n-            String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n+            String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);\n             if (ix >= chunk.length) {\n                 chunk = buffer.appendCompletedChunk(chunk);\n                 ix = 0;\n"}
{"identifier": "Compress-1", "buggy_code": "    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }\n", "fixed_code": "    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            super.close();\n            this.closed = true;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\nindex e66f58a9..aada02e8 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n@@ -343,7 +343,6 @@ public class CpioArchiveOutputStream extends ArchiveOutputStream implements\n      */\n     public void close() throws IOException {\n         if (!this.closed) {\n-            this.finish();\n             super.close();\n             this.closed = true;\n         }\n"}
{"identifier": "Compress-37", "buggy_code": "    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){\n                    // Get keyword\n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            if (restLen == 1) { // only NL\n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }\n", "fixed_code": "    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == '\\n') { // blank line in header\n                    break;\n                } else if (ch == ' '){ // End of length string\n                    // Get keyword\n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            if (restLen == 1) { // only NL\n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex f0d60cb8..61b908f0 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -459,9 +459,7 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n             int read = 0;\n             while((ch = i.read()) != -1) {\n                 read++;\n-                if (ch == '\\n') { // blank line in header\n-                    break;\n-                } else if (ch == ' '){ // End of length string\n+                if (ch == ' '){\n                     // Get keyword\n                     final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                     while((ch = i.read()) != -1) {\n"}
{"identifier": "Lang-9", "buggy_code": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }\n", "fixed_code": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 38857c7..8df302f 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -141,9 +141,6 @@ public class FastDateParser implements DateParser, Serializable {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n-        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n-            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n-        }\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }\n"}
{"identifier": "Closure-119", "buggy_code": "    public void collect(JSModule module, Scope scope, Node n) {\n      Node parent = n.getParent();\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) {\n            return;\n          }\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n                  return;\n                }\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              case Token.GETPROP:\n                return;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) {\n            return;\n          }\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(module, scope, n, parent, name);\n        }\n      } else {\n        handleGet(module, scope, n, parent, name);\n      }\n    }\n", "fixed_code": "    public void collect(JSModule module, Scope scope, Node n) {\n      Node parent = n.getParent();\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) {\n            return;\n          }\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n                  return;\n                }\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.CATCH:\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              case Token.GETPROP:\n                return;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) {\n            return;\n          }\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(module, scope, n, parent, name);\n        }\n      } else {\n        handleGet(module, scope, n, parent, name);\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic void collect(JSModule module, Scope scope, Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 0e9c4d3..639318d 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -363,7 +363,6 @@ class GlobalNamespace\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n-              case Token.CATCH:\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;\n"}
{"identifier": "Cli-4", "buggy_code": "    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (requiredOptions.size() > 0)\n        {\n            Iterator iter = requiredOptions.iterator();\n            StringBuffer buff = new StringBuffer();\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (requiredOptions.size() > 0)\n        {\n            Iterator iter = requiredOptions.iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Throws a\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex 2843ef1..35b025e 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -295,9 +295,7 @@ public abstract class Parser implements CommandLineParser {\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer(\"Missing required option\");\n-            buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n-            buff.append(\": \");\n+            StringBuffer buff = new StringBuffer();\n \n \n             // loop through the required options\n"}
{"identifier": "JacksonDatabind-67", "buggy_code": "    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        // and then post-processing\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n", "fixed_code": "    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        // and then post-processing\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex ade4b73f2..7d6a7bf5e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -1400,10 +1400,9 @@ public abstract class BasicDeserializerFactory\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                deser = _createEnumKeyDeserializer(ctxt, type);\n-            } else {\n-                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+                return _createEnumKeyDeserializer(ctxt, type);\n             }\n+            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n"}
{"identifier": "Chart-19", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex ec31907..cf3f52f 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,9 +695,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        if (axis == null) {\n-            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n-        }\n         return this.domainAxes.indexOf(axis);\n     }\n     \n@@ -973,9 +970,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        if (axis == null) {\n-            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n-        }\n         int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n"}
{"identifier": "JacksonDatabind-43", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\nindex 4847c3c77..dc0b05f48 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n@@ -4,7 +4,6 @@ import java.io.IOException;\n import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n@@ -76,16 +75,16 @@ public final class ObjectIdValueProperty\n     public Object deserializeSetAndReturn(JsonParser p,\n     \t\tDeserializationContext ctxt, Object instance) throws IOException\n     {\n+        Object id = _valueDeserializer.deserialize(p, ctxt);\n         /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n          *  missing or null id is needed for some cases, such as cases where id\n          *  will be generated externally, at a later point, and is not available\n          *  quite yet. Typical use case is with DB inserts.\n          */\n         // note: no null checks (unlike usually); deserializer should fail if one found\n-        if (p.hasToken(JsonToken.VALUE_NULL)) {\n+        if (id == null) {\n             return null;\n         }\n-        Object id = _valueDeserializer.deserialize(p, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         roid.bindItem(instance);\n         // also: may need to set a property value as well\n"}
{"identifier": "JacksonDatabind-24", "buggy_code": "    public BaseSettings withDateFormat(DateFormat df) {\n        if (_dateFormat == df) {\n            return this;\n        }\n        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                tz, _defaultBase64);\n    }\n", "fixed_code": "    public BaseSettings withDateFormat(DateFormat df) {\n        if (_dateFormat == df) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic BaseSettings withDateFormat(DateFormat df)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\nindex 7291b5d35..cd2da6187 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n@@ -231,9 +231,10 @@ public final class BaseSettings\n         if (_dateFormat == df) {\n             return this;\n         }\n+        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                 _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                _timeZone, _defaultBase64);\n+                tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n"}
{"identifier": "Closure-58", "buggy_code": "  /**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   */\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n              conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (NodeUtil.isVar(lhs)) {\n            // for(var x in y) {...}\n            lhs = lhs.getLastChild();\n          }\n            addToSetIfLocal(lhs, kill);\n            addToSetIfLocal(lhs, gen);\n          computeGenKill(rhs, gen, kill, conditional);\n        }\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n            if (!conditional) {\n              addToSetIfLocal(c, kill);\n            }\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // May short circuit.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Assume both sides are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          Node lhs = n.getFirstChild();\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          if (!NodeUtil.isAssign(n)) {\n            // assignments such as a += 1 reads a.\n            addToSetIfLocal(lhs, gen);\n          }\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n        } else {\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }\n", "fixed_code": "  /**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   */\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n              conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (NodeUtil.isVar(lhs)) {\n            // for(var x in y) {...}\n            lhs = lhs.getLastChild();\n          }\n          if (NodeUtil.isName(lhs)) {\n            addToSetIfLocal(lhs, kill);\n            addToSetIfLocal(lhs, gen);\n          } else {\n            computeGenKill(lhs, gen, kill, conditional);\n          }\n          computeGenKill(rhs, gen, kill, conditional);\n        }\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n            if (!conditional) {\n              addToSetIfLocal(c, kill);\n            }\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // May short circuit.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Assume both sides are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          Node lhs = n.getFirstChild();\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          if (!NodeUtil.isAssign(n)) {\n            // assignments such as a += 1 reads a.\n            addToSetIfLocal(lhs, gen);\n          }\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n        } else {\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\nindex e107faa..7999db4 100644\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n@@ -203,12 +203,8 @@ class LiveVariablesAnalysis extends\n             // for(var x in y) {...}\n             lhs = lhs.getLastChild();\n           }\n-          if (NodeUtil.isName(lhs)) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n-          } else {\n-            computeGenKill(lhs, gen, kill, conditional);\n-          }\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;\n"}
{"identifier": "JacksonDatabind-63", "buggy_code": "        public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { // can this ever occur?\n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    // Hmmh. Although Class.getName() is mostly ok, it does look\n                    // butt-ugly for arrays.\n                    // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n                    //   as it drops enclosing class. So let's try bit different approach\n                    String pkgName = com.fasterxml.jackson.databind.util.ClassUtil.getPackageName(cls);\n                    if (pkgName != null) {\n                        sb.append(pkgName);\n                        sb.append('.');\n                    }\n                    sb.append(cls.getSimpleName());\n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }\n", "fixed_code": "        public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { // can this ever occur?\n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    // Hmmh. Although Class.getName() is mostly ok, it does look\n                    // butt-ugly for arrays.\n                    // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n                    //   as it drops enclosing class. So let's try bit different approach\n                    int arrays = 0;\n                    while (cls.isArray()) {\n                        cls = cls.getComponentType();\n                        ++arrays;\n                    }\n                    sb.append(cls.getName());\n                    while (--arrays >= 0) {\n                        sb.append(\"[]\");\n                    }\n                    /* was:\n                    String pkgName = ClassUtil.getPackageName(cls);\n                    if (pkgName != null) {\n                        sb.append(pkgName);\n                        sb.append('.');\n                    }\n                    */\n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic String getDescription()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\nindex 00896ea..482622b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n@@ -127,22 +127,12 @@ public class JsonMappingException\n                     // butt-ugly for arrays.\n                     // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n                     //   as it drops enclosing class. So let's try bit different approach\n-                    int arrays = 0;\n-                    while (cls.isArray()) {\n-                        cls = cls.getComponentType();\n-                        ++arrays;\n-                    }\n-                    sb.append(cls.getName());\n-                    while (--arrays >= 0) {\n-                        sb.append(\"[]\");\n-                    }\n-                    /* was:\n-                    String pkgName = ClassUtil.getPackageName(cls);\n+                    String pkgName = com.fasterxml.jackson.databind.util.ClassUtil.getPackageName(cls);\n                     if (pkgName != null) {\n                         sb.append(pkgName);\n                         sb.append('.');\n                     }\n-                    */\n+                    sb.append(cls.getSimpleName());\n                 }\n                 sb.append('[');\n                 if (_fieldName != null) {\n"}
{"identifier": "Jsoup-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex fef6f1c..12c68ca 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -267,7 +267,7 @@ public class Element extends Node {\n     public Element append(String html) {\n         Validate.notNull(html);\n         \n-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();\n+        Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n         for (Node node : fragment.childNodes()) {\n             node.parentNode = null;\n             appendChild(node);\n@@ -284,7 +284,7 @@ public class Element extends Node {\n     public Element prepend(String html) {\n         Validate.notNull(html);\n         \n-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();\n+        Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n         List<Node> nodes = fragment.childNodes();\n         for (int i = nodes.size() - 1; i >= 0; i--) {\n             Node node = nodes.get(i);\n@@ -311,7 +311,7 @@ public class Element extends Node {\n     public Element wrap(String html) {\n         Validate.notEmpty(html);\n \n-        Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body();\n+        Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();\n         Elements wrapChildren = wrapBody.children();\n         Element wrap = wrapChildren.first();\n         if (wrap == null) // nothing to wrap with; noop\ndiff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java\nindex 62b0fd3..0cedf8a 100644\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n@@ -23,7 +23,6 @@ public class Parser {\n     private final TokenQueue tq;\n     private final Document doc;\n     private String baseUri;\n-    private boolean relaxed = false;\n \n     private Parser(String html, String baseUri, boolean isBodyFragment) {\n         Validate.notNull(html);\n@@ -71,11 +70,6 @@ public class Parser {\n      @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n      @return Document, with empty head, and HTML parsed into body\n      */\n-    public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n-        Parser parser = new Parser(bodyHtml, baseUri, true);\n-        parser.relaxed = true;\n-        return parser.parse();\n-    }\n \n     private Document parse() {\n         while (!tq.isEmpty()) {\n@@ -227,7 +221,7 @@ public class Parser {\n         Tag childTag = child.tag();\n         boolean validAncestor = stackHasValidParent(childTag);\n \n-        if (!validAncestor && !relaxed) {\n+        if (!validAncestor) {\n             // create implicit parent around this child\n             Tag parentTag = childTag.getImplicitParent();\n             Element implicit = new Element(parentTag, baseUri);\n@@ -256,14 +250,12 @@ public class Parser {\n         if (stack.size() == 1 && childTag.equals(htmlTag))\n             return true; // root is valid for html node\n \n-        if (childTag.requiresSpecificParent())\n-            return stack.getLast().tag().isValidParent(childTag);\n \n         // otherwise, look up the stack for valid ancestors\n         for (int i = stack.size() -1; i >= 0; i--) {\n             Element el = stack.get(i);\n             Tag parent2 = el.tag();\n-            if (parent2.isValidAncestor(childTag)) {\n+            if (parent2.isValidParent(childTag)) {\n                 return true;\n             }\n         }\ndiff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java\nindex 24333e7..0fb33bd 100644\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n@@ -25,7 +25,6 @@ public class Tag {\n     private boolean empty = false; // can hold nothing; e.g. img\n     private boolean preserveWhitespace = false; // for pre, textarea, script etc\n     private List<Tag> ancestors; // elements must be a descendant of one of these ancestors\n-    private Tag parent; // if not null, elements must be a direct child of parent\n \n     private Tag(String tagName) {\n         this.tagName = tagName.toLowerCase();\n@@ -97,8 +96,6 @@ public class Tag {\n             return false;\n \n         // don't allow children to contain their parent (directly)\n-        if (this.requiresSpecificParent() && this.getImplicitParent().equals(child))\n-            return false;\n         \n         return true;\n     }\n@@ -155,15 +152,9 @@ public class Tag {\n         return (!ancestors.isEmpty()) ? ancestors.get(0) : null;\n     }\n \n-    boolean requiresSpecificParent() {\n-        return this.parent != null;\n-    }\n \n     boolean isValidParent(Tag child) {\n-        return this.equals(child.parent);\n-    }\n \n-    boolean isValidAncestor(Tag child) {\n         if (child.ancestors.isEmpty())\n             return true; // HTML tag\n \n@@ -230,8 +221,8 @@ public class Tag {\n         createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n         createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n \n-        createBlock(\"FRAME\").setParent(\"FRAMESET\").setEmpty();\n-        createBlock(\"NOFRAMES\").setParent(\"FRAMESET\").setContainDataOnly();\n+        createBlock(\"FRAME\").setAncestor(\"FRAMESET\").setEmpty();\n+        createBlock(\"NOFRAMES\").setAncestor(\"FRAMESET\").setContainDataOnly();\n \n \n \n@@ -294,34 +285,34 @@ public class Tag {\n         createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly();\n         createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self\n         createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined\n-        createInline(\"OPTGROUP\").setParent(\"SELECT\"); //  only contain option\n-        createInline(\"OPTION\").setParent(\"SELECT\").setContainDataOnly();\n+        createInline(\"OPTGROUP\").setAncestor(\"SELECT\");\n+        createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly();\n         createBlock(\"FIELDSET\").setAncestor(\"FORM\");\n         createInline(\"LEGEND\").setAncestor(\"FIELDSET\");\n \n         // other\n         createInline(\"AREA\").setEmpty(); // not an inline per-se\n-        createInline(\"PARAM\").setParent(\"OBJECT\").setEmpty();\n+        createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty();\n         createBlock(\"INS\"); // only within body\n         createBlock(\"DEL\"); // only within body\n \n         createBlock(\"DL\");\n-        createInline(\"DT\").setParent(\"DL\").setOptionalClosing(); // only within DL.\n-        createInline(\"DD\").setParent(\"DL\").setOptionalClosing(); // only within DL.\n+        createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing();\n+        createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing();\n \n         createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL.\n \n         // tables\n         createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented\n-        createBlock(\"CAPTION\").setParent(\"TABLE\");\n-        createBlock(\"THEAD\").setParent(\"TABLE\").setOptionalClosing(); // just TR\n-        createBlock(\"TFOOT\").setParent(\"TABLE\").setOptionalClosing(); // just TR\n-        createBlock(\"TBODY\").setParent(\"TABLE\").setOptionalClosing(); // optional / implicit open too. just TR\n-        createBlock(\"COLGROUP\").setParent(\"TABLE\").setOptionalClosing(); // just COL\n-        createBlock(\"COL\").setParent(\"COLGROUP\").setEmpty();\n-        createBlock(\"TR\").setParent(\"TABLE\").setOptionalClosing(); // just TH, TD\n-        createBlock(\"TH\").setParent(\"TR\").setOptionalClosing();\n-        createBlock(\"TD\").setParent(\"TR\").setOptionalClosing();\n+        createBlock(\"CAPTION\").setAncestor(\"TABLE\");\n+        createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing();\n+        createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing();\n+        createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing();\n+        createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing();\n+        createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty();\n+        createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing();\n+        createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing();\n+        createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing();\n     }\n \n     private static Tag createBlock(String tagName) {\n@@ -385,9 +376,4 @@ public class Tag {\n         return this;\n     }\n \n-    private Tag setParent(String tagName) {\n-        parent = Tag.valueOf(tagName);\n-        setAncestor(tagName);\n-        return this;\n-    }\n }\n"}
{"identifier": "Mockito-20", "buggy_code": "    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        T mockInstance = null;\n        try {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }\n", "fixed_code": "    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n        T mockInstance = null;\n        try {\n            mockInstance = instantiator.newInstance(mockedProxyType);\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ),cce);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic <T> T createMock(MockCreationSettings<T> settings, MockHandler handler)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\nindex d5f77b6..9dc44e6 100644\n--- a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n+++ b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n@@ -29,10 +29,9 @@ public class ByteBuddyMockMaker implements MockMaker {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n-        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n         T mockInstance = null;\n         try {\n-            mockInstance = instantiator.newInstance(mockedProxyType);\n+            mockInstance = classInstantiator.instantiate(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n \n@@ -43,7 +42,7 @@ public class ByteBuddyMockMaker implements MockMaker {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n+                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n"}
{"identifier": "Math-66", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\nindex 46c4afa..9265415 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n@@ -41,10 +41,10 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n      * Construct a solver.\n      */\n     public BrentOptimizer() {\n-        setMaxEvaluations(1000);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n         setMaximalIterationCount(100);\n-        setAbsoluteAccuracy(1e-11);\n-        setRelativeAccuracy(1e-9);\n+        setAbsoluteAccuracy(1E-10);\n+        setRelativeAccuracy(1.0e-14);\n     }\n \n     /**\n@@ -54,10 +54,17 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throw new UnsupportedOperationException();\n+    }\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n+        clearResult();\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n-                        getMin(), getStartValue(), getMax(),\n+                        f, goalType, min, startValue, max,\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n+    }\n \n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.\n@@ -84,6 +91,8 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n+                            UnivariateRealFunction f,\n+                            GoalType goalType,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n@@ -107,14 +116,15 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n         double w = x;\n         double d = 0;\n         double e = 0;\n-        double fx = computeObjectiveValue(x);\n-        if (!isMinim) {\n+        double fx = computeObjectiveValue(f, x);\n+        if (goalType == GoalType.MAXIMIZE) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n \n-        while (true) {\n+        int count = 0;\n+        while (count < maximalIterationCount) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;\n@@ -187,8 +197,8 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n                     u = x + d;\n                 }\n \n-                double fu = computeObjectiveValue(u);\n-                if (!isMinim) {\n+                double fu = computeObjectiveValue(f, u);\n+                if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                 }\n \n@@ -225,10 +235,11 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n                     }\n                 }\n             } else { // termination\n-                setFunctionValue(isMinim ? fx : -fx);\n+                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                 return x;\n             }\n-            incrementIterationsCounter();\n+            ++count;\n         }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n"}
{"identifier": "Collections-25", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/collections4/IteratorUtils.java b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\nindex b3b1be0f..40f99898 100644\n--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n@@ -602,9 +602,7 @@ public class IteratorUtils {\n     public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                    final Iterator<? extends E> iterator1,\n                                                    final Iterator<? extends E> iterator2) {\n-        @SuppressWarnings(\"unchecked\")\n-        final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n-        return new CollatingIterator<E>(comp, iterator1, iterator2);\n+        return new CollatingIterator<E>(comparator, iterator1, iterator2);\n     }\n \n     /**\n@@ -625,9 +623,7 @@ public class IteratorUtils {\n      */\n     public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                    final Iterator<? extends E>... iterators) {\n-        @SuppressWarnings(\"unchecked\")\n-        final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n-        return new CollatingIterator<E>(comp, iterators);\n+        return new CollatingIterator<E>(comparator, iterators);\n     }\n \n     /**\n@@ -649,9 +645,7 @@ public class IteratorUtils {\n      */\n     public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                    final Collection<Iterator<? extends E>> iterators) {\n-        @SuppressWarnings(\"unchecked\")\n-        final Comparator<E> comp = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n-        return new CollatingIterator<E>(comp, iterators);\n+        return new CollatingIterator<E>(comparator, iterators);\n     }\n \n     // Object Graph\n"}
{"identifier": "JacksonDatabind-44", "buggy_code": "    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n        // TODO: fix in 2.8\n            /*\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n                    */\n            return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                    _valueHandler, _typeHandler, _asStatic);\n        // Otherwise, stitch together the hierarchy. First, super-class\n        // if not found, try a super-interface\n        // should not get here but...\n    }\n", "fixed_code": "    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n        // TODO: fix in 2.8\n        if (!_class.isAssignableFrom(subclass)) {\n            /*\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n                    */\n            return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                    _valueHandler, _typeHandler, _asStatic);\n        }\n        // Otherwise, stitch together the hierarchy. First, super-class\n        Class<?> next = subclass.getSuperclass();\n        if (next == _class) { // straight up parent class? Great.\n            return new SimpleType(subclass, _bindings, this,\n                    _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n        }\n        if ((next != null) && _class.isAssignableFrom(next)) {\n            JavaType superb = _narrow(next);\n            return new SimpleType(subclass, _bindings, superb,\n                    null, _valueHandler, _typeHandler, _asStatic);\n        }\n        // if not found, try a super-interface\n        Class<?>[] nextI = subclass.getInterfaces();\n        for (Class<?> iface : nextI) {\n            if (iface == _class) { // directly implemented\n                return new SimpleType(subclass, _bindings, null,\n                        new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic);\n            }\n            if (_class.isAssignableFrom(iface)) { // indirect, so recurse\n                JavaType superb = _narrow(iface);\n                return new SimpleType(subclass, _bindings, null,\n                        new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic);\n            }\n        }\n        // should not get here but...\n        throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \"\n                +_class.getName());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\nindex 0273c70cf..09fae7708 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n@@ -129,41 +129,15 @@ public class SimpleType // note: until 2.6 was final\n         // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n         //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n         // TODO: fix in 2.8\n-        if (!_class.isAssignableFrom(subclass)) {\n             /*\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n                     */\n             return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                     _valueHandler, _typeHandler, _asStatic);\n-        }\n         // Otherwise, stitch together the hierarchy. First, super-class\n-        Class<?> next = subclass.getSuperclass();\n-        if (next == _class) { // straight up parent class? Great.\n-            return new SimpleType(subclass, _bindings, this,\n-                    _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-        }\n-        if ((next != null) && _class.isAssignableFrom(next)) {\n-            JavaType superb = _narrow(next);\n-            return new SimpleType(subclass, _bindings, superb,\n-                    null, _valueHandler, _typeHandler, _asStatic);\n-        }\n         // if not found, try a super-interface\n-        Class<?>[] nextI = subclass.getInterfaces();\n-        for (Class<?> iface : nextI) {\n-            if (iface == _class) { // directly implemented\n-                return new SimpleType(subclass, _bindings, null,\n-                        new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic);\n-            }\n-            if (_class.isAssignableFrom(iface)) { // indirect, so recurse\n-                JavaType superb = _narrow(iface);\n-                return new SimpleType(subclass, _bindings, null,\n-                        new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic);\n-            }\n-        }\n         // should not get here but...\n-        throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \"\n-                +_class.getName());\n     }\n     \n     @Override\n"}
{"identifier": "Closure-42", "buggy_code": "    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n\n        // Return the bare minimum to put the AST in a valid state.\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }\n", "fixed_code": "    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n      if (loopNode.isForEach()) {\n        errorReporter.error(\n            \"unsupported language extension: for each\",\n            sourceName,\n            loopNode.getLineno(), \"\", 0);\n\n        // Return the bare minimum to put the AST in a valid state.\n        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n      }\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    Node processForInLoop(ForInLoop loopNode)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex c6b70c5..1a95aa2 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -565,15 +565,8 @@ class IRFactory {\n \n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n-      if (loopNode.isForEach()) {\n-        errorReporter.error(\n-            \"unsupported language extension: for each\",\n-            sourceName,\n-            loopNode.getLineno(), \"\", 0);\n \n         // Return the bare minimum to put the AST in a valid state.\n-        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n-      }\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),\n"}
{"identifier": "Jsoup-6", "buggy_code": "    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                } // skip\n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            if (charval != -1 || charval > 0xFFFF) { // out of range\n                String c = Character.toString((char) charval);\n                m.appendReplacement(accum, c);\n            } else {\n                m.appendReplacement(accum, m.group(0));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n", "fixed_code": "    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                } // skip\n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            if (charval != -1 || charval > 0xFFFF) { // out of range\n                String c = Character.toString((char) charval);\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nstatic String unescape(String string)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 739897c..3ffa83d 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -67,9 +67,9 @@ public class Entities {\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n+                m.appendReplacement(accum, c);\n             } else {\n-                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string\n+                m.appendReplacement(accum, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n"}
{"identifier": "Jsoup-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex d05c3cd..a9a2683 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -15,7 +15,6 @@ class CharacterReader {\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n-        input = input.replaceAll(\"\\r\\n?\", \"\\n\"); // normalise carriage returns to newlines\n \n         this.input = input;\n         this.length = input.length();\n@@ -97,7 +96,7 @@ class CharacterReader {\n     }\n \n     String consumeToEnd() {\n-        String data = input.substring(pos, input.length());\n+        String data = input.substring(pos, input.length() - 1);\n         pos = input.length();\n         return data;\n     }\n"}
{"identifier": "Math-19", "buggy_code": "    /**\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     */\n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     */\n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n                                                            true);\n                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                        throw e;\n                    }\n                }\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     */\n    private void checkParameters()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex f6a4f28..51d1c64 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -537,19 +537,6 @@ public class CMAESOptimizer\n                 boundaries[1] = uB;\n \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n-                            = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n-                    }\n-                }\n             }\n         } else {\n             // Convert API to internal handling of boundaries.\n"}
{"identifier": "Time-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex afa75d79..3ad5cfeb 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -93,7 +93,6 @@ public abstract class DateTimeZone implements Serializable {\n     /** The time zone for Universal Coordinated Time */\n     public static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\n     /** Maximum offset. */\n-    private static final int MAX_MILLIS = (86400 * 1000) - 1;\n \n     /** The instance that is providing time zones. */\n     private static Provider cProvider;\n@@ -255,19 +254,16 @@ public abstract class DateTimeZone implements Serializable {\n         if (hoursOffset == 0 && minutesOffset == 0) {\n             return DateTimeZone.UTC;\n         }\n-        if (hoursOffset < -23 || hoursOffset > 23) {\n-            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n-        }\n         if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n         int offset = 0;\n         try {\n-            int hoursInMinutes = hoursOffset * 60;\n+            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n             if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n             } else {\n-                minutesOffset = hoursInMinutes + minutesOffset;\n+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n@@ -283,9 +279,6 @@ public abstract class DateTimeZone implements Serializable {\n      * @return the DateTimeZone object for the offset\n      */\n     public static DateTimeZone forOffsetMillis(int millisOffset) {\n-        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n-            throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n-        }\n         String id = printOffset(millisOffset);\n         return fixedOffsetZone(id, millisOffset);\n     }\n"}
{"identifier": "JacksonDatabind-29", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\nindex b4e1a266d..93f3013f6 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n@@ -225,9 +225,6 @@ public class ExternalTypeHandler\n         JsonParser p2 = _tokens[index].asParser(p);\n         JsonToken t = p2.nextToken();\n         // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n-        if (t == JsonToken.VALUE_NULL) {\n-            return null;\n-        }\n \n         TokenBuffer merged = new TokenBuffer(p);\n         merged.writeStartArray();\n@@ -251,10 +248,6 @@ public class ExternalTypeHandler\n         JsonParser p2 = _tokens[index].asParser(p);\n         JsonToken t = p2.nextToken();\n         // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n-        if (t == JsonToken.VALUE_NULL) {\n-            _properties[index].getProperty().set(bean, null);\n-            return;\n-        }\n         TokenBuffer merged = new TokenBuffer(p);\n         merged.writeStartArray();\n         merged.writeString(typeId);\n"}
{"identifier": "JacksonDatabind-71", "buggy_code": "    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n        if (raw == String.class || raw == Object.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n            kind = TYPE_URI;\n        } else if (raw == URL.class) {\n            kind = TYPE_URL;\n        } else if (raw == Class.class) {\n            kind = TYPE_CLASS;\n        } else if (raw == Locale.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n        } else if (raw == Currency.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n        } else {\n            return null;\n        }\n        return new StdKeyDeserializer(kind, raw);\n    }\n", "fixed_code": "    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n            kind = TYPE_URI;\n        } else if (raw == URL.class) {\n            kind = TYPE_URL;\n        } else if (raw == Class.class) {\n            kind = TYPE_CLASS;\n        } else if (raw == Locale.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n            return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n        } else if (raw == Currency.class) {\n            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n        } else {\n            return null;\n        }\n        return new StdKeyDeserializer(kind, raw);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic static StdKeyDeserializer forType(Class<?> raw)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\nindex 8bddce4d7..d95749a21 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n@@ -72,7 +72,7 @@ public class StdKeyDeserializer extends KeyDeserializer\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n+        if (raw == String.class || raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n"}
{"identifier": "Math-17", "buggy_code": "    /** Multiply this by a single digit x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n            return multiplyFast(x);\n    }\n", "fixed_code": "    /** Multiply this by a single digit x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        if (x >= 0 && x < RADIX) {\n            return multiplyFast(x);\n        } else {\n            return multiply(newInstance(x));\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Multiply this by a single digit x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 3a91982..0f78330 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1600,11 +1600,7 @@ public class Dfp implements FieldElement<Dfp> {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n-        if (x >= 0 && x < RADIX) {\n             return multiplyFast(x);\n-        } else {\n-            return multiply(newInstance(x));\n-        }\n     }\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n"}
{"identifier": "Compress-33", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\nindex 8dc3c525..935283aa 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java\n@@ -237,9 +237,6 @@ public class CompressorStreamFactory {\n                 return new ZCompressorInputStream(in);\n             }\n \n-            if (DeflateCompressorInputStream.matches(signature, signatureLength)) {\n-                return new DeflateCompressorInputStream(in);\n-            }\n \n             if (XZUtils.matches(signature, signatureLength) &&\n                 XZUtils.isXZCompressionAvailable()) {\ndiff --git a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java\nindex b8ed1981..98d8ec12 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java\n@@ -30,11 +30,6 @@ import org.apache.commons.compress.compressors.CompressorInputStream;\n  * @since 1.9\n  */\n public class DeflateCompressorInputStream extends CompressorInputStream {\n-    private static final int MAGIC_1 = 0x78;\n-    private static final int MAGIC_2a = 0x01;\n-    private static final int MAGIC_2b = 0x5e;\n-    private static final int MAGIC_2c = 0x9c;\n-    private static final int MAGIC_2d = 0xda;\n     \n     private final InputStream in;\n \n@@ -108,11 +103,4 @@ public class DeflateCompressorInputStream extends CompressorInputStream {\n      * \n      * @since 1.9\n      */\n-    public static boolean matches(byte[] signature, int length) {\n-        return length > 3 && signature[0] == MAGIC_1 && (\n-                signature[1] == (byte) MAGIC_2a ||\n-                signature[1] == (byte) MAGIC_2b ||\n-                signature[1] == (byte) MAGIC_2c ||\n-                signature[1] == (byte) MAGIC_2d);\n-    }\n }\n"}
{"identifier": "Closure-131", "buggy_code": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n", "fixed_code": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          Character.isIdentifierIgnorable(s.charAt(0)) ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic static boolean isJSIdentifier(String s)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java\nindex cadb536..144a4ad 100644\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -191,13 +191,12 @@ public class TokenStream {\n       int length = s.length();\n \n       if (length == 0 ||\n-          Character.isIdentifierIgnorable(s.charAt(0)) ||\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n+        if (\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n"}
{"identifier": "Compress-36", "buggy_code": "    private InputStream getCurrentStream() throws IOException {\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }\n", "fixed_code": "    private InputStream getCurrentStream() throws IOException {\n        if (archive.files[currentEntryIndex].getSize() == 0) {\n            return new ByteArrayInputStream(new byte[0]);\n        }\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate InputStream getCurrentStream() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\nindex 10568407..3e2113df 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java\n@@ -899,9 +899,6 @@ public class SevenZFile implements Closeable {\n     }\n     \n     private InputStream getCurrentStream() throws IOException {\n-        if (archive.files[currentEntryIndex].getSize() == 0) {\n-            return new ByteArrayInputStream(new byte[0]);\n-        }\n         if (deferredBlockStreams.isEmpty()) {\n             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n         }\n"}
{"identifier": "Closure-174", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/JsAst.java b/src/com/google/javascript/jscomp/JsAst.java\nindex ff71d944..9f7bf8a5 100644\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n@@ -79,7 +79,6 @@ public class JsAst implements SourceAst {\n   }\n \n   private void parse(AbstractCompiler compiler) {\n-    int startErrorCount = compiler.getErrorManager().getErrorCount();\n     try {\n       ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n           compiler.getParserConfig(),\n@@ -93,11 +92,10 @@ public class JsAst implements SourceAst {\n     }\n \n \n-    if (root == null ||\n+    if (root == null || compiler.hasHaltingErrors()) {\n         // Most passes try to report as many errors as possible,\n         // so there may already be errors. We only care if there were\n         // errors in the code we just parsed.\n-        (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {\n       // There was a parse error or IOException, so use a dummy block.\n       root = IR.script();\n     } else {\ndiff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 4facea30..c4f7f8da 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2364,11 +2364,8 @@ public final class NodeUtil {\n     if (nameNode.isName()) {\n       result = IR.var(nameNode, value);\n       result.setJSDocInfo(info);\n-    } else if (value != null) {\n-      result = IR.exprResult(IR.assign(nameNode, value));\n-      result.getFirstChild().setJSDocInfo(info);\n     } else {\n-      result = IR.exprResult(nameNode);\n+      result = IR.exprResult(IR.assign(nameNode, value));\n       result.getFirstChild().setJSDocInfo(info);\n     }\n     return result;\ndiff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex 3a771c95..a4e503d0 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -353,8 +353,8 @@ class ScopedAliases implements HotSwapCompilerPass {\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+        boolean isVarAssign = parent.isVar() && n.hasChildren();\n+        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n           // Bleeding functions already get a BAD_PARAMETERS error, so just\n@@ -362,10 +362,8 @@ class ScopedAliases implements HotSwapCompilerPass {\n         } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n-        } else if (isVar) {\n-          Node value = n.hasChildren() ?\n-              v.getInitialValue().detachFromParent() :\n-              null;\n+        } else if (isVarAssign) {\n+          Node value = v.getInitialValue().detachFromParent();\n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);\n           scopedAliasNames.add(name);\n@@ -376,7 +374,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n \n           // Add $jscomp.scope.name = EXPR;\n           // Make sure we copy over all the jsdoc and debug info.\n-          if (value != null || v.getJSDocInfo() != null) {\n             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                 compiler.getCodingConvention(),\n                 globalName,\n@@ -386,7 +383,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n-          }\n \n           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n           v.getNameNode().addChildToFront(\n"}
{"identifier": "Jsoup-12", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/select/Selector.java b/src/main/java/org/jsoup/select/Selector.java\nindex 691b1cf..d54ba64 100644\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n@@ -136,7 +136,7 @@ public class Selector {\n     \n     private void combinator(char combinator) {\n         tq.consumeWhitespace();\n-        String subQuery = consumeSubQuery(); // support multi > childs\n+        String subQuery = tq.consumeToAny(combinators);\n         \n         Elements output;\n         if (combinator == '>')\n@@ -153,20 +153,6 @@ public class Selector {\n         elements.clear(); elements.addAll(output);\n     }\n \n-    private String consumeSubQuery() {\n-        StringBuilder sq = new StringBuilder();\n-        while (!tq.isEmpty()) {\n-            if (tq.matches(\"(\"))\n-                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n-            else if (tq.matches(\"[\"))\n-                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n-            else if (tq.matchesAny(combinators))\n-                break;\n-            else\n-                sq.append(tq.consume());\n-        }\n-        return sq.toString();\n-    }\n     \n     private Elements findElements() {\n         if (tq.matchChomp(\"#\")) {\n"}
{"identifier": "Codec-1", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/codec/language/Caverphone.java b/src/java/org/apache/commons/codec/language/Caverphone.java\nindex ea439852..07122953 100644\n--- a/src/java/org/apache/commons/codec/language/Caverphone.java\n+++ b/src/java/org/apache/commons/codec/language/Caverphone.java\n@@ -56,7 +56,7 @@ public class Caverphone implements StringEncoder {\n         }\n \n         // 1. Convert to lowercase\n-        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n+        txt = txt.toLowerCase();\n \n         // 2. Remove anything not A-Z\n         txt = txt.replaceAll(\"[^a-z]\", \"\");\ndiff --git a/src/java/org/apache/commons/codec/language/Metaphone.java b/src/java/org/apache/commons/codec/language/Metaphone.java\nindex a90e0ae3..88fea672 100644\n--- a/src/java/org/apache/commons/codec/language/Metaphone.java\n+++ b/src/java/org/apache/commons/codec/language/Metaphone.java\n@@ -85,7 +85,7 @@ public class Metaphone implements StringEncoder {\n         }\n         // single character is itself\n         if (txt.length() == 1) {\n-            return txt.toUpperCase(java.util.Locale.ENGLISH) ;\n+            return txt.toUpperCase() ;\n         }\n       \n         char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;\ndiff --git a/src/java/org/apache/commons/codec/language/SoundexUtils.java b/src/java/org/apache/commons/codec/language/SoundexUtils.java\nindex 2b04c085..1c6b983a 100644\n--- a/src/java/org/apache/commons/codec/language/SoundexUtils.java\n+++ b/src/java/org/apache/commons/codec/language/SoundexUtils.java\n@@ -50,7 +50,7 @@ final class SoundexUtils {\n             }\n         }\n         if (count == len) {\n-            return str.toUpperCase(java.util.Locale.ENGLISH);\n+            return str.toUpperCase();\n         }\n         return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n     }\n"}
{"identifier": "JacksonDatabind-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\nindex caea32836..ff8b1c4cf 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n@@ -780,39 +780,19 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n     @Override\n     public void writeObject(Object value) throws IOException\n     {\n-        if (value == null) {\n-            writeNull();\n-            return;\n-        }\n-        Class<?> raw = value.getClass();\n-        if (raw == byte[].class) {\n             _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n-            return;\n-        } else if (_objectCodec == null) {\n             /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n              *   err out, or just embed? For now, do latter.\n              */\n //          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n-            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n-        } else {\n-            _objectCodec.writeValue(this, value);\n-        }\n     }\n \n     @Override\n     public void writeTree(TreeNode node) throws IOException\n     {\n-        if (node == null) {\n-            writeNull();\n-            return;\n-        }\n \n-        if (_objectCodec == null) {\n             // as with 'writeObject()', is codec optional?\n             _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n-        } else {\n-            _objectCodec.writeTree(this, node);\n-        }\n     }\n \n     /*\n"}
{"identifier": "Closure-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\nindex 6777957..2987bda 100644\n--- a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n@@ -116,7 +116,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n   private String normalizeSourceName(String filename) {\n     // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n     // wrestle it back.\n-    filename = filename.replace(\"\\\\\", \"/\");\n \n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());\n@@ -181,7 +180,7 @@ public class ProcessCommonJSModules implements CompilerPass {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n-      String moduleName = guessCJSModuleName(script.getSourceFileName());\n+      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {\n"}
{"identifier": "JacksonDatabind-56", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex e27d6a9dc..c27ea729e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -228,13 +228,13 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n                 return Pattern.compile(value);\n             case STD_LOCALE:\n                 {\n-                    int ix = _firstHyphenOrUnderscore(value);\n+                    int ix = value.indexOf('_');\n                     if (ix < 0) { // single argument\n                         return new Locale(value);\n                     }\n                     String first = value.substring(0, ix);\n                     value = value.substring(ix+1);\n-                    ix = _firstHyphenOrUnderscore(value);\n+                    ix = value.indexOf('_');\n                     if (ix < 0) { // two pieces\n                         return new Locale(first, value);\n                     }\n@@ -289,15 +289,5 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n         }\n \n \n-        protected int _firstHyphenOrUnderscore(String str)\n-        {\n-            for (int i = 0, end = str.length(); i < end; ++i) {\n-                char c = str.charAt(i);\n-                if (c == '_' || c == '-') {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n     }\n }\n"}
{"identifier": "Jsoup-87", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex efbfced..9652120 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -137,9 +137,6 @@ public class Element extends Node {\n      * of the tag case preserving setting of the parser.\n      * @return\n      */\n-    public String normalName() {\n-        return tag.normalName();\n-    }\n \n     /**\n      * Change the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\ndiff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex bea598d..67a830a 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -312,7 +312,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n     Element getFromStack(String elName) {\n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n             Element next = stack.get(pos);\n-            if (next.normalName().equals(elName)) {\n+            if (next.nodeName().equals(elName)) {\n                 return next;\n             }\n         }\n@@ -334,7 +334,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n             Element next = stack.get(pos);\n             stack.remove(pos);\n-            if (next.normalName().equals(elName))\n+            if (next.nodeName().equals(elName))\n                 break;\n         }\n     }\n@@ -344,7 +344,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n             Element next = stack.get(pos);\n             stack.remove(pos);\n-            if (inSorted(next.normalName(), elNames))\n+            if (inSorted(next.nodeName(), elNames))\n                 break;\n         }\n     }\n@@ -352,7 +352,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n     void popStackToBefore(String elName) {\n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n             Element next = stack.get(pos);\n-            if (next.normalName().equals(elName)) {\n+            if (next.nodeName().equals(elName)) {\n                 break;\n             } else {\n                 stack.remove(pos);\n@@ -375,7 +375,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n     private void clearStackToContext(String... nodeNames) {\n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n             Element next = stack.get(pos);\n-            if (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(\"html\"))\n+            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                 break;\n             else\n                 stack.remove(pos);\n@@ -417,7 +417,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n                 last = true;\n                 node = contextElement;\n             }\n-            String name = node.normalName();\n+            String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n@@ -473,7 +473,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n         // don't walk too far up the tree\n \n         for (int pos = bottom; pos >= top; pos--) {\n-            final String elName = stack.get(pos).normalName();\n+            final String elName = stack.get(pos).nodeName();\n             if (inSorted(elName, targetNames))\n                 return true;\n             if (inSorted(elName, baseTypes))\n@@ -514,7 +514,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n     boolean inSelectScope(String targetName) {\n         for (int pos = stack.size() -1; pos >= 0; pos--) {\n             Element el = stack.get(pos);\n-            String elName = el.normalName();\n+            String elName = el.nodeName();\n             if (elName.equals(targetName))\n                 return true;\n             if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n@@ -566,8 +566,8 @@ public class HtmlTreeBuilder extends TreeBuilder {\n      process, then the UA must perform the above steps as if that element was not in the above list.\n      */\n     void generateImpliedEndTags(String excludeTag) {\n-        while ((excludeTag != null && !currentElement().normalName().equals(excludeTag)) &&\n-                inSorted(currentElement().normalName(), TagSearchEndTags))\n+        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n+                inSorted(currentElement().nodeName(), TagSearchEndTags))\n             pop();\n     }\n \n@@ -578,7 +578,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n     boolean isSpecial(Element el) {\n         // todo: mathml's mi, mo, mn\n         // todo: svg's foreigObject, desc, title\n-        String name = el.normalName();\n+        String name = el.nodeName();\n         return inSorted(name, TagSearchSpecial);\n     }\n \n@@ -615,7 +615,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n \n     private boolean isSameFormattingElement(Element a, Element b) {\n         // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n-        return a.normalName().equals(b.normalName()) &&\n+        return a.nodeName().equals(b.nodeName()) &&\n                 // a.namespace().equals(b.namespace()) &&\n                 a.attributes().equals(b.attributes());\n         // todo: namespaces\n@@ -646,7 +646,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n \n             // 8. create new element from element, 9 insert into current node, onto stack\n             skip = false; // can only skip increment from 4.\n-            Element newEl = insertStartTag(entry.normalName()); // todo: avoid fostering here?\n+            Element newEl = insertStartTag(entry.nodeName());\n             // newEl.namespace(entry.namespace()); // todo: namespaces\n             newEl.attributes().addAll(entry.attributes());\n \n@@ -686,7 +686,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n             Element next = formattingElements.get(pos);\n             if (next == null) // scope marker\n                 break;\n-            else if (next.normalName().equals(nodeName))\n+            else if (next.nodeName().equals(nodeName))\n                 return next;\n         }\n         return null;\ndiff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex a5532c7..656bd50 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -312,11 +312,11 @@ enum HtmlTreeBuilderState {\n                         ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n-                            if (el.normalName().equals(\"li\")) {\n+                            if (el.nodeName().equals(\"li\")) {\n                                 tb.processEndTag(\"li\");\n                                 break;\n                             }\n-                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n@@ -336,7 +336,7 @@ enum HtmlTreeBuilderState {\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         ArrayList<Element> stack = tb.getStack();\n-                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                         } else {\n@@ -350,7 +350,7 @@ enum HtmlTreeBuilderState {\n                     } else if (name.equals(\"frameset\")) {\n                         tb.error(this);\n                         ArrayList<Element> stack = tb.getStack();\n-                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals(\"body\"))) {\n+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                         } else if (!tb.framesetOk()) {\n@@ -369,7 +369,7 @@ enum HtmlTreeBuilderState {\n                         if (tb.inButtonScope(\"p\")) {\n                             tb.processEndTag(\"p\");\n                         }\n-                        if (StringUtil.inSorted(tb.currentElement().normalName(), Constants.Headings)) {\n+                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                             tb.error(this);\n                             tb.pop();\n                         }\n@@ -395,11 +395,11 @@ enum HtmlTreeBuilderState {\n                         ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n-                            if (StringUtil.inSorted(el.normalName(), Constants.DdDt)) {\n-                                tb.processEndTag(el.normalName());\n+                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n+                                tb.processEndTag(el.nodeName());\n                                 break;\n                             }\n-                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.normalName(), Constants.InBodyStartLiBreakers))\n+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n@@ -528,14 +528,14 @@ enum HtmlTreeBuilderState {\n                         else\n                             tb.transition(InSelect);\n                     } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n-                        if (tb.currentElement().normalName().equals(\"option\"))\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n                             tb.processEndTag(\"option\");\n                         tb.reconstructFormattingElements();\n                         tb.insert(startTag);\n                     } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                         if (tb.inScope(\"ruby\")) {\n                             tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().normalName().equals(\"ruby\")) {\n+                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                 tb.error(this);\n                                 tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                             }\n@@ -571,7 +571,7 @@ enum HtmlTreeBuilderState {\n                                 tb.error(this);\n                                 tb.removeFromActiveFormattingElements(formatEl);\n                                 return true;\n-                            } else if (!tb.inScope(formatEl.normalName())) {\n+                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                 tb.error(this);\n                                 return false;\n                             } else if (tb.currentElement() != formatEl)\n@@ -595,7 +595,7 @@ enum HtmlTreeBuilderState {\n                                 }\n                             }\n                             if (furthestBlock == null) {\n-                                tb.popStackToClose(formatEl.normalName());\n+                                tb.popStackToClose(formatEl.nodeName());\n                                 tb.removeFromActiveFormattingElements(formatEl);\n                                 return true;\n                             }\n@@ -630,7 +630,7 @@ enum HtmlTreeBuilderState {\n                                 lastNode = node;\n                             }\n \n-                            if (StringUtil.inSorted(commonAncestor.normalName(), Constants.InBodyEndTableFosters)) {\n+                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                 if (lastNode.parent() != null)\n                                     lastNode.remove();\n                                 tb.insertInFosterParent(lastNode);\n@@ -659,7 +659,7 @@ enum HtmlTreeBuilderState {\n                             return false;\n                         } else {\n                             tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().normalName().equals(name))\n+                            if (!tb.currentElement().nodeName().equals(name))\n                                 tb.error(this);\n                             tb.popStackToClose(name);\n                         }\n@@ -672,7 +672,7 @@ enum HtmlTreeBuilderState {\n                             return false;\n                         } else {\n                             tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().normalName().equals(name))\n+                            if (!tb.currentElement().nodeName().equals(name))\n                                 tb.error(this);\n                             tb.popStackToClose(name);\n                         }\n@@ -696,7 +696,7 @@ enum HtmlTreeBuilderState {\n                             return false;\n                         } else {\n                             tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().normalName().equals(name))\n+                            if (!tb.currentElement().nodeName().equals(name))\n                                 tb.error(this);\n                             // remove currentForm from stack. will shift anything under up.\n                             tb.removeFromStack(currentForm);\n@@ -708,7 +708,7 @@ enum HtmlTreeBuilderState {\n                             return tb.process(endTag);\n                         } else {\n                             tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().normalName().equals(name))\n+                            if (!tb.currentElement().nodeName().equals(name))\n                                 tb.error(this);\n                             tb.popStackToClose(name);\n                         }\n@@ -718,7 +718,7 @@ enum HtmlTreeBuilderState {\n                             return false;\n                         } else {\n                             tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().normalName().equals(name))\n+                            if (!tb.currentElement().nodeName().equals(name))\n                                 tb.error(this);\n                             tb.popStackToClose(name);\n                         }\n@@ -728,7 +728,7 @@ enum HtmlTreeBuilderState {\n                             return false;\n                         } else {\n                             tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().normalName().equals(name))\n+                            if (!tb.currentElement().nodeName().equals(name))\n                                 tb.error(this);\n                             tb.popStackToClose(Constants.Headings);\n                         }\n@@ -742,7 +742,7 @@ enum HtmlTreeBuilderState {\n                                 return false;\n                             }\n                             tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().normalName().equals(name))\n+                            if (!tb.currentElement().nodeName().equals(name))\n                                 tb.error(this);\n                             tb.popStackToClose(name);\n                             tb.clearFormattingElementsToLastMarker();\n@@ -765,13 +765,13 @@ enum HtmlTreeBuilderState {\n         }\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n-            String name = t.asEndTag().normalName; // case insensitive search - goal is to preserve output case, not for the parse to be case sensitive\n+            String name = tb.settings.normalizeTag(t.asEndTag().name());\n             ArrayList<Element> stack = tb.getStack();\n             for (int pos = stack.size() -1; pos >= 0; pos--) {\n                 Element node = stack.get(pos);\n-                if (node.normalName().equals(name)) {\n+                if (node.nodeName().equals(name)) {\n                     tb.generateImpliedEndTags(name);\n-                    if (!name.equals(tb.currentElement().normalName()))\n+                    if (!name.equals(tb.currentElement().nodeName()))\n                         tb.error(this);\n                     tb.popStackToClose(name);\n                     break;\n@@ -884,7 +884,7 @@ enum HtmlTreeBuilderState {\n                 }\n                 return true; // todo: as above todo\n             } else if (t.isEOF()) {\n-                if (tb.currentElement().normalName().equals(\"html\"))\n+                if (tb.currentElement().nodeName().equals(\"html\"))\n                     tb.error(this);\n                 return true; // stops parsing\n             }\n@@ -894,7 +894,7 @@ enum HtmlTreeBuilderState {\n         boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n             boolean processed;\n-            if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+            if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                 tb.setFosterInserts(true);\n                 processed = tb.process(t, InBody);\n                 tb.setFosterInserts(false);\n@@ -923,7 +923,7 @@ enum HtmlTreeBuilderState {\n                             if (!isWhitespace(character)) {\n                                 // InTable anything else section:\n                                 tb.error(this);\n-                                if (StringUtil.in(tb.currentElement().normalName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                                if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                     tb.setFosterInserts(true);\n                                     tb.process(new Token.Character().data(character), InBody);\n                                     tb.setFosterInserts(false);\n@@ -951,7 +951,7 @@ enum HtmlTreeBuilderState {\n                     return false;\n                 } else {\n                     tb.generateImpliedEndTags();\n-                    if (!tb.currentElement().normalName().equals(\"caption\"))\n+                    if (!tb.currentElement().nodeName().equals(\"caption\"))\n                         tb.error(this);\n                     tb.popStackToClose(\"caption\");\n                     tb.clearFormattingElementsToLastMarker();\n@@ -1004,7 +1004,7 @@ enum HtmlTreeBuilderState {\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n                     if (endTag.normalName.equals(\"colgroup\")) {\n-                        if (tb.currentElement().normalName().equals(\"html\")) { // frag case\n+                        if (tb.currentElement().nodeName().equals(\"html\")) {\n                             tb.error(this);\n                             return false;\n                         } else {\n@@ -1015,7 +1015,7 @@ enum HtmlTreeBuilderState {\n                         return anythingElse(t, tb);\n                     break;\n                 case EOF:\n-                    if (tb.currentElement().normalName().equals(\"html\"))\n+                    if (tb.currentElement().nodeName().equals(\"html\"))\n                         return true; // stop parsing; frag case\n                     else\n                         return anythingElse(t, tb);\n@@ -1086,7 +1086,7 @@ enum HtmlTreeBuilderState {\n                 return false;\n             }\n             tb.clearStackToTableBodyContext();\n-            tb.processEndTag(tb.currentElement().normalName()); // tbody, tfoot, thead\n+            tb.processEndTag(tb.currentElement().nodeName());\n             return tb.process(t);\n         }\n \n@@ -1170,7 +1170,7 @@ enum HtmlTreeBuilderState {\n                         return false;\n                     }\n                     tb.generateImpliedEndTags();\n-                    if (!tb.currentElement().normalName().equals(name))\n+                    if (!tb.currentElement().nodeName().equals(name))\n                         tb.error(this);\n                     tb.popStackToClose(name);\n                     tb.clearFormattingElementsToLastMarker();\n@@ -1237,13 +1237,13 @@ enum HtmlTreeBuilderState {\n                     if (name.equals(\"html\"))\n                         return tb.process(start, InBody);\n                     else if (name.equals(\"option\")) {\n-                        if (tb.currentElement().normalName().equals(\"option\"))\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n                             tb.processEndTag(\"option\");\n                         tb.insert(start);\n                     } else if (name.equals(\"optgroup\")) {\n-                        if (tb.currentElement().normalName().equals(\"option\"))\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n                             tb.processEndTag(\"option\");\n-                        else if (tb.currentElement().normalName().equals(\"optgroup\"))\n+                        else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                             tb.processEndTag(\"optgroup\");\n                         tb.insert(start);\n                     } else if (name.equals(\"select\")) {\n@@ -1266,15 +1266,15 @@ enum HtmlTreeBuilderState {\n                     name = end.normalName();\n                     switch (name) {\n                         case \"optgroup\":\n-                            if (tb.currentElement().normalName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(\"optgroup\"))\n+                            if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n                                 tb.processEndTag(\"option\");\n-                            if (tb.currentElement().normalName().equals(\"optgroup\"))\n+                            if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                                 tb.pop();\n                             else\n                                 tb.error(this);\n                             break;\n                         case \"option\":\n-                            if (tb.currentElement().normalName().equals(\"option\"))\n+                            if (tb.currentElement().nodeName().equals(\"option\"))\n                                 tb.pop();\n                             else\n                                 tb.error(this);\n@@ -1293,7 +1293,7 @@ enum HtmlTreeBuilderState {\n                     }\n                     break;\n                 case EOF:\n-                    if (!tb.currentElement().normalName().equals(\"html\"))\n+                    if (!tb.currentElement().nodeName().equals(\"html\"))\n                         tb.error(this);\n                     break;\n                 default:\n@@ -1380,17 +1380,17 @@ enum HtmlTreeBuilderState {\n                         return false;\n                 }\n             } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n-                if (tb.currentElement().normalName().equals(\"html\")) { // frag\n+                if (tb.currentElement().nodeName().equals(\"html\")) {\n                     tb.error(this);\n                     return false;\n                 } else {\n                     tb.pop();\n-                    if (!tb.isFragmentParsing() && !tb.currentElement().normalName().equals(\"frameset\")) {\n+                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n                         tb.transition(AfterFrameset);\n                     }\n                 }\n             } else if (t.isEOF()) {\n-                if (!tb.currentElement().normalName().equals(\"html\")) {\n+                if (!tb.currentElement().nodeName().equals(\"html\")) {\n                     tb.error(this);\n                     return true;\n                 }\ndiff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java\nindex 1808572..25488df 100644\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n@@ -1,7 +1,6 @@\n package org.jsoup.parser;\n \n import org.jsoup.helper.Validate;\n-import org.jsoup.internal.Normalizer;\n \n import java.util.HashMap;\n import java.util.Map;\n@@ -15,7 +14,6 @@ public class Tag {\n     private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags\n \n     private String tagName;\n-    private String normalName; // always the lower case version of this tag, regardless of case preservation mode\n     private boolean isBlock = true; // block or inline\n     private boolean formatAsBlock = true; // should be formatted as a block\n     private boolean canContainInline = true; // only pcdata if not\n@@ -27,7 +25,6 @@ public class Tag {\n \n     private Tag(String tagName) {\n         this.tagName = tagName;\n-        normalName = Normalizer.lowerCase(tagName);\n     }\n \n     /**\n@@ -43,9 +40,6 @@ public class Tag {\n      * Get this tag's normalized (lowercased) name.\n      * @return the tag's normal name.\n      */\n-    public String normalName() {\n-        return normalName;\n-    }\n \n     /**\n      * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n"}
{"identifier": "Jsoup-58", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/Jsoup.java b/src/main/java/org/jsoup/Jsoup.java\nindex 84a5e34..d25c186 100644\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n@@ -247,7 +247,7 @@ public class Jsoup {\n      @see #clean(String, org.jsoup.safety.Whitelist) \n      */\n     public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n-        return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n+        return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n     }\n     \n }\ndiff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java\nindex 0751c22..197219b 100644\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n@@ -126,10 +126,6 @@ public class Parser {\n      *\n      * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n      */\n-    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n-        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());\n-    }\n \n     /**\n      * Parse a fragment of XML into a list of nodes.\ndiff --git a/src/main/java/org/jsoup/safety/Cleaner.java b/src/main/java/org/jsoup/safety/Cleaner.java\nindex 1223bbe..7e0eb28 100644\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n@@ -14,7 +14,6 @@ import org.jsoup.parser.Tag;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n-import java.util.List;\n \n \n /**\n@@ -76,19 +75,9 @@ public class Cleaner {\n \n         Document clean = Document.createShell(dirtyDocument.baseUri());\n         int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n-        return numDiscarded == 0\n-            && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n+        return numDiscarded == 0;\n     }\n \n-    public boolean isValidBodyHtml(String bodyHtml) {\n-        Document clean = Document.createShell(\"\");\n-        Document dirty = Document.createShell(\"\");\n-        ParseErrorList errorList = ParseErrorList.tracking(1);\n-        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n-        dirty.body().insertChildren(0, nodes);\n-        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n-        return numDiscarded == 0 && errorList.size() == 0;\n-    }\n \n     /**\n      Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.\n"}
{"identifier": "Compress-23", "buggy_code": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] << (8 * i));\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n", "fixed_code": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\nindex 5e4f3e9d..0bc5a1ee 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n@@ -109,7 +109,7 @@ class Coders {\n             byte propsByte = coder.properties[0];\n             long dictSize = coder.properties[1];\n             for (int i = 1; i < 4; i++) {\n-                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n+                dictSize |= (coder.properties[i + 1] << (8 * i));\n             }\n             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                 throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n"}
{"identifier": "JxPath-17", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\nindex a979a10..a2ee4db 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n@@ -81,14 +81,18 @@ public class DOMAttributeIterator implements NodeIterator {\n         if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n             String testPrefix = name.getPrefix();\n \n-            if (testPrefix == null || equalStrings(testPrefix, nodePrefix)) {\n+            if (equalStrings(testPrefix, nodePrefix)) {\n                 return true;\n             }\n-            if (nodePrefix == null) {\n-                return false;\n+            String testNS = null;\n+            if (testPrefix != null) {\n+                testNS = parent.getNamespaceURI(testPrefix);\n             }\n-            return equalStrings(parent.getNamespaceURI(testPrefix), parent\n-                    .getNamespaceURI(nodePrefix));\n+            String nodeNS = null;\n+            if (nodePrefix != null) {\n+                nodeNS = parent.getNamespaceURI(nodePrefix);\n+            }\n+            return equalStrings(testNS, nodeNS);\n         }\n         return false;\n     }\n@@ -148,4 +152,4 @@ public class DOMAttributeIterator implements NodeIterator {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n-}\n\\ No newline at end of file\n+}\ndiff --git a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\nindex d7b7a30..db0b14d 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n@@ -67,9 +67,11 @@ public class JDOMAttributeIterator implements NodeIterator {\n             String lname = name.getName();\n             if (!lname.equals(\"*\")) {\n                 attributes = new ArrayList();\n+                if (ns != null) {\n                 Attribute attr = element.getAttribute(lname, ns);\n                 if (attr != null) {\n                     attributes.add(attr);\n+                    }\n                 }\n             }\n             else {\n@@ -77,8 +79,7 @@ public class JDOMAttributeIterator implements NodeIterator {\n                 List allAttributes = element.getAttributes();\n                 for (int i = 0; i < allAttributes.size(); i++) {\n                     Attribute attr = (Attribute) allAttributes.get(i);\n-                    if (ns == Namespace.NO_NAMESPACE\n-                            || attr.getNamespace().equals(ns)) {\n+                    if (attr.getNamespace().equals(ns)) {\n                         attributes.add(attr);\n                     }\n                 }\n@@ -113,4 +114,4 @@ public class JDOMAttributeIterator implements NodeIterator {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Jsoup-48", "buggy_code": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                    if (!values.isEmpty())\n                        header(name, values.get(0));\n                }\n            }\n        }\n", "fixed_code": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                    if (values.size() == 1)\n                        header(name, values.get(0));\n                    else if (values.size() > 1) {\n                        StringBuilder accum = new StringBuilder();\n                        for (int i = 0; i < values.size(); i++) {\n                            final String val = values.get(i);\n                            if (i != 0)\n                                accum.append(\", \");\n                            accum.append(val);\n                        }\n                        header(name, accum.toString());\n                    }\n                }\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid processResponseHeaders(Map<String, List<String>> resHeaders)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex a215b56..f8fd9dd 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -770,18 +770,8 @@ public class HttpConnection implements Connection {\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (values.size() == 1)\n+                    if (!values.isEmpty())\n                         header(name, values.get(0));\n-                    else if (values.size() > 1) {\n-                        StringBuilder accum = new StringBuilder();\n-                        for (int i = 0; i < values.size(); i++) {\n-                            final String val = values.get(i);\n-                            if (i != 0)\n-                                accum.append(\", \");\n-                            accum.append(val);\n-                        }\n-                        header(name, accum.toString());\n-                    }\n                 }\n             }\n         }\n"}
{"identifier": "Lang-30", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex da86fdb..dd2f5cf 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -1373,21 +1373,13 @@ public class StringUtils {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n-        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                         // ch is a supplementary character\n-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n-                            return i;\n-                        }\n-                    } else {\n                         return i;\n-                    }\n                 }\n             }\n         }\n@@ -1448,7 +1440,7 @@ public class StringUtils {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String cs, char[] searchChars) {\n+    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n@@ -1460,12 +1452,9 @@ public class StringUtils {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (Character.isHighSurrogate(ch)) {\n-                        if (j == searchLast) {\n+                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                             // missing low surrogate, fine, like String.indexOf(String)\n-                            return true;\n-                        }\n-                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                             return true;\n                         }\n                     } else {\n@@ -1505,7 +1494,7 @@ public class StringUtils {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String cs, String searchChars) {\n+    public static boolean containsAny(CharSequence cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n@@ -1541,21 +1530,13 @@ public class StringUtils {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n-        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n         outer:\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n-                            continue outer;\n-                        }\n-                    } else {\n                         continue outer;\n-                    }\n                 }\n             }\n             return i;\n@@ -1592,16 +1573,8 @@ public class StringUtils {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n-            boolean chFound = searchChars.indexOf(ch) >= 0;\n-            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n-                char ch2 = str.charAt(i + 1);\n-                if (chFound && searchChars.indexOf(ch2) < 0) {\n+            if (searchChars.indexOf(ch) < 0) {\n                     return i;\n-                }\n-            } else {\n-                if (!chFound) {\n-                    return i;\n-                }\n             }\n         }\n         return INDEX_NOT_FOUND;\n@@ -1702,25 +1675,14 @@ public class StringUtils {\n             return true;\n         }\n         int csLen = cs.length();\n-        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (Character.isHighSurrogate(ch)) {\n-                        if (j == searchLast) {\n                             // missing low surrogate, fine, like String.indexOf(String)\n-                            return false;\n-                        }\n-                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n-                            return false;\n-                        }\n-                    } else {\n                         // ch is in the Basic Multilingual Plane\n                         return false;\n-                    }\n                 }\n             }\n         }\n"}
{"identifier": "Mockito-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/util/Timer.java b/src/org/mockito/internal/util/Timer.java\nindex 907e545..4a51e5c 100644\n--- a/src/org/mockito/internal/util/Timer.java\n+++ b/src/org/mockito/internal/util/Timer.java\n@@ -1,6 +1,5 @@\n package org.mockito.internal.util;\n \n-import org.mockito.exceptions.Reporter;\n \n public class Timer {\n \n@@ -8,7 +7,6 @@ public class Timer {\n     private long startTime = -1;\n \n     public Timer(long durationMillis) {\n-        validateInput(durationMillis);\n         this.durationMillis = durationMillis;\n     }\n \n@@ -27,9 +25,4 @@ public class Timer {\n         startTime = System.currentTimeMillis();\n     }\n \n-    private void validateInput(long durationMillis) {\n-        if (durationMillis < 0) {\n-            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);\n-        }\n-    }\n }\n"}
{"identifier": "Jsoup-54", "buggy_code": "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "fixed_code": "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void copyAttributes(org.jsoup.nodes.Node source, Element el)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/W3CDom.java b/src/main/java/org/jsoup/helper/W3CDom.java\nindex 497e3ea..20aeeda 100644\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n@@ -123,7 +123,6 @@ public class W3CDom {\n             for (Attribute attribute : source.attributes()) {\n                 // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                 String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n-                if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n                     el.setAttribute(key, attribute.getValue());\n             }\n         }\n"}
{"identifier": "Cli-33", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/HelpFormatter.java b/src/main/java/org/apache/commons/cli/HelpFormatter.java\nindex 4329a8b..3322f76 100644\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n@@ -727,7 +727,7 @@ public class HelpFormatter\n     {\n         StringBuffer sb = new StringBuffer(text.length());\n \n-        renderWrappedTextBlock(sb, width, nextLineTabStop, text);\n+        renderWrappedText(sb, width, nextLineTabStop, text);\n         pw.println(sb.toString());\n     }\n \n@@ -897,25 +897,8 @@ public class HelpFormatter\n      * @param nextLineTabStop The position on the next line for the first tab.\n      * @param text The text to be rendered.\n      */\n-    private StringBuffer renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text) {\n-        try {\n-            BufferedReader in = new BufferedReader(new StringReader(text));\n-            String line;\n-            boolean firstLine = true;\n-            while ((line = in.readLine()) != null) {\n-                if (!firstLine) {\n-                    sb.append(getNewLine());\n-                } else {\n-                    firstLine = false;\n-                }\n-                renderWrappedText(sb, width, nextLineTabStop, line);\n-            }\n-        } catch (IOException e) {\n             // cannot happen\n-        }\n \n-        return sb;\n-    }\n \n     /**\n      * Finds the next text wrap position after <code>startPos</code> for the\n"}
{"identifier": "Math-51", "buggy_code": "    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                        // Update formula cannot make any progress: Update the\n                        // search interval.\n                default:\n                    // Should never happen.\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    if (x == x1) {\n                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n                                                          atol);\n                        // Update formula cannot make any progress: Update the\n                        // search interval.\n                        x0 = 0.5 * (x0 + x1 - delta);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex b3a23a1..e258c68 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -182,19 +182,10 @@ public abstract class BaseSecantSolver\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n-                case REGULA_FALSI:\n-                    if (x == x1) {\n-                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n-                                                          atol);\n                         // Update formula cannot make any progress: Update the\n                         // search interval.\n-                        x0 = 0.5 * (x0 + x1 - delta);\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n-                    break;\n                 default:\n                     // Should never happen.\n-                    throw new MathInternalError();\n                 }\n             }\n             // Update from [x0, x1] to [x0, x].\n"}
{"identifier": "JacksonDatabind-25", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex 8a737aade..a0cbf1615 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -1754,7 +1754,7 @@ public abstract class BasicDeserializerFactory\n         Class<?> subclass = intr.findDeserializationType(a, type);\n         if (subclass != null) {\n             try {\n-                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n+                type = (T) type.narrowBy(subclass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n             }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\nindex c6f12c10b..d79c8c883 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n@@ -474,7 +474,7 @@ public final class DeserializerCache\n         Class<?> subclass = intr.findDeserializationType(a, type);\n         if (subclass != null) {\n             try {\n-                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n+                type = type.narrowBy(subclass);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n             }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\nindex ef865d1ab..b991c7aa2 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n@@ -174,7 +174,7 @@ public abstract class TypeDeserializerBase\n                      *   important for some reason?\n                      *   Disabling the check will break 2 Enum-related tests.\n                      */\n-                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n+                    type = _baseType.narrowBy(type.getRawClass());\n                 }\n                 deser = ctxt.findContextualValueDeserializer(type, _property);\n             }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\nindex ff707118c..82de4d230 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n@@ -77,7 +77,7 @@ public class SimpleAbstractTypeResolver\n             return null;\n         }\n         // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-        return config.getTypeFactory().constructSpecializedType(type, dst);\n+        return type.narrowBy(dst);\n     }\n \n     \n"}
{"identifier": "JxPath-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\nindex b9c02bf..8cbd118 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.commons.jxpath.ri.model.beans;\n \n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.ri.QName;\n@@ -108,9 +106,6 @@ public class NullPropertyPointer extends PropertyPointer {\n             return newParent.createAttribute(context, getName());\n         }\n         else {\n-            if (parent instanceof NullPointer && parent.equals(newParent)) {\n-                throw createBadFactoryException(context.getFactory());\n-            }\n             // Consider these two use cases:\n             // 1. The parent pointer of NullPropertyPointer is \n             //    a PropertyOwnerPointer other than NullPointer. When we call \n@@ -140,9 +135,6 @@ public class NullPropertyPointer extends PropertyPointer {\n             return pointer;\n         }\n         else {\n-            if (parent instanceof NullPointer && parent.equals(newParent)) {\n-                throw createBadFactoryException(context.getFactory());\n-            }\n             if (newParent instanceof PropertyOwnerPointer) {\n                 PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n                 newParent = pop.getPropertyPointer();\n@@ -229,10 +221,4 @@ public class NullPropertyPointer extends PropertyPointer {\n         }\n         return string;\n     }\n-\n-    private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) {\n-        return new JXPathAbstractFactoryException(\"Factory \" + factory\n-                + \" reported success creating object for path: \" + asPath()\n-                + \" but object was null.  Terminating to avoid stack recursion.\");\n-    }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Lang-23", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\nindex 55ee7d1..a2cc169 100644\n--- a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n@@ -70,7 +70,6 @@ import org.apache.commons.lang3.Validate;\n  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n-    private static final int HASH_SEED = 31;\n \n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";\n@@ -261,42 +260,12 @@ public class ExtendedMessageFormat extends MessageFormat {\n      * @param obj the object to compare to\n      * @return true if this object equals the other, otherwise false\n      */\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == this) {\n-            return true;\n-        }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (!super.equals(obj)) {\n-            return false;\n-        }\n-        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n-          return false;\n-        }\n-        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n-        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n-            return false;\n-        }\n-        if (ObjectUtils.notEqual(registry, rhs.registry)) {\n-            return false;\n-        }\n-        return true;\n-    }\n \n     /**\n      * Return the hashcode.\n      *\n      * @return the hashcode\n      */\n-    @Override\n-    public int hashCode() {\n-        int result = super.hashCode();\n-        result = HASH_SEED * result + ObjectUtils.hashCode(registry);\n-        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);\n-        return result;\n-    }\n \n     /**\n      * Get a custom format from a format description.\n"}
{"identifier": "Csv-5", "buggy_code": "    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n            out.append(recordSeparator);\n        newRecord = true;\n    }\n", "fixed_code": "    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex a8aa33f..3255360 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -322,9 +322,7 @@ public final class CSVPrinter implements Flushable, Closeable {\n      */\n     public void println() throws IOException {\n         final String recordSeparator = format.getRecordSeparator();\n-        if (recordSeparator != null) {\n             out.append(recordSeparator);\n-        }\n         newRecord = true;\n     }\n \n"}
{"identifier": "JxPath-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex 55c2b98..fcc1f18 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -144,7 +144,8 @@ public class DOMNodePointer extends NodePointer {\n             int nodeType = node.getNodeType();\n             switch (((NodeTypeTest) test).getNodeType()) {\n                 case Compiler.NODE_TYPE_NODE :\n-                    return true;\n+                    return nodeType == Node.ELEMENT_NODE\n+                            || nodeType == Node.DOCUMENT_NODE;\n                 case Compiler.NODE_TYPE_TEXT :\n                     return nodeType == Node.CDATA_SECTION_NODE\n                         || nodeType == Node.TEXT_NODE;\ndiff --git a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\nindex 4ff42c7..601db7c 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n@@ -388,7 +388,7 @@ public class JDOMNodePointer extends NodePointer {\n         if (test instanceof NodeTypeTest) {\n             switch (((NodeTypeTest) test).getNodeType()) {\n                 case Compiler.NODE_TYPE_NODE :\n-                    return true;\n+                    return (node instanceof Element) || (node instanceof Document);\n                 case Compiler.NODE_TYPE_TEXT :\n                     return (node instanceof Text) || (node instanceof CDATA);\n                 case Compiler.NODE_TYPE_COMMENT :\n"}
{"identifier": "Compress-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\nindex 959df8de..3641ab69 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n@@ -333,6 +333,7 @@ public class CpioArchiveOutputStream extends ArchiveOutputStream implements\n      */\n     public void close() throws IOException {\n         if (!this.closed) {\n+            this.finish();\n             out.close();\n             this.closed = true;\n         }\ndiff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\nindex d3afc3da..abe87596 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n@@ -123,6 +123,7 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n      */\n     public void close() throws IOException {\n         if (!closed) {\n+            finish();\n             buffer.close();\n             out.close();\n             closed = true;\ndiff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\nindex 11808a96..5aa7c87c 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n@@ -527,6 +527,7 @@ public class ZipArchiveOutputStream extends ArchiveOutputStream {\n      * @exception  IOException  if an I/O error occurs.\n      */\n     public void close() throws IOException {\n+        finish();\n         if (raf != null) {\n             raf.close();\n         }\ndiff --git a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\nindex 778c2aa5..ec8e2cf4 100644\n--- a/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n+++ b/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java\n@@ -125,7 +125,6 @@ public class ChangeSetPerformer {\n                 results.addedFromChangeSet(change.getEntry().getName());\n             }\n         }\n-        out.finish();\n         return results;\n     }\n \n"}
{"identifier": "Jsoup-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/DocumentType.java b/src/main/java/org/jsoup/nodes/DocumentType.java\nindex f8c79f0..f9f77da 100644\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n@@ -1,7 +1,6 @@\n package org.jsoup.nodes;\n \n import org.jsoup.helper.StringUtil;\n-import org.jsoup.helper.Validate;\n \n /**\n  * A {@code <!DOCTPYE>} node.\n@@ -19,7 +18,6 @@ public class DocumentType extends Node {\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n@@ -32,11 +30,11 @@ public class DocumentType extends Node {\n \n     @Override\n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        accum.append(\"<!DOCTYPE \").append(attr(\"name\"));\n+        accum.append(\"<!DOCTYPE html\");\n         if (!StringUtil.isBlank(attr(\"publicId\")))\n             accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n         if (!StringUtil.isBlank(attr(\"systemId\")))\n-            accum.append(\" \\\"\").append(attr(\"systemId\")).append(\"\\\"\");\n+            accum.append(' ').append(attr(\"systemId\")).append(\"\\\"\");\n         accum.append('>');\n     }\n \n"}
{"identifier": "Closure-92", "buggy_code": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n", "fixed_code": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.lastIndexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex 1d738b5..c929a36 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -786,7 +786,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.lastIndexOf('.');\n+          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n"}
{"identifier": "Chart-1", "buggy_code": "    /**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "fixed_code": "    /**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset == null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 4a54655..226b25a 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset == null) {\n+        if (dataset != null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n"}
{"identifier": "JxPath-13", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\nindex 4d4a90a..d182676 100644\n--- a/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n+++ b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n@@ -44,24 +44,6 @@ public class NamespaceResolver implements Cloneable {\n      * @return prefix if found\n      * @since JXPath 1.3\n      */\n-    protected static String getPrefix(NodePointer pointer, String namespaceURI) {\n-        NodePointer currentPointer = pointer;\n-        while (currentPointer != null) {\n-            NodeIterator ni = currentPointer.namespaceIterator();\n-            for (int position = 1; ni != null && ni.setPosition(position); position++) {\n-                NodePointer nsPointer = ni.getNodePointer();\n-                String uri = nsPointer.getNamespaceURI();\n-                if (uri.equals(namespaceURI)) {\n-                    String prefix = nsPointer.getName().getName();\n-                    if (!\"\".equals(prefix)) {\n-                        return prefix;\n-                    }\n-                }\n-            }\n-            currentPointer = pointer.getParent();\n-        }\n-        return null;\n-    }\n \n     /**\n      * Create a new NamespaceResolver.\n@@ -123,10 +105,6 @@ public class NamespaceResolver implements Cloneable {\n      * @return namespace URI or null if the prefix is undefined.\n      */\n     public synchronized String getNamespaceURI(String prefix) {\n-        String uri = getExternallyRegisteredNamespaceURI(prefix);\n-        return uri == null && pointer != null ? pointer.getNamespaceURI(prefix)\n-                : uri;\n-    }\n \n     /**\n      * Given a prefix, returns an externally registered namespace URI.\n@@ -135,11 +113,14 @@ public class NamespaceResolver implements Cloneable {\n      * @return namespace URI or null if the prefix is undefined.\n      * @since JXPath 1.3\n      */\n-     protected synchronized String getExternallyRegisteredNamespaceURI(\n-            String prefix) {\n         String uri = (String) namespaceMap.get(prefix);\n-        return uri == null && parent != null ? parent\n-                .getExternallyRegisteredNamespaceURI(prefix) : uri;\n+        if (uri == null && pointer != null) {\n+            uri = pointer.getNamespaceURI(prefix);\n+        }\n+        if (uri == null && parent != null) {\n+            return parent.getNamespaceURI(prefix);\n+        }\n+        return uri;\n     }\n \n     /**\n@@ -148,10 +129,6 @@ public class NamespaceResolver implements Cloneable {\n      * @return String prefix\n      */\n     public synchronized String getPrefix(String namespaceURI) {\n-        String prefix = getExternallyRegisteredPrefix(namespaceURI);\n-        return prefix == null && pointer != null ? getPrefix(pointer,\n-                namespaceURI) : prefix;\n-    }\n \n     /**\n      * Get the nearest prefix found that matches an externally-registered namespace. \n@@ -159,9 +136,19 @@ public class NamespaceResolver implements Cloneable {\n      * @return String prefix if found.\n      * @since JXPath 1.3\n      */\n-    protected synchronized String getExternallyRegisteredPrefix(String namespaceURI) {\n         if (reverseMap == null) {\n             reverseMap = new HashMap();\n+            NodeIterator ni = pointer.namespaceIterator();\n+            if (ni != null) {\n+                for (int position = 1; ni.setPosition(position); position++) {\n+                    NodePointer nsPointer = ni.getNodePointer();\n+                    String uri = nsPointer.getNamespaceURI();                    \n+                    String prefix = nsPointer.getName().getName();\n+                    if (!\"\".equals(prefix)) {\n+                        reverseMap.put(uri, prefix);\n+                    }\n+                }\n+            }\n             Iterator it = namespaceMap.entrySet().iterator();\n             while (it.hasNext()) {\n                 Map.Entry entry = (Map.Entry) it.next();\n@@ -169,8 +156,10 @@ public class NamespaceResolver implements Cloneable {\n             }\n         }\n         String prefix = (String) reverseMap.get(namespaceURI);\n-        return prefix == null && parent != null ? parent\n-                .getExternallyRegisteredPrefix(namespaceURI) : prefix;\n+        if (prefix == null && parent != null) {\n+            return parent.getPrefix(namespaceURI);\n+        }\n+        return prefix;\n     }\n \n     /**\n@@ -208,4 +197,4 @@ public class NamespaceResolver implements Cloneable {\n         }\n     }\n \n-}\n\\ No newline at end of file\n+}\ndiff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex 4516297..f22f825 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -26,7 +26,6 @@ import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n-import org.apache.commons.jxpath.ri.NamespaceResolver;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n@@ -59,7 +58,6 @@ public class DOMNodePointer extends NodePointer {\n     private Map namespaces;\n     private String defaultNamespace;\n     private String id;\n-    private NamespaceResolver localNamespaceResolver;\n \n     public static final String XML_NAMESPACE_URI = \n             \"http://www.w3.org/XML/1998/namespace\";\n@@ -188,13 +186,6 @@ public class DOMNodePointer extends NodePointer {\n     /* (non-Javadoc)\n      * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n      */\n-    public synchronized NamespaceResolver getNamespaceResolver() {\n-        if (localNamespaceResolver == null) {\n-            localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n-            localNamespaceResolver.setNamespaceContextPointer(this);\n-        }\n-        return localNamespaceResolver;\n-    }\n \n     public String getNamespaceURI(String prefix) {\n         if (prefix == null || prefix.equals(\"\")) {\n@@ -421,11 +412,7 @@ public class DOMNodePointer extends NodePointer {\n         Element element = (Element) node;\n         String prefix = name.getPrefix();\n         if (prefix != null) {\n-            String ns = null;\n-            NamespaceResolver nsr = getNamespaceResolver();\n-            if (nsr != null) {\n-                ns = nsr.getNamespaceURI(prefix);\n-            }\n+            String ns = getNamespaceURI(prefix);\n             if (ns == null) {\n                 throw new JXPathException(\n                     \"Unknown namespace prefix: \" + prefix);\n"}
{"identifier": "JacksonDatabind-31", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\nindex fcf0c3b93..b7cec0b80 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n@@ -669,7 +669,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n         if (text == null) {\n             writeNull();\n         } else {\n-            _appendValue(JsonToken.VALUE_STRING, text);\n+            _append(JsonToken.VALUE_STRING, text);\n         }\n     }\n \n@@ -683,7 +683,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n         if (text == null) {\n             writeNull();\n         } else {\n-            _appendValue(JsonToken.VALUE_STRING, text);\n+            _append(JsonToken.VALUE_STRING, text);\n         }\n     }\n     \n@@ -728,7 +728,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n \n     @Override\n     public void writeRawValue(String text) throws IOException {\n-        _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n+        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n     }\n \n     @Override\n@@ -736,12 +736,12 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n         if (offset > 0 || len != text.length()) {\n             text = text.substring(offset, offset+len);\n         }\n-        _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n+        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new RawValue(text));\n     }\n \n     @Override\n     public void writeRawValue(char[] text, int offset, int len) throws IOException {\n-        _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n+        _append(JsonToken.VALUE_EMBEDDED_OBJECT, new String(text, offset, len));\n     }\n \n     /*\n@@ -752,27 +752,27 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n \n     @Override\n     public void writeNumber(short i) throws IOException {\n-        _appendValue(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n+        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n     }\n \n     @Override\n     public void writeNumber(int i) throws IOException {\n-        _appendValue(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n+        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n     }\n \n     @Override\n     public void writeNumber(long l) throws IOException {\n-        _appendValue(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n+        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n     }\n \n     @Override\n     public void writeNumber(double d) throws IOException {\n-        _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n     }\n \n     @Override\n     public void writeNumber(float f) throws IOException {\n-        _appendValue(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n     }\n \n     @Override\n@@ -780,7 +780,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n         if (dec == null) {\n             writeNull();\n         } else {\n-            _appendValue(JsonToken.VALUE_NUMBER_FLOAT, dec);\n+            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n         }\n     }\n \n@@ -789,7 +789,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n         if (v == null) {\n             writeNull();\n         } else {\n-            _appendValue(JsonToken.VALUE_NUMBER_INT, v);\n+            _append(JsonToken.VALUE_NUMBER_INT, v);\n         }\n     }\n \n@@ -798,17 +798,17 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n         /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n          *   identity as long as possible\n          */\n-        _appendValue(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n     }\n \n     @Override\n     public void writeBoolean(boolean state) throws IOException {\n-        _appendValue(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n+        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n     }\n \n     @Override\n     public void writeNull() throws IOException {\n-        _appendValue(JsonToken.VALUE_NULL);\n+        _append(JsonToken.VALUE_NULL);\n     }\n \n     /*\n@@ -826,7 +826,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n         }\n         Class<?> raw = value.getClass();\n         if (raw == byte[].class || (value instanceof RawValue)) {\n-            _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n+            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n             return;\n         }\n         if (_objectCodec == null) {\n@@ -834,7 +834,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n              *   err out, or just embed? For now, do latter.\n              */\n //          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n-            _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n+            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n         } else {\n             _objectCodec.writeValue(this, value);\n         }\n@@ -850,7 +850,7 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n \n         if (_objectCodec == null) {\n             // as with 'writeObject()', is codec optional?\n-            _appendValue(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n+            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);\n         } else {\n             _objectCodec.writeTree(this, node);\n         }\n@@ -1088,19 +1088,6 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n      *\n      * @since 2.6.4\n      */\n-    protected final void _appendValue(JsonToken type)\n-    {\n-        _writeContext.writeValue();\n-        Segment next = _hasNativeId\n-                ? _last.append(_appendAt, type, _objectId, _typeId)\n-                : _last.append(_appendAt, type);\n-        if (next == null) {\n-            ++_appendAt;\n-        } else {\n-            _last = next;\n-            _appendAt = 1; // since we added first at 0\n-        }\n-    }\n \n     /**\n      * Similar to {@link #_append(JsonToken,Object)} but also updates context with\n@@ -1108,19 +1095,6 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n      *\n      * @since 2.6.4\n      */\n-    protected final void _appendValue(JsonToken type, Object value)\n-    {\n-        _writeContext.writeValue();\n-        Segment next = _hasNativeId\n-                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n-                : _last.append(_appendAt, type, value);\n-        if (next == null) {\n-            ++_appendAt;\n-        } else {\n-            _last = next;\n-            _appendAt = 1;\n-        }\n-    }\n     \n     protected final void _appendRaw(int rawType, Object value)\n     {\n"}
{"identifier": "Jsoup-52", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex 6567e36..99c7976 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -109,7 +109,13 @@ public final class DataUtil {\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                 }\n                 if (foundCharset == null && meta.hasAttr(\"charset\")) {\n+                    try {\n+                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                     foundCharset = meta.attr(\"charset\");\n+                        }\n+                    } catch (IllegalCharsetNameException e) {\n+                        foundCharset = null;\n+                    }\n                 }\n             }\n             // look for <?xml encoding='ISO-8859-1'?>\ndiff --git a/src/main/java/org/jsoup/nodes/XmlDeclaration.java b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\nindex 619cd14..24a9f16 100644\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n@@ -43,17 +43,29 @@ public class XmlDeclaration extends Node {\n      @return XML declaration\n      */\n     public String getWholeDeclaration() {\n-        return attributes.html().trim(); // attr html starts with a \" \"\n+        final String decl = this.name;\n+        if(decl.equals(\"xml\") && attributes.size() > 1 ) {\n+            StringBuilder sb = new StringBuilder(decl);\n+            final String version = attributes.get(\"version\");\n+            if( version != null ) {\n+                sb.append(\" version=\\\"\").append(version).append(\"\\\"\");\n+            }\n+            final String encoding = attributes.get(\"encoding\");\n+            if( encoding != null ) {\n+                sb.append(\" encoding=\\\"\").append(encoding).append(\"\\\"\");\n+            }\n+            return sb.toString();\n+        }\n+        else {\n+            return this.name;\n+        }\n     }\n \n \tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         accum\n             .append(\"<\")\n             .append(isProcessingInstruction ? \"!\" : \"?\")\n-            .append(name);\n-        attributes.html(accum, out);\n-        accum\n-            .append(isProcessingInstruction ? \"!\" : \"?\")\n+                .append(getWholeDeclaration())\n             .append(\">\");\n     }\n \ndiff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex 3ccd7df..99807fc 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -1,6 +1,5 @@\n package org.jsoup.parser;\n \n-import org.jsoup.Jsoup;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n@@ -74,10 +73,8 @@ public class XmlTreeBuilder extends TreeBuilder {\n             // so we do a bit of a hack and parse the data as an element to pull the attributes out\n             String data = comment.getData();\n             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n-                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n-                Element el = doc.child(0);\n-                insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith(\"!\"));\n-                insert.attributes().addAll(el.attributes());\n+                String declaration = data.substring(1);\n+                insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(\"!\"));\n             }\n         }\n         insertNode(insert);\n"}
{"identifier": "JacksonDatabind-92", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex 74af716b4..bb73abfbc 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -61,13 +61,7 @@ public class BeanDeserializerFactory\n         // [databind#1680]: may or may not be problem, take no chance\n         s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n         // [databind#1737]; JDK provided\n-        s.add(\"java.util.logging.FileHandler\");\n-        s.add(\"java.rmi.server.UnicastRemoteObject\");\n         // [databind#1737]; 3rd party\n-        s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\");\n-        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n-        s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n-        s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n \n         DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n     }\n"}
{"identifier": "Math-92", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex 03c92eb..1ae554c 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -181,43 +181,30 @@ public final class MathUtils {\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n+        long result = Math.round(binomialCoefficientDouble(n, k));\n+        if (result == Long.MAX_VALUE) {\n+            throw new ArithmeticException(\n+                \"result too large to represent in a long integer\");\n+        }\n         // Use symmetry for large k\n-        if (k > n / 2)\n-            return binomialCoefficient(n, n - k);\n         \n         // We use the formula\n         // (n choose k) = n! / (n-k)! / k!\n         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n         // which could be written\n         // (n choose k) == (n-1 choose k-1) * n / k\n-        long result = 1;\n-        if (n <= 61) {\n             // For n <= 61, the naive implementation cannot overflow.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n-                result = result * i / j;\n-            }\n-        } else if (n <= 66) {\n             // For n > 61 but n <= 66, the result cannot overflow,\n             // but we must take care not to overflow intermediate values.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                 // We know that (result * i) is divisible by j,\n                 // but (result * i) may overflow, so we split j:\n                 // Filter out the gcd, d, so j/d and i/d are integer.\n                 // result is divisible by (j/d) because (j/d)\n                 // is relative prime to (i/d) and is a divisor of\n                 // result * (i/d).\n-                long d = gcd(i, j);\n-                result = (result / (j / d)) * (i / d);\n-            }\n-        } else {\n             // For n > 66, a result overflow might occur, so we check\n             // the multiplication, taking care to not overflow\n             // unnecessary.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n-                long d = gcd(i, j);\n-                result = mulAndCheck((result / (j / d)), (i / d));\n-            }\n-        }\n         return result;\n     }\n \n@@ -244,33 +231,9 @@ public final class MathUtils {\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientDouble(final int n, final int k) {\n-        if (n < k) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k)\");\n-        }\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= 0 for binomial coefficient (n,k)\");\n-        }\n-        if ((n == k) || (k == 0)) {\n-            return 1d;\n-        }\n-        if ((k == 1) || (k == n - 1)) {\n-            return n;\n-        }\n-        if (k > n/2) {\n-            return binomialCoefficientDouble(n, n - k);\n-        }\n-        if (n < 67) {\n-            return binomialCoefficient(n,k);\n-        }\n         \n-        double result = 1d;\n-        for (int i = 1; i <= k; i++) {\n-             result *= (double)(n - k + i) / (double)i;\n-        }\n   \n-        return Math.floor(result + 0.5);\n+        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n     }\n     \n     /**\n@@ -311,17 +274,11 @@ public final class MathUtils {\n          * For values small enough to do exact integer computation,\n          * return the log of the exact value \n          */\n-        if (n < 67) {  \n-            return Math.log(binomialCoefficient(n,k));\n-        }\n         \n         /*\n          * Return the log of binomialCoefficientDouble for values that will not\n          * overflow binomialCoefficientDouble\n          */\n-        if (n < 1030) { \n-            return Math.log(binomialCoefficientDouble(n, k));\n-        } \n         \n         /*\n          * Sum logs for values that could overflow\n"}
{"identifier": "Time-14", "buggy_code": "    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n", "fixed_code": "    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n            // month is largest field and being added to, such as month-day\n            int curMonth0 = partial.getValue(0) - 1;\n            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n            return set(partial, 0, values, newMonth);\n        }\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n//-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\nindex 2892a2d..afca44e 100644\n--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -206,12 +206,7 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n         if (valueToAdd == 0) {\n             return values;\n         }\n-        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n             // month is largest field and being added to, such as month-day\n-            int curMonth0 = partial.getValue(0) - 1;\n-            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n-            return set(partial, 0, values, newMonth);\n-        }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {\n"}
{"identifier": "JacksonDatabind-1", "buggy_code": "    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n", "fixed_code": "    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n            return;\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Alternative to\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\nindex 32ce099f7..45db172b8 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n@@ -589,7 +589,6 @@ public class BeanPropertyWriter\n             } else { // can NOT suppress entries in tabular output\n                 jgen.writeNull();\n             }\n-            return;\n         }\n         // otherwise find serializer to use\n         JsonSerializer<Object> ser = _serializer;\n"}
{"identifier": "Lang-53", "buggy_code": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        if (field == Calendar.SECOND) {\n            done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        if (field == Calendar.MINUTE) {\n            done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n", "fixed_code": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/time/DateUtils.java b/src/java/org/apache/commons/lang/time/DateUtils.java\nindex e5138b5..0dd0ded 100644\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -640,18 +640,18 @@ public class DateUtils {\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n-        }\n         if (field == Calendar.SECOND) {\n             done = true;\n+            }\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n-        }\n         if (field == Calendar.MINUTE) {\n             done = true;\n+            }\n         }\n \n         // truncate minutes\n"}
{"identifier": "Time-24", "buggy_code": "    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n", "fixed_code": "    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex 7c37fc1..b985cef 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,11 +352,6 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n-            if (resetFields) {\n-                for (int i = 0; i < count; i++) {\n-                    millis = savedFields[i].set(millis, i == (count - 1));\n-                }\n-            }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n"}
{"identifier": "Codec-2", "buggy_code": "    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n     * Must be called at least twice:  once with the data to encode, and once\n     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n     * so flush last remaining bytes (if not multiple of 3).\n     * </p><p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n     * and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in byte[] array of binary data to base64 encode.\n     * @param inPos Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n     * Must be called at least twice:  once with the data to encode, and once\n     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n     * so flush last remaining bytes (if not multiple of 3).\n     * </p><p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n     * and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in byte[] array of binary data to base64 encode.\n     * @param inPos Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            switch (modulus) {\n                case 1:\n                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n     * Must be called at least twice:  once with the data to encode, and once\n     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n     * so flush last remaining bytes (if not multiple of 3).\n     * </p><p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n     * and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in byte[] array of binary data to base64 encode.\n     * @param inPos Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     */\n    void encode(byte[] in, int inPos, int inAvail)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex dc2ecfc1..c00fbe5e 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -443,7 +443,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n                     }\n                     break;\n             }\n-            if (lineLength > 0 && pos > 0) {\n+            if (lineLength > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n"}
{"identifier": "Closure-15", "buggy_code": "      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n", "fixed_code": "      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n      public boolean apply(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex 20196bf..a8e92fc 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,9 +99,6 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n-        if (n.isDelProp()) {\n-          return true;\n-        }\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n"}
{"identifier": "Jsoup-33", "buggy_code": "    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n", "fixed_code": "    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nElement insert(Token.StartTag startTag)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex e134a58..975411b 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -159,7 +159,6 @@ class HtmlTreeBuilder extends TreeBuilder {\n         if (startTag.isSelfClosing()) {\n             Element el = insertEmpty(startTag);\n             stack.add(el);\n-            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n             tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n"}
{"identifier": "Closure-94", "buggy_code": "  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n\n      // Uniary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }\n", "fixed_code": "  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return isValidDefineValue(val.getFirstChild(), defines)\n            && isValidDefineValue(val.getLastChild(), defines);\n\n      // Uniary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n      case Token.POS:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 8c5d125..a31b17a 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -326,33 +326,14 @@ public final class NodeUtil {\n         return true;\n \n       // Binary operators are only valid if both children are valid.\n-      case Token.ADD:\n       case Token.BITAND:\n       case Token.BITNOT:\n       case Token.BITOR:\n       case Token.BITXOR:\n-      case Token.DIV:\n-      case Token.EQ:\n-      case Token.GE:\n-      case Token.GT:\n-      case Token.LE:\n-      case Token.LSH:\n-      case Token.LT:\n-      case Token.MOD:\n-      case Token.MUL:\n-      case Token.NE:\n-      case Token.RSH:\n-      case Token.SHEQ:\n-      case Token.SHNE:\n-      case Token.SUB:\n-      case Token.URSH:\n-        return isValidDefineValue(val.getFirstChild(), defines)\n-            && isValidDefineValue(val.getLastChild(), defines);\n \n       // Uniary operators are valid if the child is valid.\n       case Token.NOT:\n       case Token.NEG:\n-      case Token.POS:\n         return isValidDefineValue(val.getFirstChild(), defines);\n \n       // Names are valid if and only if they are defines themselves.\n"}
{"identifier": "JacksonDatabind-48", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\nindex 58487eb03..e01b7dda7 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n@@ -777,12 +777,6 @@ public final class DeserializationConfig\n         if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n             vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n         }\n-        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n-            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n-        }\n-        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n-            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n-        }\n         if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n             vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n         }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\nindex bf0c3f08b..da192ee35 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n@@ -862,12 +862,6 @@ public final class SerializationConfig\n     {\n         VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n         // then global overrides (disabling)\n-        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n-            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n-        }\n-        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n-            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n-        }\n         if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n             vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n         }\n"}
{"identifier": "Math-57", "buggy_code": "    /**\n     * Use K-means++ to choose the initial centers.\n     *\n     * @param <T> type of the points to cluster\n     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            int sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n\n        return resultSet;\n\n    }\n", "fixed_code": "    /**\n     * Use K-means++ to choose the initial centers.\n     *\n     * @param <T> type of the points to cluster\n     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            double sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n\n        return resultSet;\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Use K-means++ to choose the initial centers.\n     *\n     * @param <T> type of the points to cluster\n     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex e09bbc3..b73ac9d 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            double sum = 0;\n+            int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n"}
{"identifier": "Compress-8", "buggy_code": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n        int     start = offset;\n\n        for (int i = start; i < end; i++){\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) {\n                break;\n            }\n\n        // Skip leading spaces\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                   continue;\n            }\n                if (currentByte == (byte) ' ') {\n                break;\n                }\n            }\n\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "fixed_code": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        boolean allNUL = true;\n        for (int i = start; i < end; i++){\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        // May have additional NUL or space\n        trailer = buffer[end-1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 27b2a00d..31ef5368 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -50,50 +50,30 @@ public class TarUtils {\n      */\n     public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n         long    result = 0;\n+        boolean stillPadding = true;\n         int     end = offset + length;\n         int     start = offset;\n \n-        if (length < 2){\n-            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n-        }\n-\n-        boolean allNUL = true;\n         for (int i = start; i < end; i++){\n-            if (buffer[i] != 0){\n-                allNUL = false;\n+            final byte currentByte = buffer[i];\n+            if (currentByte == 0) {\n                 break;\n             }\n-        }\n-        if (allNUL) {\n-            return 0L;\n-        }\n \n         // Skip leading spaces\n-        while (start < end){\n-            if (buffer[start] == ' '){\n-                start++;\n-            } else {\n+            if (currentByte == (byte) ' ' || currentByte == '0') {\n+                if (stillPadding) {\n+                   continue;\n+            }\n+                if (currentByte == (byte) ' ') {\n                 break;\n+                }\n             }\n-        }\n \n         // Must have trailing NUL or space\n-        byte trailer;\n-        trailer = buffer[end-1];\n-        if (trailer == 0 || trailer == ' '){\n-            end--;\n-        } else {\n-            throw new IllegalArgumentException(\n-                    exceptionMessage(buffer, offset, length, end-1, trailer));\n-        }\n         // May have additional NUL or space\n-        trailer = buffer[end-1];\n-        if (trailer == 0 || trailer == ' '){\n-            end--;\n-        }\n \n-        for ( ;start < end; start++) {\n-            final byte currentByte = buffer[start];\n+            stillPadding = false;\n             // CheckStyle:MagicNumber OFF\n             if (currentByte < '0' || currentByte > '7'){\n                 throw new IllegalArgumentException(\n"}
{"identifier": "Gson-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\nindex adea605f..f86ad36f 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n@@ -275,10 +275,7 @@ public final class $Gson$Types {\n    * @param supertype a superclass of, or interface implemented by, this.\n    */\n   static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n-    if (context instanceof WildcardType) {\n       // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\n-      context = ((WildcardType)context).getUpperBounds()[0];\n-    }\n     checkArgument(supertype.isAssignableFrom(contextRawType));\n     return resolve(context, contextRawType,\n         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n"}
{"identifier": "Closure-160", "buggy_code": "  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        (warningsGuard == null || !warningsGuard.disables(\n            DiagnosticGroups.CHECK_VARIABLES))) {\n      guards.add(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = new ComposeWarningsGuard(guards);\n  }\n", "fixed_code": "  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex a4a41a8e..11850211 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -265,7 +265,6 @@ public class Compiler extends AbstractCompiler {\n             getDiagnosticGroups().getRegisteredGroups()));\n     guards.add(options.getWarningsGuard());\n \n-    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n \n     // All passes must run the variable check. This synthesizes\n     // variables later so that the compiler doesn't crash. It also\n@@ -273,12 +272,13 @@ public class Compiler extends AbstractCompiler {\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n-      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n+        (warningsGuard == null || !warningsGuard.disables(\n+            DiagnosticGroups.CHECK_VARIABLES))) {\n+      guards.add(new DiagnosticGroupWarningsGuard(\n           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n     }\n \n-    this.warningsGuard = composedGuards;\n+    this.warningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n   /**\n"}
{"identifier": "Time-4", "buggy_code": "    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n", "fixed_code": "    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 8e8e603..0d4edf4 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,7 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n"}
{"identifier": "JxPath-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\nindex e083ab3..26875b8 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n@@ -34,20 +34,12 @@ import org.apache.commons.jxpath.ri.axes.SelfContext;\n  * @version $Revision$ $Date$\n  */\n public abstract class CoreOperationCompare extends CoreOperation {\n-    private boolean invert;\n \n     public CoreOperationCompare(Expression arg1, Expression arg2) {\n-        this(arg1, arg2, false);\n-    }\n \n-    protected CoreOperationCompare(Expression arg1, Expression arg2, boolean invert) {\n         super(new Expression[] { arg1, arg2 });\n-        this.invert = invert;\n     }\n \n-    public Object computeValue(EvalContext context) {\n-        return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\n-    }\n \n     protected int getPrecedence() {\n         return 2;\n@@ -128,6 +120,11 @@ public abstract class CoreOperationCompare extends CoreOperation {\n     }\n \n     protected boolean equal(Object l, Object r) {\n+        if (l instanceof Pointer && r instanceof Pointer) {\n+            if (l.equals(r)) {\n+                return true;\n+            }\n+        }\n         if (l instanceof Pointer) {\n             l = ((Pointer) l).getValue();\n         }\n@@ -136,28 +133,21 @@ public abstract class CoreOperationCompare extends CoreOperation {\n             r = ((Pointer) r).getValue();\n         }\n \n-        boolean result;\n+        if (l == r) {\n+            return true;\n+        }\n         if (l instanceof Boolean || r instanceof Boolean) {\n-            result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r);\n-        } else if (l instanceof Number || r instanceof Number) {\n-            //if either side is NaN, no comparison returns true:\n-            double ld = InfoSetUtil.doubleValue(l);\n-            if (Double.isNaN(ld)) {\n-                return false;\n+            return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n             }\n-            double rd = InfoSetUtil.doubleValue(r);\n-            if (Double.isNaN(rd)) {\n-                return false;\n+            //if either side is NaN, no comparison returns true:\n+        if (l instanceof Number || r instanceof Number) {\n+            return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n             }\n-            result = ld == rd;\n-        } else {\n             if (l instanceof String || r instanceof String) {\n-                l = InfoSetUtil.stringValue(l);\n-                r = InfoSetUtil.stringValue(r);\n-            }\n-            result = l == r || l != null && l.equals(r);\n+            return (\n+                InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n         }\n-        return result ^ invert;\n+        return l != null && l.equals(r);\n     }\n \n }\ndiff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java\nindex 801e7fb..baca531 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java\n@@ -28,6 +28,9 @@ public class CoreOperationEqual extends CoreOperationCompare {\n         super(arg1, arg2);\n     }\n \n+    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n+        return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n     public String getSymbol() {\n         return \"=\";\n     }\ndiff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java\nindex aad3f5f..6754f46 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java\n@@ -25,9 +25,12 @@ package org.apache.commons.jxpath.ri.compiler;\n public class CoreOperationNotEqual extends CoreOperationCompare {\n \n     public CoreOperationNotEqual(Expression arg1, Expression arg2) {\n-        super(arg1, arg2, true);\n+        super(arg1, arg2);\n     }\n \n+    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n+        return equal(context, args[0], args[1]) ? Boolean.FALSE : Boolean.TRUE;\n+    }\n     public String getSymbol() {\n         return \"!=\";\n     }\n"}
{"identifier": "Closure-118", "buggy_code": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING, GET, SET\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }\n", "fixed_code": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING, GET, SET\n        if (child.isQuotedString()) {\n          continue;\n        }\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex 01293c9..b34921e 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -492,9 +492,6 @@ class DisambiguateProperties<T> implements CompilerPass {\n           child != null;\n           child = child.getNext()) {\n         // Maybe STRING, GET, SET\n-        if (child.isQuotedString()) {\n-          continue;\n-        }\n \n         // We should never see a mix of numbers and strings.\n         String name = child.getString();\n"}
{"identifier": "Jsoup-86", "buggy_code": "    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.childNodeSize() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n", "fixed_code": "    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.children().size() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Comment.java b/src/main/java/org/jsoup/nodes/Comment.java\nindex d983385..d0669fe 100644\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n@@ -75,7 +75,7 @@ public class Comment extends LeafNode {\n         String data = getData();\n         Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n         XmlDeclaration decl = null;\n-        if (doc.children().size() > 0) {\n+        if (doc.childNodeSize() > 0) {\n             Element el = doc.child(0);\n             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n             decl.attributes().addAll(el.attributes());\n"}
{"identifier": "Closure-76", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\nindex aaab0d6..63a7f29 100644\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n@@ -297,40 +297,26 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n           // If the currently node is the first child of\n           // AND/OR, be conservative only consider the READs\n           // of the second operand.\n-          if (n.getNext() != null) {\n-            state = isVariableReadBeforeKill(\n-                n.getNext(), variable);\n-            if (state == VariableLiveness.KILL) {\n-              state = VariableLiveness.MAYBE_LIVE;\n-            }\n-          }\n-          break;\n \n         case Token.HOOK:\n           // If current node is the condition, check each following\n           // branch, otherwise it is a conditional branch and the\n           // other branch can be ignored.\n-          if (n.getNext() != null && n.getNext().getNext() != null) {\n-            state = checkHookBranchReadBeforeKill(\n-                n.getNext(), n.getNext().getNext(), variable);\n-          }\n-          break;\n \n         default:\n           for(Node sibling = n.getNext(); sibling != null;\n               sibling = sibling.getNext()) {\n+            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n             state = isVariableReadBeforeKill(sibling, variable);\n-            if (state != VariableLiveness.MAYBE_LIVE) {\n-              break;\n-            }\n-          }\n-      }\n \n       // If we see a READ or KILL there is no need to continue.\n       if (state == VariableLiveness.READ) {\n         return true;\n       } else if (state == VariableLiveness.KILL) {\n         return false;\n+            }\n+          }\n+      }\n       }\n       n = n.getParent();\n     }\n@@ -351,9 +337,6 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n-    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION\n-      return VariableLiveness.MAYBE_LIVE;\n-    }\n \n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n@@ -376,25 +359,9 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n       // Conditionals\n       case Token.OR:\n       case Token.AND:\n-        VariableLiveness v1 = isVariableReadBeforeKill(\n-          n.getFirstChild(), variable);\n-        VariableLiveness v2 = isVariableReadBeforeKill(\n-          n.getLastChild(), variable);\n         // With a AND/OR the first branch always runs, but the second is\n         // may not.\n-        if (v1 != VariableLiveness.MAYBE_LIVE) {\n-          return v1;\n-        } else if (v2 == VariableLiveness.READ) {\n-          return VariableLiveness.READ;\n-        } else {\n-          return VariableLiveness.MAYBE_LIVE;\n-        }\n       case Token.HOOK:\n-        VariableLiveness first = isVariableReadBeforeKill(\n-            n.getFirstChild(), variable);\n-        if (first != VariableLiveness.MAYBE_LIVE) {\n-          return first;\n-        }\n         return checkHookBranchReadBeforeKill(\n             n.getFirstChild().getNext(), n.getLastChild(), variable);\n \n@@ -402,11 +369,13 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n         // Expressions are evaluated left-right, depth first.\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\n+          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n+      }\n     }\n \n     return VariableLiveness.MAYBE_LIVE;\n"}
{"identifier": "JacksonDatabind-27", "buggy_code": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n    }\n", "fixed_code": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\nindex 23d989e83..fc7961de5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n@@ -791,7 +791,7 @@ public class BeanDeserializer\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n"}
{"identifier": "Math-47", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex 137765c..bebfead 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -79,7 +79,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n     /** Record whether this complex number is zero. */\n-    private final transient boolean isZero;\n \n     /**\n      * Create a complex number given only the real part.\n@@ -103,7 +102,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n-        isZero = real == 0 && imaginary == 0;\n     }\n \n     /**\n@@ -255,8 +253,8 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n             return NaN;\n         }\n \n-        if (divisor.isZero) {\n-            return isZero ? NaN : INF;\n+        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {\n+            return NaN;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n@@ -292,7 +290,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return isZero ? NaN : INF;\n+            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n"}
{"identifier": "Cli-34", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/Option.java b/src/main/java/org/apache/commons/cli/Option.java\nindex 66c7ef9..11a3685 100644\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n@@ -69,7 +69,7 @@ public class Option implements Cloneable, Serializable\n     private int numberOfArgs = UNINITIALIZED;\n \n     /** the type of this Option */\n-    private Class type = String.class;\n+    private Class type;\n \n     /** the list of argument values **/\n     private List values = new ArrayList();\ndiff --git a/src/main/java/org/apache/commons/cli/OptionBuilder.java b/src/main/java/org/apache/commons/cli/OptionBuilder.java\nindex 6fd1b43..f9eb13a 100644\n--- a/src/main/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/main/java/org/apache/commons/cli/OptionBuilder.java\n@@ -81,7 +81,7 @@ public final class OptionBuilder\n         description = null;\n         argName = null;\n         longopt = null;\n-        type = String.class;\n+        type = null;\n         required = false;\n         numberOfArgs = Option.UNINITIALIZED;\n         optionalArg = false;\n"}
{"identifier": "Cli-39", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/TypeHandler.java b/src/main/java/org/apache/commons/cli/TypeHandler.java\nindex 68b4f02..93c0b73 100644\n--- a/src/main/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n@@ -89,7 +89,7 @@ public class TypeHandler\n         }\n         else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n         {\n-            return openFile(str);\n+            return createFile(str);\n         }\n         else if (PatternOptionBuilder.FILES_VALUE == clazz)\n         {\n@@ -231,17 +231,6 @@ public class TypeHandler\n      * @return The file input stream represented by <code>str</code>.\n      * @throws ParseException if the file is not exist or not readable\n      */\n-    public static FileInputStream openFile(String str) throws ParseException\n-    {\n-        try\n-        {\n-            return new FileInputStream(str);\n-        }\n-        catch (FileNotFoundException e)\n-        {\n-            throw new ParseException(\"Unable to find file: \" + str);\n-        }\n-    }\n \n     /**\n      * Returns the File[] represented by <code>str</code>.\n"}
{"identifier": "JxPath-1", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex 113b410..aef2de6 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -113,8 +113,7 @@ public class DOMNodePointer extends NodePointer {\n             int nodeType = node.getNodeType();\n             switch (((NodeTypeTest) test).getNodeType()) {\n                 case Compiler.NODE_TYPE_NODE :\n-                    return nodeType == Node.ELEMENT_NODE\n-                            || nodeType == Node.DOCUMENT_NODE;\n+                    return nodeType == Node.ELEMENT_NODE;\n                 case Compiler.NODE_TYPE_TEXT :\n                     return nodeType == Node.CDATA_SECTION_NODE\n                         || nodeType == Node.TEXT_NODE;\ndiff --git a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\nindex 32ffc1a..d151bed 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n@@ -373,7 +373,7 @@ public class JDOMNodePointer extends NodePointer {\n         else if (test instanceof NodeTypeTest) {\n             switch (((NodeTypeTest) test).getNodeType()) {\n                 case Compiler.NODE_TYPE_NODE :\n-                    return (node instanceof Element) || (node instanceof Document);\n+                    return node instanceof Element;\n                 case Compiler.NODE_TYPE_TEXT :\n                     return (node instanceof Text) || (node instanceof CDATA);\n                 case Compiler.NODE_TYPE_COMMENT :\n"}
{"identifier": "Compress-10", "buggy_code": "    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        Map<ZipArchiveEntry, OffsetEntry> origMap =\n            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n        entries.clear();\n        for (ZipArchiveEntry ze : origMap.keySet()) {\n            OffsetEntry offsetEntry = origMap.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            entries.put(ze, offsetEntry);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\nindex b0588695..964c86db 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java\n@@ -805,11 +805,8 @@ public class ZipFile {\n         // the hashcode - see COMPRESS-164\n         // Map needs to be reconstructed in order to keep central\n         // directory order\n-        Map<ZipArchiveEntry, OffsetEntry> origMap =\n-            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n-        entries.clear();\n-        for (ZipArchiveEntry ze : origMap.keySet()) {\n-            OffsetEntry offsetEntry = origMap.get(ze);\n+        for (ZipArchiveEntry ze : entries.keySet()) {\n+            OffsetEntry offsetEntry = entries.get(ze);\n             long offset = offsetEntry.headerOffset;\n             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n             byte[] b = new byte[SHORT];\n@@ -842,7 +839,6 @@ public class ZipFile {\n                     nameMap.put(ze.getName(), ze);\n                 }\n             }\n-            entries.put(ze, offsetEntry);\n         }\n     }\n \n"}
{"identifier": "Math-32", "buggy_code": "    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex add24ac..c6e7cf1 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -133,7 +133,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n+            if ((Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n"}
{"identifier": "Closure-78", "buggy_code": "  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <=\n        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n  }\n", "fixed_code": "  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <=\n        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 1afb7a8..c5ef4b0 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -708,12 +708,14 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n+          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n+          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n"}
{"identifier": "Jsoup-37", "buggy_code": "    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return accum.toString().trim();\n    }\n", "fixed_code": "    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Retrieves the element's inner HTML. E.g. on a\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex dcfa72c..f87ffcb 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1098,7 +1098,7 @@ public class Element extends Node {\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n+        return accum.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n"}
{"identifier": "Jsoup-89", "buggy_code": "    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }\n", "fixed_code": "    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = this.val;\n        if (parent != null) {\n            oldVal = parent.get(this.key); // trust the container more\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 8a51d10..4ff695d 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -85,9 +85,8 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      @param val the new attribute value; must not be null\n      */\n     public String setValue(String val) {\n-        String oldVal = this.val;\n+        String oldVal = parent.get(this.key);\n         if (parent != null) {\n-            oldVal = parent.get(this.key); // trust the container more\n             int i = parent.indexOfKey(this.key);\n             if (i != Attributes.NotFound)\n                 parent.vals[i] = val;\n"}
{"identifier": "Math-24", "buggy_code": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return current;\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return current;\n            }\n            ++iter;\n        }\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return best(current, previous, isMinim);\n            }\n            ++iter;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex cff5bfd..b6ce68e 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -227,7 +227,7 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n+                        return current;\n                     }\n                 }\n \n@@ -264,7 +264,7 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(current, previous, isMinim);\n+                return current;\n             }\n             ++iter;\n         }\n"}
{"identifier": "Compress-26", "buggy_code": "    /**\n     * Skips the given number of bytes by repeatedly invoking skip on\n     * the given input stream if necessary.\n     *\n     * <p>In a case where the stream's skip() method returns 0 before\n     * the requested number of bytes has been skip this implementation\n     * will fall back to using the read() method.</p>\n     *\n     * <p>This method will only skip less than the requested number of\n     * bytes if the end of the input stream has been reached.</p>\n     *\n     * @param input stream to skip bytes in\n     * @param numToSkip the number of bytes to skip\n     * @return the number of bytes actually skipped\n     * @throws IOException\n     */\n    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n            \n        return available - numToSkip;\n    }\n", "fixed_code": "    /**\n     * Skips the given number of bytes by repeatedly invoking skip on\n     * the given input stream if necessary.\n     *\n     * <p>In a case where the stream's skip() method returns 0 before\n     * the requested number of bytes has been skip this implementation\n     * will fall back to using the read() method.</p>\n     *\n     * <p>This method will only skip less than the requested number of\n     * bytes if the end of the input stream has been reached.</p>\n     *\n     * @param input stream to skip bytes in\n     * @param numToSkip the number of bytes to skip\n     * @return the number of bytes actually skipped\n     * @throws IOException\n     */\n    public static long skip(InputStream input, long numToSkip) throws IOException {\n        long available = numToSkip;\n        while (numToSkip > 0) {\n            long skipped = input.skip(numToSkip);\n            if (skipped == 0) {\n                break;\n            }\n            numToSkip -= skipped;\n        }\n            \n        if (numToSkip > 0) {\n            byte[] skipBuf = new byte[SKIP_BUF_SIZE];\n            while (numToSkip > 0) {\n                int read = readFully(input, skipBuf, 0,\n                                     (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n                if (read < 1) {\n                    break;\n                }\n                numToSkip -= read;\n            }\n        }\n        return available - numToSkip;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Skips the given number of bytes by repeatedly invoking skip on\n     * the given input stream if necessary.\n     *\n     * <p>In a case where the stream's skip() method returns 0 before\n     * the requested number of bytes has been skip this implementation\n     * will fall back to using the read() method.</p>\n     *\n     * <p>This method will only skip less than the requested number of\n     * bytes if the end of the input stream has been reached.</p>\n     *\n     * @param input stream to skip bytes in\n     * @param numToSkip the number of bytes to skip\n     * @return the number of bytes actually skipped\n     * @throws IOException\n     */\n    public static long skip(InputStream input, long numToSkip) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/utils/IOUtils.java b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\nindex 177d8f2a..686d75ad 100644\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n@@ -101,17 +101,6 @@ public final class IOUtils {\n             numToSkip -= skipped;\n         }\n             \n-        if (numToSkip > 0) {\n-            byte[] skipBuf = new byte[SKIP_BUF_SIZE];\n-            while (numToSkip > 0) {\n-                int read = readFully(input, skipBuf, 0,\n-                                     (int) Math.min(numToSkip, SKIP_BUF_SIZE));\n-                if (read < 1) {\n-                    break;\n-                }\n-                numToSkip -= read;\n-            }\n-        }\n         return available - numToSkip;\n     }\n \n"}
{"identifier": "Time-7", "buggy_code": "    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n", "fixed_code": "    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 913d036..447674a 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -705,9 +705,9 @@ public class DateTimeFormatter {\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n-        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n+        int defaultYear = chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n"}
{"identifier": "Closure-43", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex f9943a1..92d8715 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -417,7 +417,6 @@ final class TypedScopeCreator implements ScopeCreator {\n      * For more information, see\n      * http://code.google.com/p/closure-compiler/issues/detail?id=314\n      */\n-    private List<Node> lentObjectLiterals = null;\n \n     /**\n      * Type-less stubs.\n@@ -545,13 +544,6 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n \n       // Analyze any @lends object literals in this statement.\n-      if (n.getParent() != null && NodeUtil.isStatement(n) &&\n-          lentObjectLiterals != null) {\n-        for (Node objLit : lentObjectLiterals) {\n-          defineObjectLiteral(objLit);\n-        }\n-        lentObjectLiterals.clear();\n-      }\n     }\n \n     private void attachLiteralTypes(NodeTraversal t, Node n) {\n@@ -585,16 +577,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           break;\n \n         case Token.OBJECTLIT:\n-          JSDocInfo info = n.getJSDocInfo();\n-          if (info != null &&\n-              info.getLendsName() != null) {\n-            if (lentObjectLiterals == null) {\n-              lentObjectLiterals = Lists.newArrayList();\n-            }\n-            lentObjectLiterals.add(n);\n-          } else {\n             defineObjectLiteral(n);\n-          }\n           break;\n \n           // NOTE(nicksantos): If we ever support Array tuples,\n"}
{"identifier": "Jsoup-20", "buggy_code": "    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n", "fixed_code": "    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n            if (docData.charAt(0) == 65279)\n                docData = docData.substring(1);\n\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex 9adfe42..e5b044d 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -95,8 +95,6 @@ public class DataUtil {\n             // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n             // into head mode\n-            if (docData.charAt(0) == 65279)\n-                docData = docData.substring(1);\n \n             doc = parser.parseInput(docData, baseUri);\n             doc.outputSettings().charset(charsetName);\n"}
{"identifier": "Codec-12", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\nindex d1eb77bb..73f7e6b8 100644\n--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\n@@ -139,31 +139,9 @@ public class BaseNCodecInputStream extends FilterInputStream {\n      *\n      * @throws IllegalArgumentException if the provided skip length is negative\n      */\n-    @Override\n-    public long skip(long n) throws IOException {\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\"Negative skip length\");\n-        }\n \n         // skip in chunks of 512 bytes\n-        final byte[] b = new byte[512];\n-        final int max = (int) Math.min(n, Integer.MAX_VALUE);\n-        int total = 0;\n-\n-        while (total < max) {\n-            int len = max - total;\n-            if (len > b.length) {\n-                len = b.length;\n-            }\n-            len = read(b, 0, len);\n-            if (len == EOF) {\n-                break;\n-            }\n-            total += len;\n-        }\n \n-        return total;\n-    }\n \n     /**\n      * {@inheritDoc}\n@@ -171,17 +150,10 @@ public class BaseNCodecInputStream extends FilterInputStream {\n      * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\n      * <code>1</code> otherwise\n      */\n-    public int available() throws IOException {\n         // Note: the logic is similar to the InflaterInputStream:\n         //       as long as we have not reached EOF, indicate that there is more\n         //       data available. As we do not know for sure how much data is left,\n         //       just return 1 as a safe guess.\n \n         // use the EOF flag of the underlying codec instance\n-        if (baseNCodec.eof) {\n-            return 0;\n-        } else {\n-            return 1;\n-        }\n-    }\n }\n"}
{"identifier": "Math-69", "buggy_code": "    /**\n     * Returns a matrix of p-values associated with the (two-sided) null\n     * hypothesis that the corresponding correlation coefficient is zero.\n     * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n     * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n", "fixed_code": "    /**\n     * Returns a matrix of p-values associated with the (two-sided) null\n     * hypothesis that the corresponding correlation coefficient is zero.\n     * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n     * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns a matrix of p-values associated with the (two-sided) null\n     * hypothesis that the corresponding correlation coefficient is zero.\n     * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n     * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n     * a value with absolute value greater than or equal to <br>\n     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n     * <p>The values in the matrix are sometimes referred to as the\n     * <i>significance</i> of the corresponding correlation coefficients.</p>\n     *\n     * @return matrix of p-values\n     * @throws MathException if an error occurs estimating probabilities\n     */\n    public RealMatrix getCorrelationPValues() throws MathException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\nindex dc83314..83b4c41 100644\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n@@ -168,7 +168,7 @@ public class PearsonsCorrelation {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n+                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }\n"}
{"identifier": "Closure-35", "buggy_code": "  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null && constraintObj.isRecordType()) {\n      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n      if (objType != null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!objType.hasProperty(prop)) {\n              typeToInfer =\n                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n            }\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }\n    }\n  }\n", "fixed_code": "  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null) {\n      type.matchConstraint(constraintObj);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex fb6be1e..13e1092 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1118,8 +1118,21 @@ class TypeInference\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null) {\n-      type.matchConstraint(constraintObj);\n+    if (constraintObj != null && constraintObj.isRecordType()) {\n+      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      if (objType != null) {\n+        for (String prop : constraintObj.getOwnPropertyNames()) {\n+          JSType propType = constraintObj.getPropertyType(prop);\n+          if (!objType.isPropertyTypeDeclared(prop)) {\n+            JSType typeToInfer = propType;\n+            if (!objType.hasProperty(prop)) {\n+              typeToInfer =\n+                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n+            }\n+            objType.defineInferredProperty(prop, typeToInfer, null);\n+          }\n+        }\n+      }\n     }\n   }\n \n"}
{"identifier": "JacksonCore-4", "buggy_code": "    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        // but above intended maximum, slow to increase by 25%\n        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n", "fixed_code": "    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        // but above intended maximum, slow to increase by 25%\n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex a6773760..f97a083f 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -582,11 +582,8 @@ public final class TextBuffer\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n-        int newLen = len + (len >> 1);\n         // but above intended maximum, slow to increase by 25%\n-        if (newLen > MAX_SEGMENT_LEN) {\n-            newLen = len + (len >> 2);\n-        }\n+        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n"}
{"identifier": "JacksonDatabind-33", "buggy_code": "    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n", "fixed_code": "    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class)\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public PropertyName findNameForSerialization(Annotated a)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\nindex 5db1584c1..92b3ffa27 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n@@ -745,10 +745,7 @@ public class JacksonAnnotationIntrospector\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)\n-                    || _hasAnnotation(a, JsonUnwrapped.class)\n-                    || _hasAnnotation(a, JsonBackReference.class)\n-                    || _hasAnnotation(a, JsonManagedReference.class)) {\n+                    || _hasAnnotation(a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n"}
{"identifier": "Lang-7", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 064f547..d49da7f 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -449,6 +449,9 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n+        if (str.startsWith(\"--\")) {\n+            return null;\n+        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n@@ -715,13 +718,10 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n-        if (str.trim().startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n-            throw new NumberFormatException(str + \" is not a valid number.\");\n-        }\n         return new BigDecimal(str);\n     }\n \n"}
{"identifier": "Lang-13", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/SerializationUtils.java b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\nindex 7c89b61..1ee636c 100644\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n@@ -236,8 +236,6 @@ public class SerializationUtils {\n      * class here is a workaround, see the JIRA issue LANG-626. </p>\n      */\n      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {\n-        private static final Map<String, Class<?>> primitiveTypes = \n-                new HashMap<String, Class<?>>();\n         private ClassLoader classLoader;\n         \n         /**\n@@ -251,15 +249,6 @@ public class SerializationUtils {\n             super(in);\n             this.classLoader = classLoader;\n \n-            primitiveTypes.put(\"byte\", byte.class);\n-            primitiveTypes.put(\"short\", short.class);\n-            primitiveTypes.put(\"int\", int.class);\n-            primitiveTypes.put(\"long\", long.class);\n-            primitiveTypes.put(\"float\", float.class);\n-            primitiveTypes.put(\"double\", double.class);\n-            primitiveTypes.put(\"boolean\", boolean.class);\n-            primitiveTypes.put(\"char\", char.class);\n-            primitiveTypes.put(\"void\", void.class);\n         }\n \n         /**\n@@ -276,15 +265,7 @@ public class SerializationUtils {\n             try {\n                 return Class.forName(name, false, classLoader);\n             } catch (ClassNotFoundException ex) {\n-                try {\n                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-                } catch (ClassNotFoundException cnfe) {\n-                    Class<?> cls = primitiveTypes.get(name);\n-                    if (cls != null)\n-                        return cls;\n-                    else\n-                        throw cnfe;\n-                }\n             }\n         }\n \n"}
{"identifier": "Math-70", "buggy_code": "    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 180caef..3f66927 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(f, min, max);\n+        return solve(min, max);\n     }\n \n     /** {@inheritDoc} */\n"}
{"identifier": "Closure-132", "buggy_code": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !mayEffectMutableState(lhs)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .srcref(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }\n", "fixed_code": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !mayEffectMutableState(lhs) &&\n              (!mayHaveSideEffects(cond) ||\n                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .srcref(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 520c592..ae568e8 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,9 +779,7 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs) &&\n-              (!mayHaveSideEffects(cond) ||\n-                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n+              !mayEffectMutableState(lhs)) {\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n"}
{"identifier": "JxPath-19", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex 8e3b775..3300d03 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -557,21 +557,17 @@ public class DOMNodePointer extends NodePointer {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n         while (n != null) {\n-            if (n.getNodeType() == Node.ELEMENT_NODE && matchesQName(n)) {\n+            if (n.getNodeType() == Node.ELEMENT_NODE) {\n+                String nm = n.getNodeName();\n+                if (nm.equals(node.getNodeName())) {\n                 count++;\n+                }\n             }\n             n = n.getPreviousSibling();\n         }\n         return count;\n     }\n \n-    private boolean matchesQName(Node n) {\n-        if (getNamespaceURI() != null) {\n-            return equalStrings(getNamespaceURI(n), getNamespaceURI())\n-                    && equalStrings(node.getLocalName(), n.getLocalName());\n-        }\n-        return equalStrings(node.getNodeName(), n.getNodeName());\n-    }\n \n     /**\n      * Get relative position of this among all siblings.\ndiff --git a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\nindex 4b40a39..7df3ace 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n@@ -693,7 +693,8 @@ public class JDOMNodePointer extends NodePointer {\n             String name = ((Element) node).getQualifiedName();\n             for (int i = 0; i < children.size(); i++) {\n                 Object child = children.get(i);\n-                if (child instanceof Element && matchesQName(((Element) child))) {\n+                if ((child instanceof Element)\n+                    && ((Element) child).getQualifiedName().equals(name)) {\n                     count++;\n                 }\n                 if (child == node) {\n@@ -705,15 +706,6 @@ public class JDOMNodePointer extends NodePointer {\n         return 1;\n     }\n \n-    private boolean matchesQName(Element element) {\n-        if (getNamespaceURI() != null) {\n-            String ns = getNamespaceURI(element);\n-            if (ns == null || !ns.equals(getNamespaceURI())) {\n-                return false;\n-            }\n-        }\n-        return element.getName().equals(((Element) node).getName());\n-    }\n \n     /**\n      * Get relative position of this among all siblings.\n"}
{"identifier": "JacksonDatabind-76", "buggy_code": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    t = p.nextToken();\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue;\n                    }\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken();\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n", "fixed_code": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\nindex 817e29ec4..c3a3001af 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n@@ -580,7 +580,27 @@ public class BuilderBasedDeserializer\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n+                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n+                    t = p.nextToken();\n+                    Object bean;\n+                    try {\n+                        bean = creator.build(ctxt, buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue;\n+                    }\n+                    while (t == JsonToken.FIELD_NAME) {\n+                        p.nextToken();\n+                        tokens.copyCurrentStructure(p);\n+                        t = p.nextToken();\n+                    }\n+                    tokens.writeEndObject();\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n+                        return null;\n+                    }\n+                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n+                }\n                 continue;\n             }\n             // Object Id property?\n"}
{"identifier": "Lang-15", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\nindex 8db8abf..415cefa 100644\n--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n@@ -216,9 +216,9 @@ public class TypeUtils {\n                 toClass, typeVarAssigns);\n \n         // now to check each type argument\n-        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n-            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n-            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n+        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n+            Type toTypeArg = entry.getValue();\n+            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n \n             // parameters must either be absent from the subject type, within\n             // the bounds of the wildcard type, or be an exact match to the\n@@ -672,7 +672,7 @@ public class TypeUtils {\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n \n         // has target class been reached?\n-        if (toClass.equals(cls)) {\n+        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n             return typeVarAssigns;\n         }\n \n"}
{"identifier": "JacksonCore-10", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\nindex 7c37ffa4..241c06af 100644\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n@@ -922,8 +922,7 @@ public final class ByteQuadsCanonicalizer\n         /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n          *   since \"long names\" area follows. Instead, need to calculate from hash size.\n          */\n-        final int end = (_hashSize << 3);\n-        if (_spilloverEnd >= end) {\n+        if (_spilloverEnd >= hashArea.length) {\n             if (_failOnDoS) {\n                 _reportTooManyCollisions();\n             }\n@@ -982,8 +981,7 @@ public final class ByteQuadsCanonicalizer\n          *    to work it out, but this is the simplest, fast and seems to do ok.\n          */\n         hash += (hash >>> 16); // to xor hi- and low- 16-bits\n-        hash ^= (hash << 3); // shuffle back a bit\n-        hash += (hash >>> 12); // and bit more\n+        hash ^= (hash >>> 12);\n         return hash;\n     }\n \n"}
{"identifier": "Lang-46", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/StringEscapeUtils.java b/src/java/org/apache/commons/lang/StringEscapeUtils.java\nindex d4f98ec..7b22e21 100644\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -83,7 +83,7 @@ public class StringEscapeUtils {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n-        return escapeJavaStyleString(str, false, false);\n+        return escapeJavaStyleString(str, false);\n     }\n \n     /**\n@@ -99,7 +99,7 @@ public class StringEscapeUtils {\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void escapeJava(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, false, false);\n+        escapeJavaStyleString(out, str, false);\n     }\n \n     /**\n@@ -124,7 +124,7 @@ public class StringEscapeUtils {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n-        return escapeJavaStyleString(str, true, true);\n+        return escapeJavaStyleString(str, true);\n     }\n \n     /**\n@@ -140,7 +140,7 @@ public class StringEscapeUtils {\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, true, true);\n+        escapeJavaStyleString(out, str, true);\n     }\n \n     /**\n@@ -151,13 +151,13 @@ public class StringEscapeUtils {\n      * @param escapeForwardSlash TODO\n      * @return the escaped string\n      */\n-    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {\n+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n         if (str == null) {\n             return null;\n         }\n         try {\n             StringWriter writer = new StringWriter(str.length() * 2);\n-            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);\n+            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n             return writer.toString();\n         } catch (IOException ioe) {\n             // this should never ever happen while writing to a StringWriter\n@@ -175,8 +175,7 @@ public class StringEscapeUtils {\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n-    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n-            boolean escapeForwardSlash) throws IOException {\n+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }\n@@ -242,9 +241,7 @@ public class StringEscapeUtils {\n                         out.write('\\\\');\n                         break;\n                     case '/' :\n-                        if (escapeForwardSlash) {\n                             out.write('\\\\');\n-                        }\n                         out.write('/');\n                         break;\n                     default :\n"}
{"identifier": "Mockito-26", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/util/Primitives.java b/src/org/mockito/internal/util/Primitives.java\nindex 5a91f3a..b44b825 100644\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n@@ -63,6 +63,6 @@ public class Primitives {\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0D);\n+        primitiveValues.put(double.class, 0);\n     }\n }\n\\ No newline at end of file\n"}
{"identifier": "JxPath-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\nindex 355c8e3..5f7dcd0 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import org.apache.commons.jxpath.NodeSet;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n@@ -75,9 +74,6 @@ public abstract class Expression {\n         if (result instanceof EvalContext) {\n             return new ValueIterator((EvalContext) result);\n         }\n-        if (result instanceof NodeSet) {\n-            return new ValueIterator(((NodeSet) result).getPointers().iterator());\n-        }\n         return ValueUtils.iterate(result);\n     }\n \n@@ -89,11 +85,6 @@ public abstract class Expression {\n         if (result instanceof EvalContext) {\n             return (EvalContext) result;\n         }\n-        if (result instanceof NodeSet) {\n-            return new PointerIterator(((NodeSet) result).getPointers().iterator(),\n-                    new QName(null, \"value\"),\n-                    context.getRootContext().getCurrentNodePointer().getLocale());\n-        }\n         return new PointerIterator(ValueUtils.iterate(result),\n                 new QName(null, \"value\"),\n                 context.getRootContext().getCurrentNodePointer().getLocale());\n@@ -151,4 +142,4 @@ public abstract class Expression {\n             throw new UnsupportedOperationException();\n         }\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Compress-27", "buggy_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n        if (start == end) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "fixed_code": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        while (start < end && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 1782ffe6..4cf32d6f 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -130,6 +130,10 @@ public class TarUtils {\n             end--;\n             trailer = buffer[end - 1];\n         }\n+        if (start == end) {\n+            throw new IllegalArgumentException(\n+                    exceptionMessage(buffer, offset, length, start, trailer));\n+        }\n \n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n"}
{"identifier": "Jsoup-75", "buggy_code": "    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n", "fixed_code": "    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nfinal void html(final Appendable accum, final Document.OutputSettings out) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java\nindex 1f74bf3..1f4d812 100644\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -316,7 +316,8 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n             accum.append(' ').append(key);\n \n             // collapse checked=null, checked=\"\", checked=checked; write out others\n-            if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n+            if (!(out.syntax() == Document.OutputSettings.Syntax.html\n+                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n                 accum.append(\"=\\\"\");\n                 Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                 accum.append('\"');\n"}
{"identifier": "Lang-31", "buggy_code": "    /**\n     * <p>Checks if the CharSequence contains any character in the given\n     * set of characters.</p>\n     *\n     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)                = false\n     * StringUtils.containsAny(\"\", *)                  = false\n     * StringUtils.containsAny(*, null)                = false\n     * StringUtils.containsAny(*, [])                  = false\n     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n     * StringUtils.containsAny(\"aba\", ['z'])           = false\n     * </pre>\n     *\n     * @param cs  the CharSequence to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found,\n     * <code>false</code> if no match or null input\n     * @since 2.4\n     */\n\tpublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\t\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\t\treturn false;\n\t\t}\n\t\tint csLength = cs.length();\n\t\tint searchLength = searchChars.length;\n\t\tfor (int i = 0; i < csLength; i++) {\n\t\t\tchar ch = cs.charAt(i);\n\t\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n", "fixed_code": "    /**\n     * <p>Checks if the CharSequence contains any character in the given\n     * set of characters.</p>\n     *\n     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)                = false\n     * StringUtils.containsAny(\"\", *)                  = false\n     * StringUtils.containsAny(*, null)                = false\n     * StringUtils.containsAny(*, [])                  = false\n     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n     * StringUtils.containsAny(\"aba\", ['z'])           = false\n     * </pre>\n     *\n     * @param cs  the CharSequence to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found,\n     * <code>false</code> if no match or null input\n     * @since 2.4\n     */\n\tpublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\t\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\t\treturn false;\n\t\t}\n\t\tint csLength = cs.length();\n\t\tint searchLength = searchChars.length;\n\t\tint csLastIndex = csLength - 1;\n\t\tint searchLastIndex = searchLength - 1;\n\t\tfor (int i = 0; i < csLength; i++) {\n\t\t\tchar ch = cs.charAt(i);\n\t\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n\t\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Checks if the CharSequence contains any character in the given\n     * set of characters.</p>\n     *\n     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)                = false\n     * StringUtils.containsAny(\"\", *)                  = false\n     * StringUtils.containsAny(*, null)                = false\n     * StringUtils.containsAny(*, [])                  = false\n     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n     * StringUtils.containsAny(\"aba\", ['z'])           = false\n     * </pre>\n     *\n     * @param cs  the CharSequence to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found,\n     * <code>false</code> if no match or null input\n     * @since 2.4\n     */\n\tpublic static boolean containsAny(CharSequence cs, char[] searchChars)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 4aac02d..a90b067 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -1443,21 +1443,13 @@ public class StringUtils {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n-\t\tint csLastIndex = csLength - 1;\n-\t\tint searchLastIndex = searchLength - 1;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n-\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n \t\t\t\t\t\t// ch is a supplementary character\n-\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n \t\t\t\t\t\t// ch is in the Basic Multilingual Plane\n \t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n"}
{"identifier": "Lang-33", "buggy_code": "    /**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }\n", "fixed_code": "    /**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i] == null ? null : array[i].getClass();\n        }\n        return classes;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(Object[] array)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 3998966..615e4a9 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -907,7 +907,7 @@ public class ClassUtils {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i] == null ? null : array[i].getClass();\n+            classes[i] = array[i].getClass();\n         }\n         return classes;\n     }\n"}
{"identifier": "Time-6", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/chrono/GJChronology.java b/src/main/java/org/joda/time/chrono/GJChronology.java\nindex d1556f5..b970403 100644\n--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n@@ -193,10 +193,6 @@ public final class GJChronology extends AssembledChronology {\n             cutoverInstant = DEFAULT_CUTOVER;\n         } else {\n             cutoverInstant = gregorianCutover.toInstant();\n-            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\n-            if (cutoverDate.getYear() <= 0) {\n-                throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\n-            }\n         }\n \n         GJChronology chrono;\n@@ -980,17 +976,6 @@ public final class GJChronology extends AssembledChronology {\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n-                        if (iConvertByWeekyear) {\n-                            int wyear = iGregorianChronology.weekyear().get(instant);\n-                            if (wyear <= 0) {\n-                                instant = iGregorianChronology.weekyear().add(instant, -1);\n-                            }\n-                        } else {\n-                            int year = iGregorianChronology.year().get(instant);\n-                            if (year <= 0) {\n-                                instant = iGregorianChronology.year().add(instant, -1);\n-                            }\n-                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n@@ -1013,17 +998,6 @@ public final class GJChronology extends AssembledChronology {\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n-                        if (iConvertByWeekyear) {\n-                            int wyear = iGregorianChronology.weekyear().get(instant);\n-                            if (wyear <= 0) {\n-                                instant = iGregorianChronology.weekyear().add(instant, -1);\n-                            }\n-                        } else {\n-                            int year = iGregorianChronology.year().get(instant);\n-                            if (year <= 0) {\n-                                instant = iGregorianChronology.year().add(instant, -1);\n-                            }\n-                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n"}
{"identifier": "Gson-15", "buggy_code": "  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n", "fixed_code": "  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Encodes\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\nindex 8148816c..043c3bd5 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n@@ -492,7 +492,7 @@ public class JsonWriter implements Closeable, Flushable {\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n+    if (Double.isNaN(value) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n"}
{"identifier": "Math-84", "buggy_code": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        final RealConvergenceChecker checker = getConvergenceChecker();\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n                return;\n            }\n\n            // check convergence\n            final int iter = getIterations();\n            boolean converged = true;\n            for (int i = 0; i < simplex.length; ++i) {\n                converged &= checker.converged(iter, original[i], simplex[i]);\n            }\n            if (converged) {\n                return;\n            }\n\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 929560c..42a4d9d 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -61,7 +61,6 @@ public class MultiDirectional extends DirectSearchOptimizer {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n-        final RealConvergenceChecker checker = getConvergenceChecker();\n         while (true) {\n \n             incrementIterationsCounter();\n@@ -90,16 +89,8 @@ public class MultiDirectional extends DirectSearchOptimizer {\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n-                return;\n-            }\n \n             // check convergence\n-            final int iter = getIterations();\n-            boolean converged = true;\n-            for (int i = 0; i < simplex.length; ++i) {\n-                converged &= checker.converged(iter, original[i], simplex[i]);\n-            }\n-            if (converged) {\n                 return;\n             }\n \n"}
{"identifier": "JacksonDatabind-69", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\nindex a530e4b20..b3030afdc 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n@@ -162,20 +162,18 @@ public class CreatorCollector\n             SettableBeanProperty[] injectables)\n     {\n         if (creator.getParameterType(0).isCollectionLikeType()) {\n-            if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) {\n+            verifyNonDup(creator, C_ARRAY_DELEGATE, explicit);\n                 _arrayDelegateArgs = injectables;\n-            }\n         } else {\n-            if (verifyNonDup(creator, C_DELEGATE, explicit)) {\n+            verifyNonDup(creator, C_DELEGATE, explicit);\n                 _delegateArgs = injectables;\n-            }\n         }\n     }\n     \n     public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n             SettableBeanProperty[] properties)\n     {\n-        if (verifyNonDup(creator, C_PROPS, explicit)) {\n+        verifyNonDup(creator, C_PROPS, explicit);\n             // Better ensure we have no duplicate names either...\n             if (properties.length > 1) {\n                 HashMap<String,Integer> names = new HashMap<String,Integer>();\n@@ -194,7 +192,6 @@ public class CreatorCollector\n                 }\n             }\n             _propertyBasedArgs = properties;\n-        }\n     }\n \n     public void addIncompeteParameter(AnnotatedParameter parameter) {\n@@ -299,7 +296,7 @@ public class CreatorCollector\n     /**\n      * @return True if specified Creator is to be used\n      */\n-    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n+    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n     {\n         final int mask = (1 << typeIndex);\n         _hasNonDefaultCreator = true;\n@@ -310,7 +307,7 @@ public class CreatorCollector\n             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                 // but skip, if new one not annotated\n                 if (!explicit) {\n-                    return false;\n+                    return;\n                 }\n                 // both explicit: verify\n                 verify = true;\n@@ -332,7 +329,7 @@ public class CreatorCollector\n                 // otherwise, which one to choose?\n                 if (newType.isAssignableFrom(oldType)) {\n                     // new type more generic, use old\n-                    return false;\n+                    return;\n                 }\n                 // new type more specific, use it\n             }\n@@ -341,7 +338,6 @@ public class CreatorCollector\n             _explicitCreators |= mask;\n         }\n         _creators[typeIndex] = _fixAccess(newOne);\n-        return true;\n     }\n \n     /*\n"}
{"identifier": "Closure-11", "buggy_code": "  /**\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   */\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (n.getJSType() != null && parent.isAssign()) {\n      return;\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }\n", "fixed_code": "  /**\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   */\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    if (childType.isDict()) {\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n      checkPropertyAccess(childType, property.getString(), t, n);\n    }\n    ensureTyped(t, n);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   */\n  private void visitGetProp(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex e428dfa..ae8a320 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1311,6 +1311,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n+    } else if (n.getJSType() != null && parent.isAssign()) {\n+      return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n"}
{"identifier": "Gson-8", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java\nindex 41e7cd15..49fdf7f6 100644\n--- a/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java\n+++ b/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java\n@@ -20,7 +20,6 @@ import java.io.ObjectInputStream;\n import java.io.ObjectStreamClass;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n \n /**\n  * Do sneaky things to allocate objects without invoking their constructors.\n@@ -46,7 +45,6 @@ public abstract class UnsafeAllocator {\n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public <T> T newInstance(Class<T> c) throws Exception {\n-          assertInstantiable(c);\n           return (T) allocateInstance.invoke(unsafe, c);\n         }\n       };\n@@ -70,7 +68,6 @@ public abstract class UnsafeAllocator {\n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public <T> T newInstance(Class<T> c) throws Exception {\n-          assertInstantiable(c);\n           return (T) newInstance.invoke(null, c, constructorId);\n         }\n       };\n@@ -90,7 +87,6 @@ public abstract class UnsafeAllocator {\n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public <T> T newInstance(Class<T> c) throws Exception {\n-          assertInstantiable(c);\n           return (T) newInstance.invoke(null, c, Object.class);\n         }\n       };\n@@ -111,13 +107,4 @@ public abstract class UnsafeAllocator {\n    * throw an {@link java.lang.UnsupportedOperationException}\n    * @param c instance of the class to be checked\n    */\n-  private static void assertInstantiable(Class<?> c) {\n-    int modifiers = c.getModifiers();\n-    if (Modifier.isInterface(modifiers)) {\n-      throw new UnsupportedOperationException(\"Interface can't be instantiated! Interface name: \" + c.getName());\n-    }\n-    if (Modifier.isAbstract(modifiers)) {\n-      throw new UnsupportedOperationException(\"Abstract class can't be instantiated! Class name: \" + c.getName());\n-    }\n-  }\n }\n"}
{"identifier": "Mockito-12", "buggy_code": "    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n                return (Class) actual;\n                //in case of nested generics we don't go deep\n        }\n        \n        return Object.class;\n    }\n", "fixed_code": "    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class) actual;\n            } else if (actual instanceof ParameterizedType) {\n                //in case of nested generics we don't go deep\n                return (Class) ((ParameterizedType) actual).getRawType();\n            }\n        }\n        \n        return Object.class;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/util/reflection/GenericMaster.java b/src/org/mockito/internal/util/reflection/GenericMaster.java\nindex 4df9f7a..64bf154 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n@@ -17,12 +17,8 @@ public class GenericMaster {\n         Type generic = field.getGenericType();\n         if (generic != null && generic instanceof ParameterizedType) {\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n-            if (actual instanceof Class) {\n                 return (Class) actual;\n-            } else if (actual instanceof ParameterizedType) {\n                 //in case of nested generics we don't go deep\n-                return (Class) ((ParameterizedType) actual).getRawType();\n-            }\n         }\n         \n         return Object.class;\n"}
{"identifier": "Lang-65", "buggy_code": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n\n        // truncate milliseconds\n\n        // truncate seconds\n\n        // truncate minutes\n\n        // reset time\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n", "fixed_code": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n            if (field == Calendar.SECOND) {\n                done = true;\n            }\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n            if (field == Calendar.MINUTE) {\n                done = true;\n            }\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/time/DateUtils.java b/src/java/org/apache/commons/lang/time/DateUtils.java\nindex 79c13f0..531e73f 100644\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -621,9 +621,6 @@ public class DateUtils {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n-        if (field == Calendar.MILLISECOND) {\n-            return;\n-        }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n@@ -631,39 +628,14 @@ public class DateUtils {\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n-        Date date = val.getTime();\n-        long time = date.getTime();\n-        boolean done = false;\n \n         // truncate milliseconds\n-        int millisecs = val.get(Calendar.MILLISECOND);\n-        if (!round || millisecs < 500) {\n-            time = time - millisecs;\n-            if (field == Calendar.SECOND) {\n-                done = true;\n-            }\n-        }\n \n         // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-            if (field == Calendar.MINUTE) {\n-                done = true;\n-            }\n-        }\n \n         // truncate minutes\n-        int minutes = val.get(Calendar.MINUTE);\n-        if (!done && (!round || minutes < 30)) {\n-            time = time - (minutes * 60000L);\n-        }\n \n         // reset time\n-        if (date.getTime() != time) {\n-            date.setTime(time);\n-            val.setTime(date);\n-        }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n@@ -734,9 +706,7 @@ public class DateUtils {\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n-            if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n-            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n"}
{"identifier": "Compress-41", "buggy_code": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }\n", "fixed_code": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic ZipArchiveEntry getNextZipEntry() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\nindex 51b19304..5d4c0a82 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n@@ -244,10 +244,9 @@ public ZipArchiveEntry getNextZipEntry() throws IOException {\n         if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n             hitCentralDirectory = true;\n             skipRemainderOfArchive();\n-            return null;\n         }\n         if (!sig.equals(ZipLong.LFH_SIG)) {\n-            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n+            return null;\n         }\n \n         int off = WORD;\n"}
{"identifier": "Closure-166", "buggy_code": "  @Override\n  public void matchConstraint(JSType constraint) {\n    // We only want to match constraints on anonymous types.\n    if (hasReferenceName()) {\n      return;\n    }\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraint {{prop: (number|undefined)}}\n    // function f(constraint) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraint.isRecordType()) {\n      matchRecordTypeConstraint(constraint.toObjectType());\n    }\n  }\n", "fixed_code": "  @Override\n  public void matchConstraint(JSType constraint) {\n    // We only want to match constraints on anonymous types.\n    if (hasReferenceName()) {\n      return;\n    }\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraint {{prop: (number|undefined)}}\n    // function f(constraint) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraint.isRecordType()) {\n      matchRecordTypeConstraint(constraint.toObjectType());\n    } else if (constraint.isUnionType()) {\n      for (JSType alt : constraint.toMaybeUnionType().getAlternates()) {\n        if (alt.isRecordType()) {\n          matchRecordTypeConstraint(alt.toObjectType());\n        }\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public void matchConstraint(JSType constraint)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex 41cddd55d..3df8216d2 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -570,12 +570,6 @@ class PrototypeObjectType extends ObjectType {\n     // properties on this object.\n     if (constraint.isRecordType()) {\n       matchRecordTypeConstraint(constraint.toObjectType());\n-    } else if (constraint.isUnionType()) {\n-      for (JSType alt : constraint.toMaybeUnionType().getAlternates()) {\n-        if (alt.isRecordType()) {\n-          matchRecordTypeConstraint(alt.toObjectType());\n-        }\n-      }\n     }\n   }\n \n"}
{"identifier": "Math-99", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex 806c888..d51ec7a 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -540,11 +540,6 @@ public final class MathUtils {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n-                throw MathRuntimeException.createArithmeticException(\n-                        \"overflow: gcd({0}, {1}) is 2^31\",\n-                        new Object[] { p, q });\n-            }\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n@@ -716,9 +711,6 @@ public final class MathUtils {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n-        if (lcm == Integer.MIN_VALUE){\n-            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n-        }\n         return lcm;\n     }\n \n"}
{"identifier": "Time-15", "buggy_code": "    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n", "fixed_code": "    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/field/FieldUtils.java b/src/main/java/org/joda/time/field/FieldUtils.java\nindex 1e045b2..a0fe7e2 100644\n--- a/src/main/java/org/joda/time/field/FieldUtils.java\n+++ b/src/main/java/org/joda/time/field/FieldUtils.java\n@@ -135,9 +135,6 @@ public class FieldUtils {\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n-                if (val1 == Long.MIN_VALUE) {\n-                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n-                }\n                 return -val1;\n             case 0:\n                 return 0L;\n"}
{"identifier": "Jsoup-68", "buggy_code": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        int bottom = stack.size() -1;\n        if (bottom > MaxScopeSearchDepth) {\n            bottom = MaxScopeSearchDepth;\n        }\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).nodeName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n        return false;\n    }\n", "fixed_code": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).nodeName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex b8cc1f0..08444ef 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -465,7 +465,10 @@ public class HtmlTreeBuilder extends TreeBuilder {\n \n     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n         // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n-        final int bottom = stack.size() -1;\n+        int bottom = stack.size() -1;\n+        if (bottom > MaxScopeSearchDepth) {\n+            bottom = MaxScopeSearchDepth;\n+        }\n         final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n         // don't walk too far up the tree\n \n"}
{"identifier": "Math-104", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex ba2c4db..8c565cb 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -34,7 +34,7 @@ public class Gamma implements Serializable {\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-15;\n+    private static final double DEFAULT_EPSILON = 10e-9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n"}
{"identifier": "Mockito-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex 3b3795b..a3a7c08 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -124,12 +124,10 @@ public class InvocationMatcher implements DescribedInvocation, CapturesArgumensF\n                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                 }\n             }\n-            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {\n+            for (int position = indexOfVararg; position < matchers.size(); position++) {\n+                Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n-                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];\n-                    for (int i = 0; i < Array.getLength(rawArgument); i++) {\n-                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));\n-                    }\n+                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                 }\n             }\n         } else {\n@@ -142,18 +140,6 @@ public class InvocationMatcher implements DescribedInvocation, CapturesArgumensF\n         }\n     }\n \n-    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {\n-        HashSet<Matcher> set = new HashSet<Matcher>();\n-        for (int position = indexOfVararg; position < matchers.size(); position++) {\n-            Matcher matcher = matchers.get(position);\n-            if(matcher instanceof MatcherDecorator) {\n-                set.add(((MatcherDecorator) matcher).getActualMatcher());\n-            } else {\n-                set.add(matcher);\n-            }\n-        }\n-        return set;\n-    }\n \n     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n"}
{"identifier": "Mockito-34", "buggy_code": "    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n", "fixed_code": "    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic void captureArgumentsFrom(Invocation i)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex f15b9d4..c72b119 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -103,7 +103,7 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n+            if (m instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n"}
{"identifier": "JacksonXml-4", "buggy_code": "    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n    {\n        // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n        //    configured root name...\n        if (jgen instanceof ToXmlGenerator) {\n            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n        }\n        super.serializeValue(jgen, null);\n    }\n", "fixed_code": "    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n    {\n        // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n        //    configured root name...\n        QName rootName = _rootNameFromConfig();\n        if (rootName == null) {\n            rootName = ROOT_NAME_FOR_NULL;\n        }\n        if (jgen instanceof ToXmlGenerator) {\n            _initWithRootName((ToXmlGenerator) jgen, rootName);\n        }\n        super.serializeValue(jgen, null);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\nindex 40dd64d..327d149 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n@@ -201,12 +201,8 @@ public class XmlSerializerProvider extends DefaultSerializerProvider\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n-        QName rootName = _rootNameFromConfig();\n-        if (rootName == null) {\n-            rootName = ROOT_NAME_FOR_NULL;\n-        }\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, rootName);\n+            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n"}
{"identifier": "JacksonCore-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex 98b56302..12af5fb0 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -949,9 +949,6 @@ public final class ReaderBasedJsonParser\n             --ptr; // need to push back following separator\n             _inputPtr = ptr;\n             // As per #105, need separating space between root values; check here\n-            if (_parsingContext.inRoot()) {\n-                _verifyRootSpace(ch);\n-            }\n             int len = ptr-startPtr;\n             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n             return reset(negative, intLen, fractLen, expLen);\n@@ -1081,9 +1078,6 @@ public final class ReaderBasedJsonParser\n         // Ok; unless we hit end-of-input, need to push last char read back\n         if (!eof) {\n             --_inputPtr;\n-            if (_parsingContext.inRoot()) {\n-                _verifyRootSpace(c);\n-            }\n         }\n         _textBuffer.setCurrentLength(outPtr);\n         // And there we have it!\n@@ -1165,24 +1159,7 @@ public final class ReaderBasedJsonParser\n      * NOTE: caller MUST ensure there is at least one character available;\n      * and that input pointer is AT given char (not past)\n      */\n-    private final void _verifyRootSpace(int ch) throws IOException\n-    {\n         // caller had pushed it back, before calling; reset\n-        ++_inputPtr;\n-        switch (ch) {\n-        case ' ':\n-        case '\\t':\n-            return;\n-        case '\\r':\n-            _skipCR();\n-            return;\n-        case '\\n':\n-            ++_currInputRow;\n-            _currInputRowStart = _inputPtr;\n-            return;\n-        }\n-        _reportMissingRootWS(ch);\n-    }\n     \n     /*\n     /**********************************************************\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\nindex 83ae5b7a..15faeb8b 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n@@ -1241,9 +1241,6 @@ public final class UTF8StreamJsonParser\n         --_inputPtr; // to push back trailing char (comma etc)\n         _textBuffer.setCurrentLength(outPtr);\n         // As per #105, need separating space between root values; check here\n-        if (_parsingContext.inRoot()) {\n-            _verifyRootSpace(c);\n-        }\n \n         // And there we have it!\n         return resetInt(negative, intLen);\n@@ -1280,9 +1277,6 @@ public final class UTF8StreamJsonParser\n         --_inputPtr; // to push back trailing char (comma etc)\n         _textBuffer.setCurrentLength(outPtr);\n         // As per #105, need separating space between root values; check here\n-        if (_parsingContext.inRoot()) {\n-            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n-        }\n \n         // And there we have it!\n         return resetInt(negative, intPartLength);\n@@ -1410,9 +1404,6 @@ public final class UTF8StreamJsonParser\n         if (!eof) {\n             --_inputPtr;\n             // As per #105, need separating space between root values; check here\n-            if (_parsingContext.inRoot()) {\n-                _verifyRootSpace(c);\n-            }\n         }\n         _textBuffer.setCurrentLength(outPtr);\n \n@@ -1427,25 +1418,8 @@ public final class UTF8StreamJsonParser\n      * NOTE: caller MUST ensure there is at least one character available;\n      * and that input pointer is AT given char (not past)\n      */\n-    private final void _verifyRootSpace(int ch) throws IOException\n-    {\n         // caller had pushed it back, before calling; reset\n-        ++_inputPtr;\n         // TODO? Handle UTF-8 char decoding for error reporting\n-        switch (ch) {\n-        case ' ':\n-        case '\\t':\n-            return;\n-        case '\\r':\n-            _skipCR();\n-            return;\n-        case '\\n':\n-            ++_currInputRow;\n-            _currInputRowStart = _inputPtr;\n-            return;\n-        }\n-        _reportMissingRootWS(ch);\n-    }\n \n     /*\n     /**********************************************************\n@@ -2598,6 +2572,9 @@ public final class UTF8StreamJsonParser\n                 }\n                 break;\n             default: // e.g. -1\n+                if (i < 32) {\n+                    _throwInvalidSpace(i);\n+                }\n                 _reportInvalidChar(i);\n             }\n         }\n"}
{"identifier": "JacksonDatabind-83", "buggy_code": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value.\n                if (_deserialize(text, ctxt) != null) {\n                return _deserialize(text, ctxt);\n                }\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            } catch (MalformedURLException me) {\n                cause = me;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            // nothing to do here, yet? We'll fail anyway\n        }\n        JsonToken t = p.getCurrentToken();\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n", "fixed_code": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value.\n                return _deserialize(text, ctxt);\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            } catch (MalformedURLException me) {\n                cause = me;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            // nothing to do here, yet? We'll fail anyway\n        }\n        JsonToken t = p.getCurrentToken();\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex 0d01e780a..4f4eb672a 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -116,7 +116,9 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n+                if (_deserialize(text, ctxt) != null) {\n                 return _deserialize(text, ctxt);\n+                }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n"}
{"identifier": "Lang-60", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..c7cbfb3 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1670,7 +1670,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n-        for (int i = 0; i < this.size; i++) {\n+        for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }\n@@ -1727,7 +1727,7 @@ public class StrBuilder implements Cloneable {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        for (int i = startIndex; i < size; i++) {\n+        for (int i = startIndex; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }\n"}
{"identifier": "Jsoup-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 786b1bf..1b52a79 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -35,7 +35,7 @@ public class Entities {\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");\n+    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n"}
{"identifier": "JacksonDatabind-81", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\nindex 19f52c6c6..df4c2a770 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n@@ -761,9 +761,7 @@ public class JacksonAnnotationIntrospector\n                         type = tf.constructGeneralizedType(type, serClass);\n                     } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n                         type = tf.constructSpecializedType(type, serClass);\n-                    } else if (_primitiveAndWrapper(currRaw, serClass)) {\n                         // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                        type = type.withStaticTyping();\n                     } else {\n                         throw new JsonMappingException(null,\n                                 String.format(\"Can not refine serialization type %s into %s; types not related\",\n@@ -796,9 +794,7 @@ public class JacksonAnnotationIntrospector\n                             keyType = tf.constructGeneralizedType(keyType, keyClass);\n                         } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                             keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        } else if (_primitiveAndWrapper(currRaw, keyClass)) {\n                             // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                            keyType = keyType.withStaticTyping();\n                         } else {\n                             throw new JsonMappingException(null,\n                                     String.format(\"Can not refine serialization key type %s into %s; types not related\",\n@@ -832,9 +828,7 @@ public class JacksonAnnotationIntrospector\n                            contentType = tf.constructGeneralizedType(contentType, contentClass);\n                        } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                            contentType = tf.constructSpecializedType(contentType, contentClass);\n-                       } else if (_primitiveAndWrapper(currRaw, contentClass)) {\n                            // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                           contentType = contentType.withStaticTyping();\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization content type %s into %s; types not related\",\n@@ -1122,8 +1116,7 @@ public class JacksonAnnotationIntrospector\n         \n         // Ok: start by refining the main type itself; common to all types\n         final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n-        if ((valueClass != null) && !type.hasRawClass(valueClass)\n-                && !_primitiveAndWrapper(type, valueClass)) {\n+        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n             try {\n                 type = tf.constructSpecializedType(type, valueClass);\n             } catch (IllegalArgumentException iae) {\n@@ -1139,8 +1132,7 @@ public class JacksonAnnotationIntrospector\n         if (type.isMapLikeType()) {\n             JavaType keyType = type.getKeyType();\n             final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n-            if ((keyClass != null)\n-                    && !_primitiveAndWrapper(keyType, keyClass)) {\n+            if (keyClass != null) {\n                 try {\n                     keyType = tf.constructSpecializedType(keyType, keyClass);\n                     type = ((MapLikeType) type).withKeyType(keyType);\n@@ -1156,8 +1148,7 @@ public class JacksonAnnotationIntrospector\n         if (contentType != null) { // collection[like], map[like], array, reference\n             // And then value types for all containers:\n             final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n-            if ((contentClass != null)\n-                    && !_primitiveAndWrapper(contentType, contentClass)) {\n+            if (contentClass != null) {\n                 try {\n                     contentType = tf.constructSpecializedType(contentType, contentClass);\n                     type = type.withContentType(contentType);\n@@ -1463,25 +1454,5 @@ public class JacksonAnnotationIntrospector\n         return StdTypeResolverBuilder.noTypeInfoBuilder();\n     }\n \n-    private boolean _primitiveAndWrapper(Class<?> baseType, Class<?> refinement)\n-    {\n-        if (baseType.isPrimitive()) {\n-            return baseType == ClassUtil.primitiveType(refinement);\n-        }\n-        if (refinement.isPrimitive()) {\n-            return refinement == ClassUtil.primitiveType(baseType);\n-        }\n-        return false;\n-    }\n \n-    private boolean _primitiveAndWrapper(JavaType baseType, Class<?> refinement)\n-    {\n-        if (baseType.isPrimitive()) {\n-            return baseType.hasRawClass(ClassUtil.primitiveType(refinement));\n-        }\n-        if (refinement.isPrimitive()) {\n-            return refinement == ClassUtil.primitiveType(baseType.getRawClass());\n-        }\n-        return false;\n-    }\n }\n"}
{"identifier": "Compress-47", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\nindex 41e6940b..dd845b83 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n@@ -412,8 +412,7 @@ public boolean canReadEntryData(final ArchiveEntry ae) {\n         if (ae instanceof ZipArchiveEntry) {\n             final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n             return ZipUtil.canHandleEntryData(ze)\n-                && supportsDataDescriptorFor(ze)\n-                && supportsCompressedSizeFor(ze);\n+                && supportsDataDescriptorFor(ze);\n         }\n         return false;\n     }\n@@ -438,10 +437,6 @@ public int read(final byte[] buffer, final int offset, final int length) throws\n             throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                     current.entry);\n         }\n-        if (!supportsCompressedSizeFor(current.entry)) {\n-            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE,\n-                    current.entry);\n-        }\n \n         int read;\n         if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n@@ -811,14 +806,6 @@ private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n      * Whether the compressed size for the entry is either known or\n      * not required by the compression method being used.\n      */\n-    private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {\n-        return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN\n-            || entry.getMethod() == ZipEntry.DEFLATED\n-            || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n-            || (entry.getGeneralPurposeBit().usesDataDescriptor()\n-                && allowStoredEntriesWithDataDescriptor\n-                && entry.getMethod() == ZipEntry.STORED);\n-    }\n \n     /**\n      * Caches a stored entry that uses the data descriptor.\n"}
{"identifier": "Closure-12", "buggy_code": "  private boolean hasExceptionHandler(Node cfgNode) {\n    return false;\n  }\n", "fixed_code": "  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate boolean hasExceptionHandler(Node cfgNode)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\nindex 8361ac9..add5c66 100644\n--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n@@ -157,12 +157,6 @@ class MaybeReachingVariableUse extends\n   }\n \n   private boolean hasExceptionHandler(Node cfgNode) {\n-    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n-    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n-      if (edge.getValue() == Branch.ON_EX) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n \n"}
{"identifier": "Closure-39", "buggy_code": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n\n        ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return \"{...}\";\n    }\n  }\n", "fixed_code": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n\n        ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  String toStringHelper(boolean forAnnotations)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex f4b537d..dffe3a5 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -377,10 +377,10 @@ class PrototypeObjectType extends ObjectType {\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n+        sb.append(getPropertyType(property).toString());\n \n         ++i;\n-        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n+        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }\n@@ -391,7 +391,7 @@ class PrototypeObjectType extends ObjectType {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n-      return forAnnotations ? \"?\" : \"{...}\";\n+      return \"{...}\";\n     }\n   }\n \n"}
{"identifier": "Closure-55", "buggy_code": "  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n);\n  }\n", "fixed_code": "  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n)\n        && !NodeUtil.isGetOrSetKey(n.getParent());\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate static boolean isReduceableFunctionExpression(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionRewriter.java b/src/com/google/javascript/jscomp/FunctionRewriter.java\nindex 9d8ebc3..dbf0006 100644\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n@@ -114,8 +114,7 @@ class FunctionRewriter implements CompilerPass {\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n)\n-        && !NodeUtil.isGetOrSetKey(n.getParent());\n+    return NodeUtil.isFunctionExpression(n);\n   }\n \n   /**\n"}
{"identifier": "Chart-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/data/general/DatasetUtilities.java b/source/org/jfree/data/general/DatasetUtilities.java\nindex 548d684..927cbad 100644\n--- a/source/org/jfree/data/general/DatasetUtilities.java\n+++ b/source/org/jfree/data/general/DatasetUtilities.java\n@@ -752,19 +752,12 @@ public final class DatasetUtilities {\n             for (int series = 0; series < seriesCount; series++) {\n                 int itemCount = dataset.getItemCount(series);\n                 for (int item = 0; item < itemCount; item++) {\n-                    double value = intervalXYData.getXValue(series, item);\n                     lvalue = intervalXYData.getStartXValue(series, item);\n                     uvalue = intervalXYData.getEndXValue(series, item);\n-                    if (!Double.isNaN(value)) {\n-                        minimum = Math.min(minimum, value);\n-                        maximum = Math.max(maximum, value);\n-                    }\n                     if (!Double.isNaN(lvalue)) {\n                         minimum = Math.min(minimum, lvalue);\n-                        maximum = Math.max(maximum, lvalue);\n                     }\n                     if (!Double.isNaN(uvalue)) {\n-                        minimum = Math.min(minimum, uvalue);\n                         maximum = Math.max(maximum, uvalue);\n                     }\n                 }\n@@ -1246,19 +1239,12 @@ public final class DatasetUtilities {\n             for (int series = 0; series < seriesCount; series++) {\n                 int itemCount = dataset.getItemCount(series);\n                 for (int item = 0; item < itemCount; item++) {\n-                    double value = ixyd.getYValue(series, item);\n                     double lvalue = ixyd.getStartYValue(series, item);\n                     double uvalue = ixyd.getEndYValue(series, item);\n-                    if (!Double.isNaN(value)) {\n-                        minimum = Math.min(minimum, value);\n-                        maximum = Math.max(maximum, value);\n-                    }\n                     if (!Double.isNaN(lvalue)) {\n                         minimum = Math.min(minimum, lvalue);\n-                        maximum = Math.max(maximum, lvalue);\n                     }\n                     if (!Double.isNaN(uvalue)) {\n-                        minimum = Math.min(minimum, uvalue);\n                         maximum = Math.max(maximum, uvalue);\n                     }\n                 }\n"}
{"identifier": "Math-79", "buggy_code": "    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n", "fixed_code": "    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(int[] p1, int[] p2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex ad77a56..46368dc 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      double sum = 0;\n+      int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final double dp = p1[i] - p2[i];\n+          final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n"}
{"identifier": "Gson-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\nindex 67394531..c2372c79 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n@@ -76,11 +76,7 @@ public final class $Gson$Types {\n    */\n   public static WildcardType subtypeOf(Type bound) {\n     Type[] upperBounds;\n-    if (bound instanceof WildcardType) {\n-      upperBounds = ((WildcardType) bound).getUpperBounds();\n-    } else {\n       upperBounds = new Type[] { bound };\n-    }\n     return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n   }\n \n@@ -91,11 +87,7 @@ public final class $Gson$Types {\n    */\n   public static WildcardType supertypeOf(Type bound) {\n     Type[] lowerBounds;\n-    if (bound instanceof WildcardType) {\n-      lowerBounds = ((WildcardType) bound).getLowerBounds();\n-    } else {\n       lowerBounds = new Type[] { bound };\n-    }\n     return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n   }\n \n"}
{"identifier": "JacksonDatabind-86", "buggy_code": "", "fixed_code": "    @Override\n    public JavaType getSuperClass() {\n    \tif (_referencedType != null) {\n    \t\treturn _referencedType.getSuperClass();\n    \t}\n    \treturn super.getSuperClass();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\nindex 12162c57f..30807836d 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java\n@@ -26,13 +26,6 @@ public class ResolvedRecursiveType extends TypeBase\n         _referencedType = ref;\n     }\n    \n-    @Override\n-    public JavaType getSuperClass() {\n-    \tif (_referencedType != null) {\n-    \t\treturn _referencedType.getSuperClass();\n-    \t}\n-    \treturn super.getSuperClass();\n-    }\n \n     public JavaType getSelfReferencedType() { return _referencedType; }\n \n"}
{"identifier": "JacksonDatabind-41", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\nindex bedf749db..6c43863fc 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n@@ -599,9 +599,7 @@ public final class TypeFactory\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        TypeBindings bindings = (contextClass == null)\n-                ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings();\n-        return _fromAny(null, type, bindings);\n+        return constructType(type, constructType(contextClass));\n     }\n \n     /**\n@@ -609,9 +607,7 @@ public final class TypeFactory\n      */\n     @Deprecated\n     public JavaType constructType(Type type, JavaType contextType) {\n-        TypeBindings bindings = (contextType == null)\n-                ? TypeBindings.emptyBindings() : contextType.getBindings();\n-        return _fromAny(null, type, bindings);\n+        return _fromAny(null, type, contextType.getBindings());\n     }\n \n     /*\n"}
{"identifier": "JacksonDatabind-109", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\nindex 56b30737f..dc4906ebf 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n@@ -34,7 +34,6 @@ public class NumberSerializer\n     /**\n      * Copied from `jackson-core` class `GeneratorBase`\n      */\n-    protected final static int MAX_BIG_DECIMAL_SCALE = 9999;\n     \n     protected final boolean _isInt;\n \n@@ -56,9 +55,6 @@ public class NumberSerializer\n             switch (format.getShape()) {\n             case STRING:\n                 // [databind#2264]: Need special handling for `BigDecimal`\n-                if (((Class<?>) handledType()) == BigDecimal.class) {\n-                    return bigDecimalAsStringSerializer();\n-                }\n                 return ToStringSerializer.instance;\n             default:\n             }\n@@ -114,57 +110,14 @@ public class NumberSerializer\n     /**\n      * @since 2.10\n      */\n-    public static JsonSerializer<?> bigDecimalAsStringSerializer() {\n-        return BigDecimalAsStringSerializer.BD_INSTANCE;\n-    }\n     \n-    final static class BigDecimalAsStringSerializer\n-        extends ToStringSerializerBase\n-    {\n-        final static BigDecimalAsStringSerializer BD_INSTANCE = new BigDecimalAsStringSerializer();\n-        \n-        public BigDecimalAsStringSerializer() {\n-            super(BigDecimal.class);\n-        }\n \n-        @Override\n-        public boolean isEmpty(SerializerProvider prov, Object value) {\n-            return valueToString(value).isEmpty();\n-        }\n \n-        @Override\n-        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider)\n-            throws IOException\n-        {\n-            final String text;\n-            if (gen.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-                final BigDecimal bd = (BigDecimal) value;\n                 // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this\n-                if (!_verifyBigDecimalRange(gen, bd)) {\n                     // ... but wouldn't it be nice to trigger error via generator? Alas,\n                     // no method to do that. So we'll do...\n-                    final String errorMsg = String.format(\n-                            \"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\",\n-                            bd.scale(), MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE);\n-                    provider.reportMappingProblem(errorMsg);\n-                }\n-                text = bd.toPlainString();\n-            } else {\n-                text = value.toString();\n-            }\n-            gen.writeString(text);\n-        }\n \n-        @Override\n-        public String valueToString(Object value) {\n             // should never be called\n-            throw new IllegalStateException();\n-        }\n \n         // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this\n-        protected boolean _verifyBigDecimalRange(JsonGenerator gen, BigDecimal value) throws IOException {\n-            int scale = value.scale();\n-            return ((scale >= -MAX_BIG_DECIMAL_SCALE) && (scale <= MAX_BIG_DECIMAL_SCALE));\n-        }\n-    }\n }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\nindex 8fd2b875f..8af633d5b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n@@ -2,7 +2,6 @@ package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n@@ -98,9 +97,6 @@ public class NumberSerializers {\n             if (format != null) {\n                 switch (format.getShape()) {\n                 case STRING:\n-                    if (((Class<?>) handledType()) == BigDecimal.class) {\n-                        return NumberSerializer.bigDecimalAsStringSerializer();\n-                    }\n                     return ToStringSerializer.instance;\n                 default:\n                 }\n"}
{"identifier": "Lang-55", "buggy_code": "    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n            stopTime = System.currentTimeMillis();\n        this.runningState = STATE_STOPPED;\n    }\n", "fixed_code": "    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if(this.runningState == STATE_RUNNING) {\n            stopTime = System.currentTimeMillis();\n        }\n        this.runningState = STATE_STOPPED;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/time/StopWatch.java b/src/java/org/apache/commons/lang/time/StopWatch.java\nindex 0f0786a..8f39421 100644\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -115,9 +115,7 @@ public class StopWatch {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n-        if(this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n-        }\n         this.runningState = STATE_STOPPED;\n     }\n \n"}
{"identifier": "Chart-13", "buggy_code": "    /**\n     * Arranges the items within a container.\n     *\n     * @param container  the container.\n     * @param constraint  the constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }\n", "fixed_code": "    /**\n     * Arranges the items within a container.\n     *\n     * @param container  the container.\n     * @param constraint  the constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Arranges the items within a container.\n     *\n     * @param container  the container.\n     * @param constraint  the constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex b3ae54b..730aeb3 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n+                    new Range(0.0, constraint.getWidth() - w[2]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n"}
{"identifier": "Mockito-21", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java b/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\nindex 9f0201a..0cc8226 100644\n--- a/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\n+++ b/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\n@@ -14,23 +14,18 @@ public class ConstructorInstantiator implements Instantiator {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withParams(cls, outerClassInstance);\n+        return withOuterClass(cls);\n     }\n \n-    private static <T> T withParams(Class<T> cls, Object... params) {\n+    private <T> T withOuterClass(Class<T> cls) {\n         try {\n             //this is kind of overengineered because we don't need to support more params\n             //however, I know we will be needing it :)\n-            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n-                Class<?>[] types = constructor.getParameterTypes();\n-                if (paramsMatch(types, params)) {\n-                    return (T) constructor.newInstance(params);\n-                }\n-            }\n+            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n+            return c.newInstance(outerClassInstance);\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n-        throw paramsException(cls, null);\n     }\n \n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n@@ -38,17 +33,6 @@ public class ConstructorInstantiator implements Instantiator {\n                 + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n     }\n \n-    private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n-        if (params.length != types.length) {\n-            return false;\n-        }\n-        for (int i = 0; i < params.length; i++) {\n-            if (!types[i].isInstance(params[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n \n     private static <T> T noArgConstructor(Class<T> cls) {\n         try {\n"}
{"identifier": "Compress-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\nindex 76e28666..acfe3279 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java\n@@ -39,12 +39,10 @@ public class ArArchiveInputStream extends ArchiveInputStream {\n      * If getNextEnxtry has been called, the entry metadata is stored in\n      * currentEntry.\n      */\n-    private ArArchiveEntry currentEntry = null;\n     /*\n      * The offset where the current entry started. -1 if no entry has been\n      * called\n      */\n-    private long entryOffset = -1;\n \n     public ArArchiveInputStream( final InputStream pInput ) {\n         input = pInput;\n@@ -59,18 +57,8 @@ public class ArArchiveInputStream extends ArchiveInputStream {\n      *             if the entry could not be read\n      */\n     public ArArchiveEntry getNextArEntry() throws IOException {\n-        if (currentEntry != null) {\n-            final long entryEnd = entryOffset + currentEntry.getLength();\n-            while (offset < entryEnd) {\n-                int x = read();\n-                if (x == -1) {\n                     // hit EOF before previous entry was complete\n                     // TODO: throw an exception instead?\n-                    return null;\n-                }\n-            }\n-            currentEntry = null;\n-        }\n \n         if (offset == 0) {\n             final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n@@ -86,17 +74,15 @@ public class ArArchiveInputStream extends ArchiveInputStream {\n             }\n         }\n \n-        if (offset % 2 != 0) {\n-            if (read() < 0) {\n                 // hit eof\n-                return null;\n-            }\n-        }\n \n         if (input.available() == 0) {\n             return null;\n         }\n \n+        if (offset % 2 != 0) {\n+            read();\n+        }\n         final byte[] name = new byte[16];\n         final byte[] lastmodified = new byte[12];\n         final byte[] userid = new byte[6];\n@@ -125,11 +111,9 @@ public class ArArchiveInputStream extends ArchiveInputStream {\n             }\n         }\n \n-        entryOffset = offset;\n-        currentEntry = new ArArchiveEntry(new String(name).trim(),\n+        return new ArArchiveEntry(new String(name).trim(),\n                                           Long.parseLong(new String(length)\n                                                          .trim()));\n-        return currentEntry;\n     }\n \n \n@@ -142,13 +126,12 @@ public class ArArchiveInputStream extends ArchiveInputStream {\n             closed = true;\n             input.close();\n         }\n-        currentEntry = null;\n     }\n \n     public int read() throws IOException {\n-        byte[] single = new byte[1];\n-        int num = read(single, 0, 1);\n-        return num == -1 ? -1 : single[0] & 0xff;\n+        final int ret = input.read();\n+        offset += (ret > 0 ? 1 : 0);\n+        return ret;\n     }\n \n     public int read(byte[] b) throws IOException {\n@@ -157,14 +140,6 @@ public class ArArchiveInputStream extends ArchiveInputStream {\n \n     public int read(byte[] b, final int off, final int len) throws IOException {\n         int toRead = len;\n-        if (currentEntry != null) {\n-            final long entryEnd = entryOffset + currentEntry.getLength();\n-            if (len > 0 && entryEnd > offset) {\n-                toRead = (int) Math.min(len, entryEnd - offset);\n-            } else {\n-                return -1;\n-            }\n-        }\n         final int ret = this.input.read(b, off, toRead);\n         offset += (ret > 0 ? ret : 0);\n         return ret;\n"}
{"identifier": "Math-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\nindex aa3299a..b8225ad 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n@@ -40,7 +40,10 @@ public class Weight implements OptimizationData {\n      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n-        weightMatrix = new DiagonalMatrix(weight);\n+        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n+        for (int i = 0; i < dim; i++) {\n+            weightMatrix.setEntry(i, i, weight[i]);\n+        }\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\nindex ef52943..d12ebea 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n@@ -264,16 +264,7 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n-        if (m instanceof DiagonalMatrix) {\n-            final int dim = m.getRowDimension();\n-            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n-            for (int i = 0; i < dim; i++) {\n-                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n-            }\n-            return sqrtM;\n-        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n-        }\n     }\n }\n"}
{"identifier": "Codec-17", "buggy_code": "    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n", "fixed_code": "    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex 7bb15e33..5b14ca0c 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -336,7 +336,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return newString(bytes, Charsets.ISO_8859_1);\n+        return new String(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**\n"}
{"identifier": "JacksonDatabind-100", "buggy_code": "    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        // Multiple possibilities...\n        JsonNode n = currentNode();\n        if (n != null) {\n            // [databind#2096]: although `binaryValue()` works for real binary node\n            // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n            byte[] data = n.binaryValue();\n            if (data != null) {\n                return data;\n            }\n            if (n.isPojo()) {\n                Object ob = ((POJONode) n).getPojo();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n            }\n        }\n        // otherwise return null to mark we have no binary content\n        return null;\n    }\n", "fixed_code": "    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        // Multiple possibilities...\n        JsonNode n = currentNode();\n        if (n != null) {\n            // [databind#2096]: although `binaryValue()` works for real binary node\n            // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n            if (n instanceof TextNode) {\n                return ((TextNode) n).getBinaryValue(b64variant);\n            }\n            return n.binaryValue();\n        }\n        // otherwise return null to mark we have no binary content\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\nindex 40bf3d343..9d2f74b35 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n@@ -360,10 +360,16 @@ public class TreeTraversingParser extends ParserMinimalBase\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            if (n instanceof TextNode) {\n-                return ((TextNode) n).getBinaryValue(b64variant);\n+            byte[] data = n.binaryValue();\n+            if (data != null) {\n+                return data;\n+            }\n+            if (n.isPojo()) {\n+                Object ob = ((POJONode) n).getPojo();\n+                if (ob instanceof byte[]) {\n+                    return (byte[]) ob;\n+                }\n             }\n-            return n.binaryValue();\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n"}
{"identifier": "Cli-22", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex ca8b6c6..47ad0f7 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -38,7 +38,6 @@ public class PosixParser extends Parser\n     private boolean eatTheRest;\n \n     /** holder for the current option */\n-    private Option currentOption;\n \n     /** the command line Options */\n     private Options options;\n@@ -114,11 +113,10 @@ public class PosixParser extends Parser\n \n                 if (!options.hasOption(opt))\n                 {\n-                    processNonOptionToken(token, stopAtNonOption);\n+                    processNonOptionToken(token);\n                 }\n                 else\n                 {\n-                    currentOption = options.getOption(opt);\n                     \n                     tokens.add(opt);\n                     if (pos != -1)\n@@ -145,9 +143,13 @@ public class PosixParser extends Parser\n                     burstToken(token, stopAtNonOption);\n                 }\n             }\n+            else if (stopAtNonOption)\n+            {\n+                processNonOptionToken(token);\n+            }\n             else\n             {\n-                processNonOptionToken(token, stopAtNonOption);\n+                tokens.add(token);\n             }\n \n             gobble(iter);\n@@ -179,13 +181,10 @@ public class PosixParser extends Parser\n      *\n      * @param value The current token\n      */\n-    private void processNonOptionToken(String value, boolean stopAtNonOption)\n+    private void processNonOptionToken(String value)\n     {\n-        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n-        {\n             eatTheRest = true;\n             tokens.add(\"--\");\n-        }\n \n         tokens.add(value);\n     }\n@@ -209,10 +208,6 @@ public class PosixParser extends Parser\n             eatTheRest = true;\n         }\n \n-        if (options.hasOption(token))\n-        {\n-            currentOption = options.getOption(token);\n-        }\n \n         tokens.add(token);\n     }\n@@ -245,6 +240,7 @@ public class PosixParser extends Parser\n      */\n     protected void burstToken(String token, boolean stopAtNonOption)\n     {\n+        Option currentOption;\n         for (int i = 1; i < token.length(); i++)\n         {\n             String ch = String.valueOf(token.charAt(i));\n@@ -263,7 +259,7 @@ public class PosixParser extends Parser\n             }\n             else if (stopAtNonOption)\n             {\n-                processNonOptionToken(token.substring(i), true);\n+                processNonOptionToken(token.substring(i));\n                 break;\n             }\n             else\n"}
{"identifier": "Closure-27", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/rhino/IR.java b/src/com/google/javascript/rhino/IR.java\nindex 002acd6..081f01f 100644\n--- a/src/com/google/javascript/rhino/IR.java\n+++ b/src/com/google/javascript/rhino/IR.java\n@@ -108,9 +108,6 @@ public class IR {\n     return block;\n   }\n \n-  private static Node blockUnchecked(Node stmt) {\n-    return new Node(Token.BLOCK, stmt);\n-  }\n \n   public static Node script(Node ... stmts) {\n     // TODO(johnlenz): finish setting up the SCRIPT node\n@@ -224,8 +221,8 @@ public class IR {\n   }\n \n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n-    Preconditions.checkState(tryBody.isBlock());\n-    Preconditions.checkState(finallyBody.isBlock());\n+    Preconditions.checkState(tryBody.isLabelName());\n+    Preconditions.checkState(finallyBody.isLabelName());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }\n@@ -233,7 +230,7 @@ public class IR {\n   public static Node tryCatch(Node tryBody, Node catchNode) {\n     Preconditions.checkState(tryBody.isBlock());\n     Preconditions.checkState(catchNode.isCatch());\n-    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n+    Node catchBody = block(catchNode).copyInformationFrom(catchNode);\n     return new Node(Token.TRY, tryBody, catchBody);\n   }\n \n"}
{"identifier": "JxPath-10", "buggy_code": "    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n", "fixed_code": "    public final Object computeValue(EvalContext context) {\n        return compute(args[0].compute(context), args[1].compute(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic final Object computeValue(EvalContext context)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\nindex a09afa8..b968cd5 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n@@ -39,7 +39,7 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].compute(context), args[1].compute(context))\n+        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n"}
{"identifier": "JacksonDatabind-28", "buggy_code": "        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n", "fixed_code": "        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.hasToken(JsonToken.END_OBJECT)) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\nindex d5eb01709..264ed2051 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n@@ -94,13 +94,14 @@ public class JsonNodeDeserializer\n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) {\n+            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n+                p.nextToken();\n                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n             }\n             // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.hasToken(JsonToken.END_OBJECT)) {\n-                return ctxt.getNodeFactory().objectNode();\n+            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n+                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n"}
{"identifier": "Lang-6", "buggy_code": "    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pt));\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 0500460..4d010ea 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -92,7 +92,7 @@ public abstract class CharSequenceTranslator {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pt));\n+                pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }\n"}
{"identifier": "Time-8", "buggy_code": "    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < 0 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - minutesOffset;\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n", "fixed_code": "    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n     *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n     */\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a127604..7d1719b 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -276,17 +276,14 @@ public abstract class DateTimeZone implements Serializable {\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < -59 || minutesOffset > 59) {\n+        if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n-        if (hoursOffset > 0 && minutesOffset < 0) {\n-            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n-        }\n         int offset = 0;\n         try {\n             int hoursInMinutes = hoursOffset * 60;\n             if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n+                minutesOffset = hoursInMinutes - minutesOffset;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n"}
{"identifier": "Math-93", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex 1389d5a..7d8aa4d 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -342,10 +342,8 @@ public final class MathUtils {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n-        }\n-        if (n > 20) {\n+        long result = Math.round(factorialDouble(n));\n+        if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }\n@@ -376,9 +374,6 @@ public final class MathUtils {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n-        if (n < 21) {\n-            return factorial(n);\n-        }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n@@ -399,9 +394,6 @@ public final class MathUtils {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n-        if (n < 21) {\n-            return Math.log(factorial(n));\n-        }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);\n"}
{"identifier": "Math-76", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex e418c08..1436881 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -159,27 +159,24 @@ public class SingularValueDecompositionImpl implements SingularValueDecompositio\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p; ++i) {\n+                for (int i = 0; i < p - 1; ++i) {\n                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n-                    if (i < n - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                    } else {\n+                }\n                         for (int j = 0; j < p; ++j) {\n-                            wi[j] = mi * ei0[j] / singularValues[j];\n+                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                         }\n-                    }\n-                }\n \n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];\n@@ -248,26 +245,23 @@ public class SingularValueDecompositionImpl implements SingularValueDecompositio\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p; ++i) {\n+                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n-                    if (i < m - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                    } else {\n+                }\n                         for (int j = 0; j < p; ++j) {\n-                            wi[j] = mi * ei0[j] / singularValues[j];\n+                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                         }\n-                    }\n-                }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n                 }\n"}
{"identifier": "JacksonCore-15", "buggy_code": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \t\t//if not scalar and ended successfully, then return null\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n", "fixed_code": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \tif(!_allowMultipleMatches && _currToken != null && _exposedContext == null){\n    \t\t//if not scalar and ended successfully, then return null\n    \t\tif((_currToken.isStructEnd()  && _headContext.isStartHandled()) ){\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n    \t\telse if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath \n    \t\t\t\t&& _itemFilter == TokenFilter.INCLUDE_ALL) {\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t}\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public JsonToken nextToken() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\nindex bf68cd77..e2de6f85 100644\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n@@ -224,18 +224,9 @@ public class FilteringParserDelegate extends JsonParserDelegate\n     \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n     \t// check for no buffered context _exposedContext - null\n     \t//If all the conditions matches then check for scalar / non-scalar property\n-    \tif(!_allowMultipleMatches && _currToken != null && _exposedContext == null){\n     \t\t//if not scalar and ended successfully, then return null\n-    \t\tif((_currToken.isStructEnd()  && _headContext.isStartHandled()) ){\n-    \t\t\treturn (_currToken = null);\n-    \t\t}\n     \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n     \t\t// then return null \n-    \t\telse if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath \n-    \t\t\t\t&& _itemFilter == TokenFilter.INCLUDE_ALL) {\n-    \t\t\treturn (_currToken = null);\n-    \t\t}\n-    \t}\n         // Anything buffered?\n         TokenFilterContext ctxt = _exposedContext;\n \n"}
{"identifier": "Math-13", "buggy_code": "    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }\n", "fixed_code": "    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 982e559..99d86e9 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -559,16 +559,7 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n-        if (m instanceof DiagonalMatrix) {\n-            final int dim = m.getRowDimension();\n-            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n-            for (int i = 0; i < dim; i++) {\n-               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n-            }\n-            return sqrtM;\n-        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n-        }\n     }\n }\n"}
{"identifier": "Closure-153", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex c14ac8f..4c99858 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -628,7 +628,6 @@ class Normalize implements CompilerPass {\n   private final class DuplicateDeclarationHandler implements\n       SyntacticScopeCreator.RedeclarationHandler {\n \n-    private Set<Var> hasOkDuplicateDeclaration = Sets.newHashSet();\n \n     /**\n      * Remove duplicate VAR declarations encountered discovered during\n@@ -636,22 +635,15 @@ class Normalize implements CompilerPass {\n      */\n     @Override\n     public void onRedeclaration(\n-        Scope s, String name, Node n, CompilerInput input) {\n+        Scope s, String name, Node n, Node parent, Node gramps,\n+        Node nodeWithLineNumber) {\n       Preconditions.checkState(n.getType() == Token.NAME);\n-      Node parent = n.getParent();\n       Var v = s.getVar(name);\n \n-      if (v != null && s.isGlobal()) {\n         // We allow variables to be duplicate declared if one\n         // declaration appears in source and the other in externs.\n         // This deals with issues where a browser built-in is declared\n         // in one browser but not in another.\n-        if (v.isExtern() && !input.isExtern()) {\n-          if (hasOkDuplicateDeclaration.add(v)) {\n-            return;\n-          }\n-        }\n-      }\n \n       // If name is \"arguments\", Var maybe null.\n       if (v != null && v.getParentNode().getType() == Token.CATCH) {\n@@ -674,7 +666,7 @@ class Normalize implements CompilerPass {\n             name);\n         compiler.report(\n             JSError.make(\n-                input.getName(), n,\n+                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n                 CATCH_BLOCK_VAR_ERROR, name));\n       } else if (v != null && parent.getType() == Token.FUNCTION) {\n         if (v.getParentNode().getType() == Token.VAR) {\n@@ -686,7 +678,7 @@ class Normalize implements CompilerPass {\n       } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n \n-        replaceVarWithAssignment(n, parent, parent.getParent());\n+        replaceVarWithAssignment(n, parent, gramps);\n       }\n     }\n \ndiff --git a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\nindex eb6e1ea..9494792 100644\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n@@ -91,7 +91,7 @@ class SyntacticScopeCreator implements ScopeCreator {\n       // been declared in the outer scope.\n       String fnName = fnNameNode.getString();\n       if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n-        declareVar(fnNameNode);\n+        declareVar(fnName, fnNameNode, n, null, null, n);\n       }\n \n       // Args: Declare function variables\n@@ -99,7 +99,7 @@ class SyntacticScopeCreator implements ScopeCreator {\n       for (Node a = args.getFirstChild(); a != null;\n            a = a.getNext()) {\n         Preconditions.checkState(a.getType() == Token.NAME);\n-        declareVar(a);\n+        declareVar(a.getString(), a, args, n, null, n);\n       }\n \n       // Body\n@@ -121,7 +121,9 @@ class SyntacticScopeCreator implements ScopeCreator {\n         for (Node child = n.getFirstChild();\n              child != null;) {\n           Node next = child.getNext();\n-          declareVar(child);\n+          Preconditions.checkState(child.getType() == Token.NAME);\n+          String name = child.getString();\n+          declareVar(name, child, n, parent, null, n);\n           child = next;\n         }\n         return;\n@@ -136,7 +138,7 @@ class SyntacticScopeCreator implements ScopeCreator {\n           // This is invalid, but allow it so the checks can catch it.\n           return;\n         }\n-        declareVar(n.getFirstChild());\n+        declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n         return;   // should not examine function's children\n \n       case Token.CATCH:\n@@ -148,7 +150,7 @@ class SyntacticScopeCreator implements ScopeCreator {\n         final Node var = n.getFirstChild();\n         final Node block = var.getNext();\n \n-        declareVar(var);\n+        declareVar(var.getString(), var, n, parent, null, n);\n         scanVars(block, n);\n         return;  // only one child to scan\n \n@@ -174,7 +176,8 @@ class SyntacticScopeCreator implements ScopeCreator {\n    */\n   interface RedeclarationHandler {\n     void onRedeclaration(\n-        Scope s, String name, Node n, CompilerInput input);\n+        Scope s, String name,\n+        Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n   }\n \n   /**\n@@ -182,8 +185,8 @@ class SyntacticScopeCreator implements ScopeCreator {\n    */\n   private class DefaultRedeclarationHandler implements RedeclarationHandler {\n     public void onRedeclaration(\n-        Scope s, String name, Node n, CompilerInput input) {\n-      Node parent = n.getParent();\n+        Scope s, String name,\n+        Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n \n       // Don't allow multiple variables to be declared at the top level scope\n       if (scope.isGlobal()) {\n@@ -228,17 +231,16 @@ class SyntacticScopeCreator implements ScopeCreator {\n    * @param n The node corresponding to the variable name.\n    * @param declaredType The variable's type, according to JSDoc\n    */\n-  private void declareVar(Node n) {\n-    Preconditions.checkState(n.getType() == Token.NAME);\n+  private void declareVar(String name, Node n, Node parent,\n+                          Node gramps, com.google.javascript.rhino.jstype.JSType declaredType,\n+                          Node nodeWithLineNumber) {\n \n-    CompilerInput input = compiler.getInput(sourceName);\n-    String name = n.getString();\n     if (scope.isDeclared(name, false)\n         || (scope.isLocal() && name.equals(ARGUMENTS))) {\n       redeclarationHandler.onRedeclaration(\n-          scope, name, n, input);\n+          scope, name, n, parent, gramps, nodeWithLineNumber);\n     } else {\n-      scope.declare(name, n, null, input);\n+      scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n     }\n   }\n }\n"}
{"identifier": "Closure-30", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex 3f39c07..d53a8f8 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -154,7 +154,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n \n   @Override\n   public void process(Node externs, Node root) {\n-    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n+    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n \n   @Override\ndiff --git a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\nindex 589f673..1487af3 100644\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n@@ -68,7 +68,6 @@ final class MustBeReachingVariableDef extends\n   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n-    private boolean unknownDependencies = false;\n \n     Definition(Node node) {\n       this.node = node;\n@@ -394,13 +393,9 @@ final class MustBeReachingVariableDef extends\n         new AbstractCfgNodeTraversalCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (n.isName()) {\n+        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n           Var dep = jsScope.getVar(n.getString());\n-          if (dep == null) {\n-            def.unknownDependencies = true;\n-          } else {\n             def.depends.add(dep);\n-          }\n         }\n       }\n     });\n@@ -432,9 +427,6 @@ final class MustBeReachingVariableDef extends\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n-    if (def.unknownDependencies) {\n-      return true;\n-    }\n \n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {\n"}
{"identifier": "Codec-11", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\nindex ed09fecb..13291cd5 100644\n--- a/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n@@ -67,12 +67,9 @@ public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, Strin\n \n     private static final byte SPACE = 32;\n \n-    private static final byte CR = 13;\n \n-    private static final byte LF = 10;\n \n     /** Safe line length for quoted printable encoded text. */\n-    private static final int SAFE_LENGTH = 73;\n \n     // Static initializer for printable chars collection\n     static {\n@@ -114,13 +111,12 @@ public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, Strin\n      *            the buffer to write to\n      * @return The number of bytes written to the <code>buffer</code>\n      */\n-    private static final int encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n+    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n         buffer.write(ESCAPE_CHAR);\n         char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n         char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n         buffer.write(hex1);\n         buffer.write(hex2);\n-        return 3;\n     }\n \n     /**\n@@ -133,13 +129,6 @@ public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, Strin\n      *                  the byte array\n      * @return the unsigned octet at position <code>index</code> from the array\n      */\n-    private static int getUnsignedOctet(final int index, final byte[] bytes) {\n-        int b = bytes[index];\n-        if (b < 0) {\n-            b = 256 + b;\n-        }\n-        return b;\n-    }\n \n     /**\n      * Write a byte to the buffer.\n@@ -152,15 +141,6 @@ public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, Strin\n      *                  the buffer to write to\n      * @return the number of bytes that have been written to the buffer\n      */\n-    private static int encodeByte(final int b, final boolean encode,\n-                                  final ByteArrayOutputStream buffer) {\n-        if (encode) {\n-            return encodeQuotedPrintable(b, buffer);\n-        } else {\n-            buffer.write(b);\n-            return 1;\n-        }\n-    }\n \n     /**\n      * Checks whether the given byte is whitespace.\n@@ -169,9 +149,6 @@ public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, Strin\n      *                  byte to be checked\n      * @return <code>true</code> if the byte is either a space or tab character\n      */\n-    private static boolean isWhitespace(final int b) {\n-        return b == SPACE || b == TAB;\n-    }\n \n     /**\n      * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n@@ -195,46 +172,31 @@ public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, Strin\n             printable = PRINTABLE_CHARS;\n         }\n         ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        int pos = 1;\n         // encode up to buffer.length - 3, the last three octets will be treated\n         // separately for simplification of note #3\n-        for (int i = 0; i < bytes.length - 3; i++) {\n-            int b = getUnsignedOctet(i, bytes);\n-            if (pos < SAFE_LENGTH) {\n                 // up to this length it is safe to add any byte, encoded or not\n-                pos += encodeByte(b, !printable.get(b), buffer);\n+        for (byte c : bytes) {\n+            int b = c;\n+            if (b < 0) {\n+                b = 256 + b;\n+            }\n+            if (printable.get(b)) {\n+                buffer.write(b);\n             } else {\n                 // rule #3: whitespace at the end of a line *must* be encoded\n-                encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\n \n                 // rule #5: soft line break\n-                buffer.write(ESCAPE_CHAR);\n-                buffer.write(CR);\n-                buffer.write(LF);\n-                pos = 1;\n+                encodeQuotedPrintable(b, buffer);\n             }\n         }\n \n         // rule #3: whitespace at the end of a line *must* be encoded\n         // if we would do a soft break line after this octet, encode whitespace\n-        int b = getUnsignedOctet(bytes.length - 3, bytes);\n-        boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\n-        pos += encodeByte(b, encode, buffer);\n \n         // note #3: '=' *must not* be the ultimate or penultimate character\n         // simplification: if < 6 bytes left, do a soft line break as we may need\n         //                 exactly 6 bytes space for the last 2 bytes\n-        if (pos > SAFE_LENGTH - 2) {\n-            buffer.write(ESCAPE_CHAR);\n-            buffer.write(CR);\n-            buffer.write(LF);\n-        }\n-        for (int i = bytes.length - 2; i < bytes.length; i++) {\n-            b = getUnsignedOctet(i, bytes);\n             // rule #3: trailing whitespace shall be encoded\n-            encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\n-            encodeByte(b, encode, buffer);\n-        }\n \n         return buffer.toByteArray();\n     }\n@@ -264,16 +226,13 @@ public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, Strin\n             if (b == ESCAPE_CHAR) {\n                 try {\n                     // if the next octet is a CR we have found a soft line break\n-                    if (bytes[++i] == CR) {\n-                        continue;\n-                    }\n-                    int u = Utils.digit16(bytes[i]);\n+                    int u = Utils.digit16(bytes[++i]);\n                     int l = Utils.digit16(bytes[++i]);\n                     buffer.write((char) ((u << 4) + l));\n                 } catch (ArrayIndexOutOfBoundsException e) {\n                     throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                 }\n-            } else if (b != CR && b != LF) {\n+            } else {\n                 // every other octet is appended except for CR & LF\n                 buffer.write(b);\n             }\n"}
{"identifier": "Closure-127", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\nindex e6d88a8..d819874 100644\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n@@ -167,22 +167,13 @@ class UnreachableCodeElimination implements CompilerPass {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {\n+            if (nextCfgNode == fallThrough) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n \n-    private boolean inFinally(Node parent, Node child) {\n-      if (parent == null || parent.isFunction()) {\n-        return false;\n-      } else if (NodeUtil.isTryFinallyNode(parent, child)) {\n-        return true;\n-      } else {\n-        return inFinally(parent.getParent(), parent);\n-      }\n-    }\n \n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);\n"}
{"identifier": "Mockito-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\nindex 8fb0cae..747655e 100644\n--- a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n+++ b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n@@ -5,9 +5,7 @@\n package org.mockito.internal.stubbing.answers;\n \n import java.io.Serializable;\n-import java.lang.reflect.Modifier;\n \n-import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n@@ -35,9 +33,6 @@ public class CallsRealMethods implements Answer<Object>, Serializable {\n     private static final long serialVersionUID = 9057165148930624087L;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n-    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n-    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n-    \t}\n         return invocation.callRealMethod();\n     }\n }\n\\ No newline at end of file\n"}
{"identifier": "Jsoup-2", "buggy_code": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }\n", "fixed_code": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            popStackToClose(tag);\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void parseStartTag()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java\nindex e7284d5..da4bdce 100644\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n@@ -145,7 +145,6 @@ public class Parser {\n         if (tag.isData()) {\n             String data = tq.chompTo(\"</\" + tagName);\n             tq.chompTo(\">\");\n-            popStackToClose(tag);\n             \n             Node dataNode;\n             if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n"}
{"identifier": "Closure-175", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 659f39ab..9d3fdd39 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -43,14 +43,6 @@ class FunctionInjector {\n   private final boolean assumeStrictThis;\n   private final boolean assumeMinimumCapture;\n   private final Supplier<String> safeNameIdSupplier;\n-  private final Supplier<String> throwawayNameSupplier =\n-      new Supplier<String>() {\n-    private int nextId = 0;\n-    @Override\n-    public String get() {\n-      return String.valueOf(nextId++);\n-    }\n-  };\n \n   /**\n    * @param allowDecomposition Whether an effort should be made to break down\n@@ -213,7 +205,7 @@ class FunctionInjector {\n     }\n \n     if (mode == InliningMode.DIRECT) {\n-      return canInlineReferenceDirectly(callNode, fnNode, needAliases);\n+      return canInlineReferenceDirectly(callNode, fnNode);\n     } else {\n       return canInlineReferenceAsStatementBlock(\n           t, callNode, fnNode, needAliases);\n@@ -695,11 +687,12 @@ class FunctionInjector {\n    * </pre>\n    */\n   private CanInlineResult canInlineReferenceDirectly(\n-      Node callNode, Node fnNode, Set<String> namesToAlias) {\n+      Node callNode, Node fnNode) {\n     if (!isDirectCallNodeReplacementPossible(fnNode)) {\n       return CanInlineResult.NO;\n     }\n \n+    Node block = fnNode.getLastChild();\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n \n@@ -719,17 +712,24 @@ class FunctionInjector {\n       }\n     }\n \n-    Map<String, Node> args =\n-        FunctionArgumentInjector.getFunctionCallParameterMap(\n-            fnNode, callNode, this.throwawayNameSupplier);\n-    boolean hasArgs = !args.isEmpty();\n-    if (hasArgs) {\n+    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n+    while (cArg != null || fnParam != null) {\n+      if (fnParam != null) {\n+        if (cArg != null) {\n+          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n+              && NodeUtil.getNameReferenceCount(\n+                  block, fnParam.getString()) > 1) {\n+            return CanInlineResult.NO;\n+          }\n+        }\n+        fnParam = fnParam.getNext();\n+      }\n       // Limit the inlining\n-      Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n-      FunctionArgumentInjector.maybeAddTempsForCallArguments(\n-          fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n-      if (!allNamesToAlias.isEmpty()) {\n+      if (cArg != null) {\n+        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n         return CanInlineResult.NO;\n+        }\n+        cArg = cArg.getNext();\n       }\n     }\n \n"}
{"identifier": "Time-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/MutableDateTime.java b/src/main/java/org/joda/time/MutableDateTime.java\nindex 9aa8602..310f55d 100644\n--- a/src/main/java/org/joda/time/MutableDateTime.java\n+++ b/src/main/java/org/joda/time/MutableDateTime.java\n@@ -636,9 +636,7 @@ public class MutableDateTime\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n-        if (amount != 0) {\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -659,9 +657,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n-        if (years != 0) {\n             setMillis(getChronology().years().add(getMillis(), years));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -682,9 +678,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeekyears(final int weekyears) {\n-        if (weekyears != 0) {\n             setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -705,9 +699,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMonths(final int months) {\n-        if (months != 0) {\n             setMillis(getChronology().months().add(getMillis(), months));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -728,9 +720,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeeks(final int weeks) {\n-        if (weeks != 0) {\n             setMillis(getChronology().weeks().add(getMillis(), weeks));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -771,9 +761,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n-        if (days != 0) {\n             setMillis(getChronology().days().add(getMillis(), days));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -794,9 +782,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addHours(final int hours) {\n-        if (hours != 0) {\n             setMillis(getChronology().hours().add(getMillis(), hours));\n-        }\n     }\n     \n     //-----------------------------------------------------------------------\n@@ -827,9 +813,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMinutes(final int minutes) {\n-        if (minutes != 0) {\n             setMillis(getChronology().minutes().add(getMillis(), minutes));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -860,9 +844,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n-        if (seconds != 0) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -895,9 +877,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n-        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n"}
{"identifier": "Closure-32", "buggy_code": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n\n    do {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Mark the position after the star as the new start of the line.\n          } else {\n            // The star is part of the comment.\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n              // All tokens must be separated by a space.\n\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are ok.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n", "fixed_code": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n    int lineStartChar = -1;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Mark the position after the star as the new start of the line.\n            lineStartChar = stream.getCharno() + 1;\n          } else {\n            // The star is part of the comment.\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          lineStartChar = 0;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          boolean isEOC = token == JsDocToken.EOC;\n          if (!isEOC) {\n            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n              int numSpaces = stream.getCharno() - lineStartChar;\n              for (int i = 0; i < numSpaces; i++) {\n                builder.append(' ');\n              }\n              lineStartChar = -1;\n            } else if (builder.length() > 0) {\n              // All tokens must be separated by a space.\n              builder.append(' ');\n            }\n          }\n\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When we're capturing a license block, annotations\n              // in the block are ok.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex cfdccbe..f6a6400 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1355,14 +1355,12 @@ public final class JsDocInfoParser {\n     // Track the start of the line to count whitespace that\n     // the tokenizer skipped. Because this case is rare, it's easier\n     // to do this here than in the tokenizer.\n-    int lineStartChar = -1;\n \n     do {\n       switch (token) {\n         case STAR:\n           if (ignoreStar) {\n             // Mark the position after the star as the new start of the line.\n-            lineStartChar = stream.getCharno() + 1;\n           } else {\n             // The star is part of the comment.\n             if (builder.length() > 0) {\n@@ -1381,7 +1379,6 @@ public final class JsDocInfoParser {\n           }\n \n           ignoreStar = true;\n-          lineStartChar = 0;\n           token = next();\n           continue;\n \n@@ -1389,19 +1386,7 @@ public final class JsDocInfoParser {\n           ignoreStar = false;\n           state = State.SEARCHING_ANNOTATION;\n \n-          boolean isEOC = token == JsDocToken.EOC;\n-          if (!isEOC) {\n-            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n-              int numSpaces = stream.getCharno() - lineStartChar;\n-              for (int i = 0; i < numSpaces; i++) {\n-                builder.append(' ');\n-              }\n-              lineStartChar = -1;\n-            } else if (builder.length() > 0) {\n               // All tokens must be separated by a space.\n-              builder.append(' ');\n-            }\n-          }\n \n           if (token == JsDocToken.EOC ||\n               token == JsDocToken.EOF ||\n@@ -1426,6 +1411,9 @@ public final class JsDocInfoParser {\n             return new ExtractionInfo(multilineText, token);\n           }\n \n+          if (builder.length() > 0) {\n+            builder.append(' ');\n+          }\n           builder.append(toString(token));\n \n           line = stream.getRemainingJSDocLine();\n"}
{"identifier": "JacksonDatabind-104", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\nindex 02afe5fce..5ea467d0d 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n@@ -438,19 +438,12 @@ public class StdDateFormat\n         final int year = cal.get(Calendar.YEAR);\n \n         // Assuming GregorianCalendar, special handling needed for BCE (aka BC)\n-        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n-            _formatBCEYear(buffer, year);\n-        } else {\n-            if (year > 9999) {\n                 // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but\n                 //   it seems that plus prefix IS mandated. Padding is an open question, but since agreeement\n                 //   for max length would be needed, we ewould need to limit to arbitrary length\n                 //   like five digits (erroring out if beyond or padding to that as minimum).\n                 //   Instead, let's just print number out as is and let decoder try to make sense of it.\n-                buffer.append('+');\n-            }\n             pad4(buffer, year);\n-        }\n         buffer.append('-');\n         pad2(buffer, cal.get(Calendar.MONTH) + 1);\n         buffer.append('-');\n@@ -487,20 +480,11 @@ public class StdDateFormat\n         }\n     }\n \n-    protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) {\n         // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become\n         // \"+0000\", but rest (from `2` up, in that era) need minus sign.\n-        if (bceYearNoSign == 1) {\n-            buffer.append(\"+0000\");\n-            return;\n-        }\n-        final int isoYear = bceYearNoSign - 1;\n-        buffer.append('-');\n         // as with CE, 4 digit variant needs padding; beyond that not (although that part is\n         // open to debate, needs agreement with receiver)\n         // But `pad4()` deals with \"big\" numbers now so:\n-        pad4(buffer, isoYear);\n-    }\n \n     private static void pad2(StringBuffer buffer, int value) {\n         int tens = value / 10;\n@@ -529,11 +513,7 @@ public class StdDateFormat\n         if (h == 0) {\n             buffer.append('0').append('0');\n         } else {\n-            if (h > 99) { // [databind#2167]: handle above 9999 correctly\n-                buffer.append(h);\n-            } else {\n                 pad2(buffer, h);\n-            }\n             value -= (100 * h);\n         }\n         pad2(buffer, value);\n"}
{"identifier": "Mockito-10", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\nindex 3bb7636..e2ded55 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n@@ -14,7 +14,6 @@ import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n-import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n \n import java.io.IOException;\n@@ -69,7 +68,7 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n \n         // record deep stub answer\n         return recordDeepStubAnswer(\n-                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),\n+                newDeepStubMock(returnTypeGenericMetadata),\n                 container\n         );\n     }\n@@ -85,26 +84,22 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n      * @param parentMock The parent of the current deep stub mock.\n      * @return The mock\n      */\n-    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\n-        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\n+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n         return mockitoCore().mock(\n                 returnTypeGenericMetadata.rawType(),\n-                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\n+                withSettingsUsing(returnTypeGenericMetadata)\n         );\n     }\n \n-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                 : withSettings();\n \n-        return propagateSerializationSettings(mockSettings, parentMockSettings)\n+        return mockSettings.serializable()\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n     }\n \n-    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\n-        return mockSettings.serializable(parentMockSettings.getSerializableMode());\n-    }\n \n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\n"}
{"identifier": "Lang-62", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/Entities.java b/src/java/org/apache/commons/lang/Entities.java\nindex a45e004..9570068 100644\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n@@ -847,9 +847,6 @@ class Entities {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n-                            if (entityValue > 0xFFFF) {\n-                                entityValue = -1;\n-                            }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }\n@@ -920,17 +917,12 @@ class Entities {\n                                     case 'X' :\n                                     case 'x' : {\n                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n-                                        break;\n                                     }\n                                     default : {\n                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                     }\n                                 }\n-                                if (entityValue > 0xFFFF) {\n-                                    entityValue = -1;\n-                                }\n                             } catch (NumberFormatException e) {\n-                                entityValue = -1;\n                             }\n                         }\n                     } else { //escaped value content is an entity name\n"}
{"identifier": "JacksonDatabind-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\nindex 05098fd73..e684b10a2 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n@@ -1473,7 +1473,7 @@ public class ObjectReader\n             result = NullNode.instance;\n         } else {\n             DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n+            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n             if (_unwrapRoot) {\n                 result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n             } else {\n@@ -1574,20 +1574,7 @@ public class ObjectReader\n     /**\n      * @since 2.6\n      */\n-    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt)\n-        throws JsonMappingException\n-    {\n-        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n-        if (deser == null) {\n             // Nope: need to ask provider to resolve it\n-            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n-            if (deser == null) { // can this happen?\n-                throw new JsonMappingException(\"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n-            }\n-            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n-        }\n-        return deser;\n-    }\n \n     /**\n      * Method called to locate deserializer ahead of time, if permitted\n"}
{"identifier": "JacksonDatabind-74", "buggy_code": "    // off-lined to keep main method lean and mean...\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                p = tb.asParser(p);\n                // must move to point to the first token:\n                p.nextToken();\n            }\n            return deser.deserialize(p, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n        }\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null;\n    }\n", "fixed_code": "    // off-lined to keep main method lean and mean...\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            if (tb != null) {\n                tb.writeEndObject();\n                p = tb.asParser(p);\n                // must move to point to the first token:\n                p.nextToken();\n            }\n            return deser.deserialize(p, ctxt);\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n        } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                String str = p.getText().trim();\n                if (str.isEmpty()) {\n                    return null;\n                }\n            }\n        }\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// off-lined to keep main method lean and mean...\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\nindex 7941e054c..d1d096a75 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n@@ -153,13 +153,6 @@ public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer\n         // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n         if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n             return super.deserializeTypedFromAny(p, ctxt);\n-        } else if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n-            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                String str = p.getText().trim();\n-                if (str.isEmpty()) {\n-                    return null;\n-                }\n-            }\n         }\n         ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                 \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n"}
{"identifier": "Mockito-35", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/Matchers.java b/src/org/mockito/Matchers.java\nindex 7a89556..16f1b5b 100644\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n@@ -359,7 +359,7 @@ public class Matchers {\n      * @return <code>null</code>.\n      */\n     public static <T> T isA(Class<T> clazz) {\n-        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);\n+        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();\n     }\n \n     /**\n@@ -476,7 +476,7 @@ public class Matchers {\n      * @return <code>null</code>.\n      */\n     public static <T> T eq(T value) {\n-        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());\n+        return reportMatcher(new Equals(value)).<T>returnNull();\n     }  \n \n     /**\n@@ -513,7 +513,7 @@ public class Matchers {\n      * @return <code>null</code>.\n      */\n     public static <T> T same(T value) {\n-        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());\n+        return reportMatcher(new Same(value)).<T>returnNull();\n     }\n \n     /**\n"}
{"identifier": "JacksonCore-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\nindex 18f50c8e..94797eed 100644\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n@@ -271,16 +271,16 @@ public class IOContext\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); }\n+        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n     }\n \n     protected final void _verifyRelease(char[] toRelease, char[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); }\n+        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n     }\n \n     private IllegalArgumentException wrongBuf() {\n         // sanity check failed; trying to return different, smaller buffer.\n-        return new IllegalArgumentException(\"Trying to release buffer smaller than original\");\n+return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n     }\n }\n"}
{"identifier": "Codec-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/language/bm/Lang.java b/src/main/java/org/apache/commons/codec/language/bm/Lang.java\nindex a7ebba6e..e9c2e728 100644\n--- a/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Lang.java\n@@ -95,11 +95,11 @@ public class Lang {\n \n     private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\n \n-    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/%s_lang.txt\";\n+    private static final String LANGUAGE_RULES_RN = \"org/apache/commons/codec/language/bm/lang.txt\";\n \n     static {\n         for (final NameType s : NameType.values()) {\n-            Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));\n+            Langs.put(s, loadFromResource(LANGUAGE_RULES_RN, Languages.getInstance(s)));\n         }\n     }\n \ndiff --git a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\nindex 44a3f03a..97cedb29 100644\n--- a/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\n@@ -28,7 +28,7 @@ import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n-import java.util.TreeMap;\n+import java.util.TreeSet;\n \n import org.apache.commons.codec.language.bm.Languages.LanguageSet;\n import org.apache.commons.codec.language.bm.Rule.Phoneme;\n@@ -335,8 +335,7 @@ public class PhoneticEngine {\n             return phonemeBuilder;\n         }\n \n-        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\n-            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n+        final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\n \n         for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\n             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\n@@ -359,18 +358,10 @@ public class PhoneticEngine {\n             // the phonemes map orders the phonemes only based on their text, but ignores the language set\n             // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\n             // phonemes with the same text but different language set get lost\n-            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\n-                if (phonemes.containsKey(newPhoneme)) {\n-                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\n-                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\n-                    phonemes.put(mergedPhoneme, mergedPhoneme);\n-                } else {\n-                    phonemes.put(newPhoneme, newPhoneme);\n-                }\n-            }\n+            phonemes.addAll(subBuilder.getPhonemes());\n         }\n \n-        return new PhonemeBuilder(phonemes.keySet());\n+        return new PhonemeBuilder(phonemes);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/codec/language/bm/Rule.java b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\nindex 659d2dff..f96ff7c4 100644\n--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java\n@@ -155,9 +155,6 @@ public class Rule {\n          * @param lang the language set to merge\n          * @return a new Phoneme\n          */\n-        public Phoneme mergeWithLanguage(final LanguageSet lang) {\n-          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\n-        }\n \n         @Override\n         public String toString() {\ndiff --git a/src/main/resources/org/apache/commons/codec/language/bm/ash_lang.txt b/src/main/resources/org/apache/commons/codec/language/bm/ash_lang.txt\n--- a/src/main/resources/org/apache/commons/codec/language/bm/ash_lang.txt\t2020-01-24 12:25:47.065255433 -0800\n+++ b/src/main/resources/org/apache/commons/codec/language/bm/ash_lang.txt\t1969-12-31 16:00:00.000000000 -0800\n@@ -1,206 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-// ASHKENAZIC\n-\n-// 1. following are rules to accept the language\n-// 1.1 Special letter combinations\n-zh polish+russian+german+english true\n-eau french true\n-[aoeiu\u00c3\u00a4\u00c3\u00b6\u00c3\u00bc]h german true\n-^vogel german, true\n-vogel$ german true\n-witz german true\n-tz$ german+russian+english true\n-^tz russian+english true\n-g\u00c3\u00bce spanish true\n-g\u00c3\u00bci spanish true\n-ghe romanian true\n-ghi romanian true\n-vici$ romanian true\n-schi$ romanian true\n-chsch german true\n-tsch german true\n-ssch german true\n-sch$ german+russian true\n-^sch german+russian true\n-^rz polish true\n-rz$ polish+german true\n-[^aoeiu\u00c3\u00a4\u00c3\u00b6\u00c3\u00bc]rz polish true\n-rz[^aoeiu\u00c3\u00a4\u00c3\u00b6\u00c3\u00bc] polish true\n-cki$ polish true\n-ska$ polish true\n-cka$ polish true\n-ue german+russian true\n-ae german+russian+english true\n-oe german+french+russian+english true\n-th$ german true\n-^th german true\n-th[^aoeiu] german true\n-mann german true\n-cz polish true\n-cy polish true\n-niew polish true\n-stein german true\n-heim$ german true\n-heimer$ german true\n-ii$ russian true\n-iy$ russian true\n-yy$ russian true\n-yi$ russian true\n-yj$ russian true\n-ij$ russian true\n-gaus$ russian true\n-gauz$ russian true\n-gauz$ russian true\n-goltz$ russian true\n-gol'tz$ russian true \n-golts$ russian true \n-gol'ts$ russian true \n-^goltz russian true\n-^gol'tz russian true \n-^golts russian true \n-^gol'ts russian true \n-gendler$ russian true \n-gejmer$ russian true \n-gejm$ russian true \n-geimer$ russian true \n-geim$ russian true \n-geymer russian true \n-geym$ russian true \n-gof$ russian true \n-thal german true\n-zweig german true\n-ck$ german+english true\n-c$ polish+romanian+hungarian true\n-sz polish+hungarian true\n-gue spanish+french true\n-gui spanish+french true\n-guy french true\n-cs$ hungarian true\n-^cs hungarian true\n-dzs hungarian true\n-zs$ hungarian true\n-^zs hungarian true\n-^wl polish true\n-^wr polish+english+german true\n-\n-gy$ hungarian true\n-gy[aeou] hungarian true\n-gy hungarian+russian true\n-ly hungarian+russian+polish true\n-ny hungarian+russian+polish true\n-ty hungarian+russian+polish true \n-\n-// 1.2 special characters    \n-\u00c3\u00a2 romanian+french true\n-\u00c4\u0083 romanian true\n-\u00c3\u00a0 french true\n-\u00c3\u00a4 german true\n-\u00c3\u00a1 hungarian+spanish true\n-\u00c4\u0085 polish true\n-\u00c4\u0087 polish true\n-\u00c3\u00a7 french true\n-\u00c4\u0099 polish true\n-\u00c3\u00a9 french+hungarian+spanish true\n-\u00c3\u00a8 french true\n-\u00c3\u00aa french true\n-\u00c3\u00ad hungarian+spanish true\n-\u00c3\u00ae romanian+french true\n-\u00c5\u0082 polish true\n-\u00c5\u0084 polish true\n-\u00c3\u00b1 spanish true\n-\u00c3\u00b3 polish+hungarian+spanish true\n-\u00c3\u00b6 german+hungarian true\n-\u00c3\u00b5 hungarian true\n-\u00c5\u009f romanian true\n-\u00c5\u009b polish true\n-\u00c5\u00a3 romanian true\n-\u00c3\u00bc german+hungarian true\n-\u00c3\u00b9 french true\n-\u00c5\u00b1 hungarian true\n-\u00c3\u00ba hungarian+spanish true\n-\u00c5\u00ba polish true\n-\u00c5\u00bc polish true\n-    \n-\u00c3\u009f german true\n-\n-// Every Cyrillic word has at least one Cyrillic vowel (\u00d0\u00b0\u00d1\u0091\u00d0\u00b5\u00d0\u00be\u00d0\u00b8\u00d1\u0083\u00d1\u008b\u00d1\u008d\u00d1\u008e\u00d1\u008f) \n-\u00d0\u00b0 cyrillic true \n-\u00d1\u0091 cyrillic true \n-\u00d0\u00be cyrillic true \n-\u00d0\u00b5 cyrillic true \n-\u00d0\u00b8 cyrillic true \n-\u00d1\u0083 cyrillic true \n-\u00d1\u008b cyrillic true \n-\u00d1\u008d cyrillic true \n-\u00d1\u008e cyrillic true \n-\u00d1\u008f cyrillic true \n-    \n-// Hebrew \n-\u00d7\u0090 hebrew true\n-\u00d7\u0091 hebrew true\n-\u00d7\u0092 ebrew true\n-\u00d7\u0093 hebrew true\n-\u00d7\u0094 hebrew true\n-\u00d7\u0095 hebrew true\n-\u00d7\u0096 hebrew true\n-\u00d7\u0097 hebrew true\n-\u00d7\u0098 hebrew true\n-\u00d7\u0099 hebrew true\n-\u00d7\u009b hebrew true\n-\u00d7\u009c hebrew true\n-\u00d7\u009e hebrew true\n-\u00d7\u00a0 hebrew true\n-\u00d7\u00a1 hebrew true\n-\u00d7\u00a2 hebrew true\n-\u00d7\u00a4 hebrew true\n-\u00d7\u00a6 hebrew true \n-\u00d7\u00a7 hebrew true\n-\u00d7\u00a8 hebrew true\n-\u00d7\u00a9 hebrew true\n-\u00d7\u00aa hebrew true\n-    \n-    \n-// 2. following are rules to reject the language\n-// Every Latin character word has at least one Latin vowel  \n-a cyrillic+hebrew false \n-o cyrillic+hebrew false \n-e cyrillic+hebrew false \n-i cyrillic+hebrew false \n-y cyrillic+hebrew+romanian false \n-u cyrillic+hebrew false \n-  \n-v[^aoeiu\u00c3\u00a4\u00c3\u00bc\u00c3\u00b6] german false // in german \"v\" can be found before a vowel only\n-y[^aoeiu] german false  // in german \"y\" usually appears only in the last position; sometimes before a vowel\n-c[^aohk] german false\n-dzi german+english+french false\n-ou german false\n-aj german+english+french false\n-ej german+english+french false\n-oj german+english+french false\n-uj german+english+french false\n-k romanian false\n-v polish false\n-ky polish false\n-eu russian+polish false\n-w french+romanian+spanish+hungarian+russian false\n-kie french+spanish false\n-gie french+romanian+spanish false\n-q hungarian+polish+russian+romanian false\n-sch hungarian+polish+french+spanish false\n-^h russian false\ndiff --git a/src/main/resources/org/apache/commons/codec/language/bm/gen_lang.txt b/src/main/resources/org/apache/commons/codec/language/bm/gen_lang.txt\n--- a/src/main/resources/org/apache/commons/codec/language/bm/gen_lang.txt\t2020-01-24 12:25:47.065255433 -0800\n+++ b/src/main/resources/org/apache/commons/codec/language/bm/gen_lang.txt\t1969-12-31 16:00:00.000000000 -0800\n@@ -1,295 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-// GENERIC\n-\n-// 1. following are rules to accept the language\n-// 1.1 Special letter combinations\n-^o\u00e2\u0080\u0099 english true\n-^o' english true\n-^mc english true\n-^fitz english true\n-ceau french+romanian true\n-eau romanian true\n-eau$ french true // mp: I've added this\n-eaux$ french true // mp: I've added this\n-ault$ french true\n-oult$ french true\n-eux$ french true\n-eix$ french true\n-glou$ greeklatin true\n-uu dutch true\n-tx spanish true\n-witz german true\n-tz$ german+russian+english true\n-^tz russian+english true\n-poulos$ greeklatin true\n-pulos$ greeklatin true\n-iou greeklatin true\n-sj$ dutch true\n-^sj dutch true\n-g\u00c3\u00bce spanish true\n-g\u00c3\u00bci spanish true\n-ghe romanian+greeklatin true\n-ghi romanian+greeklatin true\n-escu$ romanian true\n-esco$ romanian true\n-vici$ romanian true\n-schi$ romanian true\n-ii$ russian true\n-iy$ russian true\n-yy$ russian true\n-yi$ russian true\n-^rz polish true\n-rz$ polish+german true\n-[bcdfgklmnpstwz]rz polish true\n-rz[bcdfghklmnpstw] polish true\n-cki$ polish true\n-ska$ polish true\n-cka$ polish true\n-ae german+russian+english true\n-oe german+french+russian+english+dutch true\n-th$ german+english true\n-^th german+english+greeklatin true\n-mann german true\n-cz polish true\n-cy polish+greeklatin true\n-niew polish true\n-etti$ italian true\n-eti$ italian true\n-ati$ italian true\n-ato$ italian true\n-[aoei]no$ italian true\n-[aoei]ni$ italian true\n-esi$ italian true\n-oli$ italian true\n-field$ english true\n-stein german true\n-heim$ german true\n-heimer$ german true\n-thal german true\n-zweig german true\n-[aeou]h german true\n-\u00c3\u00a4h german true\n-\u00c3\u00b6h german true\n-\u00c3\u00bch german true\n-[ln]h[ao]$ portuguese true\n-[ln]h[aou] portuguese+french+german+dutch+czech+spanish+turkish true\n-chsch german true\n-tsch german true\n-sch$ german+russian true\n-^sch german+russian true\n-ck$ german+english true\n-c$ polish+romanian+hungarian+czech+turkish true\n-sz polish+hungarian true\n-cs$ hungarian true\n-^cs hungarian true\n-dzs hungarian true\n-zs$ hungarian true\n-^zs hungarian true\n-^wl polish true\n-^wr polish+english+german+dutch true\n-\n-gy$ hungarian true\n-gy[aeou] hungarian true\n-gy hungarian+russian+french+greeklatin true\n-guy french true\n-gu[ei] spanish+french+portuguese true\n-gu[ao] spanish+portuguese true\n-gi[aou] italian+greeklatin true\n-        \n-ly hungarian+russian+polish+greeklatin true\n-ny hungarian+russian+polish+spanish+greeklatin true\n-ty hungarian+russian+polish+greeklatin true \n-\n-// 1.2 special characters    \n-\u00c4\u0087 polish true\n-\u00c3\u00a7 french+spanish+portuguese+turkish true\n-\u00c4\u008d czech true\n-\u00c4\u008f czech true\n-\u00c4\u009f turkish true\n-\u00c5\u0082 polish true\n-\u00c5\u0084 polish true\n-\u00c3\u00b1 spanish true\n-\u00c5\u0088 czech true\n-\u00c5\u0099 czech true\n-\u00c5\u009b polish true\n-\u00c5\u009f romanian+turkish true\n-\u00c5\u00a1 czech true\n-\u00c5\u00a3 romanian true\n-\u00c5\u00a5 czech true\n-\u00c5\u00ba polish true\n-\u00c5\u00bc polish true\n-        \n-\u00c3\u009f german true\n-\n-\u00c3\u00a4 german true\n-\u00c3\u00a1 hungarian+spanish+portuguese+czech+greeklatin true\n-\u00c3\u00a2 romanian+french+portuguese true\n-\u00c4\u0083 romanian true\n-\u00c4\u0085 polish true\n-\u00c3\u00a0 portuguese true\n-\u00c3\u00a3 portuguese true\n-\u00c4\u0099 polish true\n-\u00c3\u00a9 french+hungarian+czech+greeklatin true\n-\u00c3\u00a8 french+spanish+italian true\n-\u00c3\u00aa french true\n-\u00c4\u009b czech true\n-\u00c3\u00aa french+portuguese true\n-\u00c3\u00ad hungarian+spanish+portuguese+czech+greeklatin true\n-\u00c3\u00ae romanian+french true\n-\u00c4\u00b1 turkish true\n-\u00c3\u00b3 polish+hungarian+spanish+italian+portuguese+czech+greeklatin true\n-\u00c3\u00b6 german+hungarian+turkish true\n-\u00c3\u00b4 french+portuguese true\n-\u00c3\u00b5 portuguese+hungarian true\n-\u00c3\u00b2 italian+spanish true\n-\u00c5\u00b1 hungarian true\n-\u00c3\u00ba hungarian+spanish+portuguese+czech+greeklatin true\n-\u00c3\u00bc german+hungarian+spanish+portuguese+turkish true\n-\u00c3\u00b9 french true\n-\u00c5\u00af czech true\n-\u00c3\u00bd czech+greeklatin true\n-   \n-// Every Cyrillic word has at least one Cyrillic vowel (\u00d0\u00b0\u00d1\u0091\u00d0\u00b5\u00d0\u00be\u00d0\u00b8\u00d1\u0083\u00d1\u008b\u00d1\u008d\u00d1\u008e\u00d1\u008f) \n-\u00d0\u00b0 cyrillic true \n-\u00d1\u0091 cyrillic true \n-\u00d0\u00be cyrillic true \n-\u00d0\u00b5 cyrillic true \n-\u00d0\u00b8 cyrillic true \n-\u00d1\u0083 cyrillic true \n-\u00d1\u008b cyrillic true \n-\u00d1\u008d cyrillic true \n-\u00d1\u008e cyrillic true \n-\u00d1\u008f cyrillic true \n- \n-// Every Greek word has at least one Greek vowel\n-\u00ce\u00b1 greek true \n-\u00ce\u00b5 greek true \n-\u00ce\u00b7 greek true \n-\u00ce\u00b9 greek true \n-\u00ce\u00bf greek true \n-\u00cf\u0085 greek true \n-\u00cf\u0089 greek true \n-\n-// Arabic (only initial)\n-\u00d8\u00a7 arabic true // alif (isol + init)   \n-\u00d8\u00a8 arabic true // ba' \n-\u00d8\u00aa arabic true // ta' \n-\u00d8\u00ab arabic true // tha'\n-\u00d8\u00ac arabic true // jim\n-\u00d8\u00ad arabic true // h.a' \n-\u00d8\u00ae' arabic true // kha' \n-\u00d8\u00af arabic true // dal (isol + init)\n-\u00d8\u00b0 arabic true // dhal (isol + init)\n-\u00d8\u00b1 arabic true // ra' (isol + init)\n-\u00d8\u00b2 arabic true // za' (isol + init)\n-\u00d8\u00b3 arabic true // sin \n-\u00d8\u00b4 arabic true // shin \n-\u00d8\u00b5 arabic true // s.ad \n-\u00d8\u00b6 arabic true // d.ad \n-\u00d8\u00b7 arabic true // t.a' \n-\u00d8\u00b8 arabic true // z.a' \n-\u00d8\u00b9 arabic true // 'ayn\n-\u00d8\u00ba arabic true // ghayn \n-\u00d9\u0081 arabic true // fa' \n-\u00d9\u0082 arabic true // qaf \n-\u00d9\u0083 arabic true // kaf  \n-\u00d9\u0084 arabic true // lam \n-\u00d9\u0085 arabic true // mim \n-\u00d9\u0086 arabic true // nun \n-\u00d9\u0087 arabic true // ha' \n-\u00d9\u0088 arabic true // waw (isol + init)\n-\u00d9\u008a arabic true // ya' \n-    \n-\u00d8\u00a2 arabic true // alif madda  \n-\u00d8\u00a5 arabic true // alif + diacritic  \n-\u00d8\u00a3 arabic true // alif + hamza\n-\u00d8\u00a4 arabic true //  waw + hamza\n-\u00d8\u00a6 arabic true //  ya' + hamza\n-\u00d9\u0084\u00d8\u00a7 arabic true // ligature l+a\n-                \n-// Hebrew \n-\u00d7\u0090 hebrew true\n-\u00d7\u0091 hebrew true\n-\u00d7\u0092 hebrew true\n-\u00d7\u0093 hebrew true\n-\u00d7\u0094 hebrew true\n-\u00d7\u0095 hebrew true\n-\u00d7\u0096 hebrew true\n-\u00d7\u0097 hebrew true\n-\u00d7\u0098 hebrew true\n-\u00d7\u0099 hebrew true\n-\u00d7\u009b hebrew true\n-\u00d7\u009c hebrew true\n-\u00d7\u009e hebrew true\n-\u00d7\u00a0 hebrew true\n-\u00d7\u00a1 hebrew true\n-\u00d7\u00a2 hebrew true\n-\u00d7\u00a4 hebrew true\n-\u00d7\u00a6 hebrew true \n-\u00d7\u00a7 hebrew true\n-\u00d7\u00a8 hebrew true\n-\u00d7\u00a9 hebrew true\n-\u00d7\u00aa hebrew true\n-      \n-// 2. following are rules to reject the language\n-   \n-// Every Latin character word has at least one Latin vowel  \n-a cyrillic+hebrew+greek+arabic false \n-o cyrillic+hebrew+greek+arabic false \n-e cyrillic+hebrew+greek+arabic false \n-i cyrillic+hebrew+greek+arabic false \n-y cyrillic+hebrew+greek+arabic+romanian+dutch false \n-u cyrillic+hebrew+greek+arabic false \n-  \n-j italian false\n-j[^aoeiuy] french+spanish+portuguese+greeklatin false \n-g czech false\n-k romanian+spanish+portuguese+french+italian false\n-q hungarian+polish+russian+romanian+czech+dutch+turkish+greeklatin false\n-v polish false\n-w french+romanian+spanish+hungarian+russian+czech+turkish+greeklatin false\n-x czech+hungarian+dutch+turkish false // polish excluded from the list\n-    \n-dj spanish+turkish false\n-v[^aoeiu] german false // in german, \"v\" can be found before a vowel only\n-y[^aoeiu] german false  // in german, \"y\" usually appears only in the last position; sometimes before a vowel\n-c[^aohk] german false\n-dzi german+english+french+turkish false\n-ou german false\n-a[eiou] turkish false // no diphthongs in Turkish\n-\u00c3\u00b6[eaiou] turkish false \n-\u00c3\u00bc[eaiou] turkish false \n-e[aiou] turkish false \n-i[aeou] turkish false \n-o[aieu] turkish false \n-u[aieo] turkish false \n-aj german+english+french+dutch false\n-ej german+english+french+dutch false\n-oj german+english+french+dutch false\n-uj german+english+french+dutch false\n-eu russian+polish false\n-ky polish false\n-kie french+spanish+greeklatin false\n-gie portuguese+romanian+spanish+greeklatin false\n-ch[aou] italian false\n-ch turkish false\n-son$ german false\n-sc[ei] french false\n-sch hungarian+polish+french+spanish false\n-^h russian false\ndiff --git a/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt b/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt\n--- a/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt\t2020-01-24 12:25:47.065255433 -0800\n+++ b/src/main/resources/org/apache/commons/codec/language/bm/sep_lang.txt\t1969-12-31 16:00:00.000000000 -0800\n@@ -1,105 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-// SEPHARDIC\n-\n-// 1. following are rules to accept the language\n-// 1.1 Special letter combinations\n-eau french true\n-ou french true\n-gni italian+french true\n-tx spanish true\n-tj spanish true\n-gy french true\n-guy french true\n-\n-sh spanish+portuguese true // English, but no sign for /sh/ in these languages\n-\n-lh portuguese true\n-nh portuguese true\n-ny spanish true\n-\n-gue spanish+french true\n-gui spanish+french true\n-gia italian true\n-gie italian true\n-gio italian true\n-giu italian true\n-            \n-// 1.2 special characters    \n-\u00c3\u00b1 spanish true\n-\u00c3\u00a2 portuguese+french true\n-\u00c3\u00a1 portuguese+spanish true\n-\u00c3\u00a0 portuguese true\n-\u00c3\u00a3 portuguese true\n-\u00c3\u00aa french+portuguese true\n-\u00c3\u00ad portuguese+spanish true\n-\u00c3\u00ae french true\n-\u00c3\u00b4 french+portuguese true\n-\u00c3\u00b5 portuguese true\n-\u00c3\u00b2 italian+spanish true\n-\u00c3\u00ba portuguese+spanish true\n-\u00c3\u00b9 french true\n-\u00c3\u00bc portuguese+spanish true\n-      \n-// Hebrew \n-\u00d7\u0090 hebrew true\n-\u00d7\u0091 hebrew true\n-\u00d7\u0092 hebrew true\n-\u00d7\u0093 hebrew true\n-\u00d7\u0094 hebrew true\n-\u00d7\u0095 hebrew true\n-\u00d7\u0096 hebrew true\n-\u00d7\u0097 hebrew true\n-\u00d7\u0098 hebrew true\n-\u00d7\u0099 hebrew true\n-\u00d7\u009b hebrew true\n-\u00d7\u009c hebrew true\n-\u00d7\u009e hebrew true\n-\u00d7\u00a0 hebrew true\n-\u00d7\u00a1 hebrew true\n-\u00d7\u00a2 hebrew true\n-\u00d7\u00a4 hebrew true\n-\u00d7\u00a6 hebrew true \n-\u00d7\u00a7 hebrew true\n-\u00d7\u00a8 hebrew true\n-\u00d7\u00a9 hebrew true\n-\u00d7\u00aa hebrew true\n-        \n-// 2. following are rules to reject the language\n-    \n-// Every Latin character word has at least one Latin vowel  \n-a hebrew false \n-o hebrew false \n-e hebrew false \n-i hebrew false \n-y hebrew false \n-u hebrew false \n-      \n-kh spanish false\n-gua italian false\n-guo italian false\n-\u00c3\u00a7 italian false\n-cha italian false\n-cho italian false\n-chu italian false\n-j italian false\n-dj spanish false\n-sce french false\n-sci french false\n-\u00c3\u00b3 french false\n-\u00c3\u00a8 portuguese false\n\n"}
{"identifier": "Lang-32", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\nindex 9f7e890..4ae351d 100644\n--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n@@ -101,7 +101,12 @@ public class HashCodeBuilder {\n      * \n      * @since 2.3\n      */\n-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\n+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n+        @Override\n+        protected Set<IDKey> initialValue() {\n+            return new HashSet<IDKey>();\n+        }\n+    };\n \n     /*\n      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n@@ -144,8 +149,7 @@ public class HashCodeBuilder {\n      * @since 2.3\n      */\n     static boolean isRegistered(Object value) {\n-        Set<IDKey> registry = getRegistry();\n-        return registry != null && registry.contains(new IDKey(value));\n+        return getRegistry().contains(new IDKey(value));\n     }\n \n     /**\n@@ -515,11 +519,6 @@ public class HashCodeBuilder {\n      *            The object to register.\n      */\n     static void register(Object value) {\n-        synchronized (HashCodeBuilder.class) {\n-            if (getRegistry() == null) {\n-                REGISTRY.set(new HashSet<IDKey>());\n-            }\n-        }\n         getRegistry().add(new IDKey(value));\n     }\n \n@@ -536,15 +535,7 @@ public class HashCodeBuilder {\n      * @since 2.3\n      */\n     static void unregister(Object value) {\n-        Set<IDKey> s = getRegistry();\n-        if (s != null) {\n-            s.remove(new IDKey(value));\n-            synchronized (HashCodeBuilder.class) {\n-                if (s.isEmpty()) {\n-                    REGISTRY.remove();\n-                }\n-            }\n-        }\n+        getRegistry().remove(new IDKey(value));\n     }\n \n     /**\n"}
{"identifier": "Math-63", "buggy_code": "    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }\n", "fixed_code": "    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns true iff they are equal as defined by\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex ab0fe33..1361849 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return equals(x, y, 1);\n+        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n     }\n \n     /**\n"}
{"identifier": "JacksonCore-24", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\nindex 981e796d..1e52b9e0 100644\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n@@ -866,11 +866,9 @@ public abstract class ParserBase extends ParserMinimalBase\n     // @since 2.9.8\n     protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n     {\n-        if (expType == NR_INT) {\n-            reportOverflowInt(rawNum);\n-        } else {\n-            reportOverflowLong(rawNum);\n-        }\n+        final String numDesc = _longIntegerDesc(rawNum);\n+        _reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n+                (expType == NR_LONG) ? \"long\" : \"int\");\n     }\n \n     /*\n@@ -886,7 +884,7 @@ public abstract class ParserBase extends ParserMinimalBase\n             // Let's verify it's lossless conversion by simple roundtrip\n             int result = (int) _numberLong;\n             if (((long) result) != _numberLong) {\n-                reportOverflowInt(getText(), currentToken());\n+                _reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n             }\n             _numberInt = result;\n         } else if ((_numTypesValid & NR_BIGINT) != 0) {\ndiff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\nindex fe9a0475..c83ade9c 100644\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n@@ -562,15 +562,11 @@ public abstract class ParserMinimalBase extends JsonParser\n \n     // @since 2.10\n     protected void reportOverflowInt(String numDesc) throws IOException {\n-        reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT);\n+        _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n+                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));\n     }\n \n     // @since 2.10\n-    protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException {\n-        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n-                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE),\n-                inputType, Integer.TYPE);\n-    }\n \n     /**\n      * Method called to throw an exception for integral (not floating point) input\n@@ -583,15 +579,11 @@ public abstract class ParserMinimalBase extends JsonParser\n \n     // @since 2.10\n     protected void reportOverflowLong(String numDesc) throws IOException {\n-        reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT);\n+        _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n+                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));\n     }\n \n     // @since 2.10\n-    protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException {\n-        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n-                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE),\n-                inputType, Long.TYPE);\n-    }\n \n     /**\n      * @since 2.10\n"}
{"identifier": "Lang-25", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\nindex ef839c6..8caca58 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n@@ -71,33 +71,33 @@ public class EntityArrays {\n         {\"\\u00C7\", \"&Ccedil;\"}, // \u00c7 - uppercase C, cedilla\n         {\"\\u00C8\", \"&Egrave;\"}, // \u00c8 - uppercase E, grave accent\n         {\"\\u00C9\", \"&Eacute;\"}, // \u00c9 - uppercase E, acute accent\n-        {\"\\u00CA\", \"&Ecirc;\"}, // \u00ca - uppercase E, circumflex accent\n-        {\"\\u00CB\", \"&Euml;\"}, // \u00cb - uppercase E, umlaut\n-        {\"\\u00CC\", \"&Igrave;\"}, // \u00cc - uppercase I, grave accent\n-        {\"\\u00CD\", \"&Iacute;\"}, // \u00cd - uppercase I, acute accent\n-        {\"\\u00CE\", \"&Icirc;\"}, // \u00ce - uppercase I, circumflex accent\n-        {\"\\u00CF\", \"&Iuml;\"}, // \u00cf - uppercase I, umlaut\n-        {\"\\u00D0\", \"&ETH;\"}, // \u00d0 - uppercase Eth, Icelandic\n-        {\"\\u00D1\", \"&Ntilde;\"}, // \u00d1 - uppercase N, tilde\n-        {\"\\u00D2\", \"&Ograve;\"}, // \u00d2 - uppercase O, grave accent\n-        {\"\\u00D3\", \"&Oacute;\"}, // \u00d3 - uppercase O, acute accent\n-        {\"\\u00D4\", \"&Ocirc;\"}, // \u00d4 - uppercase O, circumflex accent\n-        {\"\\u00D5\", \"&Otilde;\"}, // \u00d5 - uppercase O, tilde\n-        {\"\\u00D6\", \"&Ouml;\"}, // \u00d6 - uppercase O, umlaut\n-        {\"\\u00D7\", \"&times;\"}, // multiplication sign\n-        {\"\\u00D8\", \"&Oslash;\"}, // \u00d8 - uppercase O, slash\n-        {\"\\u00D9\", \"&Ugrave;\"}, // \u00d9 - uppercase U, grave accent\n-        {\"\\u00DA\", \"&Uacute;\"}, // \u00da - uppercase U, acute accent\n-        {\"\\u00DB\", \"&Ucirc;\"}, // \u00db - uppercase U, circumflex accent\n-        {\"\\u00DC\", \"&Uuml;\"}, // \u00dc - uppercase U, umlaut\n-        {\"\\u00DD\", \"&Yacute;\"}, // \u00dd - uppercase Y, acute accent\n-        {\"\\u00DE\", \"&THORN;\"}, // \u00de - uppercase THORN, Icelandic\n-        {\"\\u00DF\", \"&szlig;\"}, // \u00df - lowercase sharps, German\n-        {\"\\u00E0\", \"&agrave;\"}, // \u00e0 - lowercase a, grave accent\n-        {\"\\u00E1\", \"&aacute;\"}, // \u00e1 - lowercase a, acute accent\n-        {\"\\u00E2\", \"&acirc;\"}, // \u00e2 - lowercase a, circumflex accent\n-        {\"\\u00E3\", \"&atilde;\"}, // \u00e3 - lowercase a, tilde\n-        {\"\\u00E4\", \"&auml;\"}, // \u00e4 - lowercase a, umlaut\n+        {\"\\u00CB\", \"&Ecirc;\"}, // \u00ca - uppercase E, circumflex accent\n+        {\"\\u00CC\", \"&Euml;\"}, // \u00cb - uppercase E, umlaut\n+        {\"\\u00CD\", \"&Igrave;\"}, // \u00cc - uppercase I, grave accent\n+        {\"\\u00CE\", \"&Iacute;\"}, // \u00cd - uppercase I, acute accent\n+        {\"\\u00CF\", \"&Icirc;\"}, // \u00ce - uppercase I, circumflex accent\n+        {\"\\u00D0\", \"&Iuml;\"}, // \u00cf - uppercase I, umlaut\n+        {\"\\u00D1\", \"&ETH;\"}, // \u00d0 - uppercase Eth, Icelandic\n+        {\"\\u00D2\", \"&Ntilde;\"}, // \u00d1 - uppercase N, tilde\n+        {\"\\u00D3\", \"&Ograve;\"}, // \u00d2 - uppercase O, grave accent\n+        {\"\\u00D4\", \"&Oacute;\"}, // \u00d3 - uppercase O, acute accent\n+        {\"\\u00D5\", \"&Ocirc;\"}, // \u00d4 - uppercase O, circumflex accent\n+        {\"\\u00D6\", \"&Otilde;\"}, // \u00d5 - uppercase O, tilde\n+        {\"\\u00D7\", \"&Ouml;\"}, // \u00d6 - uppercase O, umlaut\n+        {\"\\u00D8\", \"&times;\"}, // multiplication sign\n+        {\"\\u00D9\", \"&Oslash;\"}, // \u00d8 - uppercase O, slash\n+        {\"\\u00DA\", \"&Ugrave;\"}, // \u00d9 - uppercase U, grave accent\n+        {\"\\u00DB\", \"&Uacute;\"}, // \u00da - uppercase U, acute accent\n+        {\"\\u00DC\", \"&Ucirc;\"}, // \u00db - uppercase U, circumflex accent\n+        {\"\\u00DD\", \"&Uuml;\"}, // \u00dc - uppercase U, umlaut\n+        {\"\\u00DE\", \"&Yacute;\"}, // \u00dd - uppercase Y, acute accent\n+        {\"\\u00DF\", \"&THORN;\"}, // \u00de - uppercase THORN, Icelandic\n+        {\"\\u00E0\", \"&szlig;\"}, // \u00df - lowercase sharps, German\n+        {\"\\u00E1\", \"&agrave;\"}, // \u00e0 - lowercase a, grave accent\n+        {\"\\u00E2\", \"&aacute;\"}, // \u00e1 - lowercase a, acute accent\n+        {\"\\u00E3\", \"&acirc;\"}, // \u00e2 - lowercase a, circumflex accent\n+        {\"\\u00E4\", \"&atilde;\"}, // \u00e3 - lowercase a, tilde\n+        {\"\\u00E5\", \"&auml;\"}, // \u00e4 - lowercase a, umlaut\n         {\"\\u00E5\", \"&aring;\"}, // \u00e5 - lowercase a, ring\n         {\"\\u00E6\", \"&aelig;\"}, // \u00e6 - lowercase ae\n         {\"\\u00E7\", \"&ccedil;\"}, // \u00e7 - lowercase c, cedilla\n"}
{"identifier": "Jsoup-19", "buggy_code": "    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n        // rels without a baseuri get removed\n        String value = el.absUrl(attr.getKey());\n        if (!preserveRelativeLinks)\n            attr.setValue(value);\n        \n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString() + \":\";\n            if (value.toLowerCase().startsWith(prot)) {\n                return true;\n            }\n        }\n        return false;\n    }\n", "fixed_code": "    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n        // rels without a baseuri get removed\n        String value = el.absUrl(attr.getKey());\n        if (value.length() == 0)\n            value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols\n        if (!preserveRelativeLinks)\n            attr.setValue(value);\n        \n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString() + \":\";\n            if (value.toLowerCase().startsWith(prot)) {\n                return true;\n            }\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/safety/Whitelist.java b/src/main/java/org/jsoup/safety/Whitelist.java\nindex 4d14dce..51349da 100644\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n@@ -339,8 +339,6 @@ public class Whitelist {\n         // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n         // rels without a baseuri get removed\n         String value = el.absUrl(attr.getKey());\n-        if (value.length() == 0)\n-            value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols\n         if (!preserveRelativeLinks)\n             attr.setValue(value);\n         \n"}
{"identifier": "Lang-24", "buggy_code": "    /**\n     * <p>Checks whether the String a valid Java number.</p>\n     *\n     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n     * qualifier, scientific notation and numbers marked with a type\n     * qualifier (e.g. 123L).</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if the string is a correctly formatted number\n     */\n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                // we've already taken care of hex.\n                if (hasExp) {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent or decimal point\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n", "fixed_code": "    /**\n     * <p>Checks whether the String a valid Java number.</p>\n     *\n     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n     * qualifier, scientific notation and numbers marked with a type\n     * qualifier (e.g. 123L).</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if the string is a correctly formatted number\n     */\n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                // we've already taken care of hex.\n                if (hasExp) {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent\n                    return false;\n                }\n                // single trailing decimal point after non-exponent is ok\n                return foundDigit;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent or decimal point\n                return foundDigit && !hasExp && !hasDecPoint;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Checks whether the String a valid Java number.</p>\n     *\n     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n     * qualifier, scientific notation and numbers marked with a type\n     * qualifier (e.g. 123L).</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if the string is a correctly formatted number\n     */\n    public static boolean isNumber(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d9b3c6d..4a1d845 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1410,7 +1410,7 @@ public class NumberUtils {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp && !hasDecPoint;\n+                return foundDigit && !hasExp;\n             }\n             // last character is illegal\n             return false;\n"}
{"identifier": "Math-105", "buggy_code": "    /**\n     * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n     * sum of squared errors</a> (SSE) associated with the regression \n     * model.\n     * <p>\n     * The sum is computed using the computational formula\n     * <p>\n     * <code>SSE = SYY - (SXY * SXY / SXX)</code>\n     * <p>\n     * where <code>SYY</code> is the sum of the squared deviations of the y\n     * values about their mean, <code>SXX</code> is similarly defined and\n     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n     * <p>\n     * The sums are accumulated using the updating algorithm referenced in \n     * {@link #addData}.  \n     * <p>\n     * The return value is constrained to be non-negative - i.e., if due to \n     * rounding errors the computational formula returns a negative result, \n     * 0 is returned.\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is \n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul>\n     *\n     * @return sum of squared errors associated with the regression model\n     */\n    public double getSumSquaredErrors() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n", "fixed_code": "    /**\n     * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n     * sum of squared errors</a> (SSE) associated with the regression \n     * model.\n     * <p>\n     * The sum is computed using the computational formula\n     * <p>\n     * <code>SSE = SYY - (SXY * SXY / SXX)</code>\n     * <p>\n     * where <code>SYY</code> is the sum of the squared deviations of the y\n     * values about their mean, <code>SXX</code> is similarly defined and\n     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n     * <p>\n     * The sums are accumulated using the updating algorithm referenced in \n     * {@link #addData}.  \n     * <p>\n     * The return value is constrained to be non-negative - i.e., if due to \n     * rounding errors the computational formula returns a negative result, \n     * 0 is returned.\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n     * must have been added before invoking this method. If this method is \n     * invoked before a model can be estimated, <code>Double,NaN</code> is\n     * returned.\n     * </li></ul>\n     *\n     * @return sum of squared errors associated with the regression model\n     */\n    public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n     * sum of squared errors</a> (SSE) associated with the regression \n     * model.\n     * <p>\n     * The sum is computed using the computational formula\n     * <p>\n     * <code>SSE = SYY - (SXY * SXY / SXX)</code>\n     * <p>\n     * where <code>SYY</code> is the sum of the squared deviations of the y\n     * values about their mean, <code>SXX</code> is similarly defined and\n     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n     * <p>\n     * The sums are accumulated using the updating algorithm referenced in \n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\nindex d9fa592..dcf512b 100644\n--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n@@ -261,7 +261,7 @@ public class SimpleRegression implements Serializable {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n+        return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n"}
{"identifier": "Time-25", "buggy_code": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n", "fixed_code": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 81f5872..a320022 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,15 +896,6 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n-            long prev = previousTransition(instantAdjusted);\n-            if (prev < instantAdjusted) {\n-                int offsetPrev = getOffset(prev);\n-                int diff = offsetPrev - offsetLocal;\n-                if (instantAdjusted - prev <= diff) {\n-                    return offsetPrev;\n-                }\n-            }\n         }\n         return offsetAdjusted;\n     }\n"}
{"identifier": "Lang-38", "buggy_code": "    /**\n     * <p>Formats a <code>Calendar</code> object into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param calendar  the calendar to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        if (mTimeZoneForced) {\n            calendar = (Calendar) calendar.clone();\n            calendar.setTimeZone(mTimeZone);\n        }\n        return applyRules(calendar, buf);\n    }\n", "fixed_code": "    /**\n     * <p>Formats a <code>Calendar</code> object into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param calendar  the calendar to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n        if (mTimeZoneForced) {\n            calendar.getTime(); /// LANG-538\n            calendar = (Calendar) calendar.clone();\n            calendar.setTimeZone(mTimeZone);\n        }\n        return applyRules(calendar, buf);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Formats a <code>Calendar</code> object into the\n     * supplied <code>StringBuffer</code>.</p>\n     * \n     * @param calendar  the calendar to format\n     * @param buf  the buffer to format into\n     * @return the specified string buffer\n     */\n    public StringBuffer format(Calendar calendar, StringBuffer buf)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex d60af96..6b10a94 100644\n--- a/src/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -869,7 +869,6 @@ public class FastDateFormat extends Format {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n-            calendar.getTime(); /// LANG-538\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }\n"}
{"identifier": "Closure-60", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 43a296f..7f20c2e 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -105,8 +105,6 @@ public final class NodeUtil {\n         // ignoring side-effects\n         return TernaryValue.TRUE;\n \n-      case Token.VOID:\n-        return TernaryValue.FALSE;\n \n       default:\n         return getPureBooleanValue(n);\n@@ -135,10 +133,7 @@ public final class NodeUtil {\n         return TernaryValue.FALSE;\n \n       case Token.VOID:\n-        if (!mayHaveSideEffects(n.getFirstChild())) {\n           return TernaryValue.FALSE;\n-        }\n-        break;\n \n       case Token.NAME:\n         String name = n.getString();\n"}
{"identifier": "Closure-91", "buggy_code": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n\n            // object literal keys\n            pType == Token.STRING ||\n            pType == Token.NUMBER)) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n", "fixed_code": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n\n            // object literal keys\n            pType == Token.STRING ||\n            pType == Token.NUMBER)) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Since this pass reports errors only when a global\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex 91008e4..fa598d2 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,15 +112,6 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n-      Node gramps = parent.getParent();\n-      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n-        JSDocInfo maybeLends = gramps.getJSDocInfo();\n-        if (maybeLends != null &&\n-            maybeLends.getLendsName() != null &&\n-            maybeLends.getLendsName().endsWith(\".prototype\")) {\n-          return false;\n-        }\n-      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {\n"}
{"identifier": "JxPath-21", "buggy_code": "    /**\n     * If the property contains a collection, then the length of that\n     * collection, otherwise - 1.\n     * @return int length\n     */\n    public int getLength() {\n        return ValueUtils.getLength(getBaseValue());\n    }\n", "fixed_code": "    /**\n     * If the property contains a collection, then the length of that\n     * collection, otherwise - 1.\n     * @return int length\n     */\n    public int getLength() {\n        Object baseValue = getBaseValue();\n        return baseValue == null ? 1 : ValueUtils.getLength(baseValue);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * If the property contains a collection, then the length of that\n     * collection, otherwise - 1.\n     * @return int length\n     */\n    public int getLength()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\nindex f7e2525..52aa39a 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n@@ -149,8 +149,7 @@ public abstract class PropertyPointer extends NodePointer {\n      * @return int length\n      */\n     public int getLength() {\n-        Object baseValue = getBaseValue();\n-        return baseValue == null ? 1 : ValueUtils.getLength(baseValue);\n+        return ValueUtils.getLength(getBaseValue());\n     }\n \n     /**\n"}
{"identifier": "Math-6", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\nindex 927e17f..75c9757 100644\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n@@ -48,7 +48,7 @@ public abstract class BaseOptimizer<PAIR> {\n         this.checker = checker;\n \n         evaluations = new Incrementor(0, new MaxEvalCallback());\n-        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n+        iterations = new Incrementor(0, new MaxIterCallback());\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\nindex bd12b54..e010781 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n@@ -211,15 +211,16 @@ public class NonLinearConjugateGradientOptimizer\n         }\n \n         PointValuePair current = null;\n+        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n-            incrementIterationCount();\n+            ++iter;\n \n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n-                if (checker.converged(getIterations(), previous, current)) {\n+                if (checker.converged(iter, previous, current)) {\n                     // We have found an optimum.\n                     return current;\n                 }\n@@ -273,7 +274,7 @@ public class NonLinearConjugateGradientOptimizer\n             steepestDescent = newSteepestDescent;\n \n             // Compute conjugate search direction.\n-            if (getIterations() % n == 0 ||\n+            if (iter % n == 0 ||\n                 beta < 0) {\n                 // Break conjugation: reset search direction.\n                 searchDirection = steepestDescent.clone();\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\nindex fed67b1..0303041 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n@@ -385,7 +385,6 @@ public class CMAESOptimizer\n \n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n-            incrementIterationCount();\n \n             // Generate and evaluate lambda offspring\n             final RealMatrix arz = randn1(dimension, lambda);\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\nindex afe8d2f..9572820 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n@@ -188,8 +188,9 @@ public class PowellOptimizer\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n+        int iter = 0;\n         while (true) {\n-            incrementIterationCount();\n+            ++iter;\n \n             double fX = fVal;\n             double fX2 = 0;\n@@ -223,7 +224,7 @@ public class PowellOptimizer\n             final PointValuePair current = new PointValuePair(x, fVal);\n             if (!stop) { // User-defined stopping criteria.\n                 if (checker != null) {\n-                    stop = checker.converged(getIterations(), previous, current);\n+                    stop = checker.converged(iter, previous, current);\n                 }\n             }\n             if (stop) {\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\nindex 0dd644e..9ea2324 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n@@ -155,7 +155,7 @@ public class SimplexOptimizer extends MultivariateOptimizer {\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            if (getIterations() > 0) {\n+            if (iteration > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];\n@@ -172,7 +172,7 @@ public class SimplexOptimizer extends MultivariateOptimizer {\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n \n-            incrementIterationCount();\n+\t\t\t++iteration;\n         }\n     }\n \ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\nindex 844ed22..a2834f2 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n@@ -103,8 +103,9 @@ public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {\n \n         // iterate until convergence is reached\n         PointVectorValuePair current = null;\n+        int iter = 0;\n         for (boolean converged = false; !converged;) {\n-            incrementIterationCount();\n+            ++iter;\n \n             // evaluate the objective function and its jacobian\n             PointVectorValuePair previous = current;\n@@ -156,7 +157,7 @@ public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {\n \n             // Check convergence.\n             if (previous != null) {\n-                converged = checker.converged(getIterations(), previous, current);\n+                converged = checker.converged(iter, previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\nindex 4016131..ca2d138 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n@@ -319,10 +319,10 @@ public class LevenbergMarquardtOptimizer\n         // Outer loop.\n         lmPar = 0;\n         boolean firstIteration = true;\n+        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            incrementIterationCount();\n-\n+            ++iter;\n             final PointVectorValuePair previous = current;\n \n             // QR decomposition of the jacobian matrix\n@@ -486,7 +486,7 @@ public class LevenbergMarquardtOptimizer\n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n-                        if (checker.converged(getIterations(), previous, current)) {\n+                        if (checker.converged(iter, previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }\n"}
{"identifier": "JacksonDatabind-61", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\nindex 3d939ec2c..1f419e8b8 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n@@ -229,9 +229,6 @@ public class ObjectMapper\n         {\n             // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n             //  primitive types too, regardless\n-            if (t.isPrimitive()) {\n-                return false;\n-            }\n \n             switch (_appliesFor) {\n             case NON_CONCRETE_AND_ARRAYS:\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\nindex e5a3e4d47..ad9888f5b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n@@ -71,9 +71,6 @@ public class StdTypeResolverBuilder\n         if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n         // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n         //    regardless of setting\n-        if (baseType.isPrimitive()) {\n-            return null;\n-        }\n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n         switch (_includeAs) {\n         case WRAPPER_ARRAY:\n@@ -104,9 +101,6 @@ public class StdTypeResolverBuilder\n         if (_idType == JsonTypeInfo.Id.NONE) { return null; }\n         // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n         //    regardless of setting\n-        if (baseType.isPrimitive()) {\n-            return null;\n-        }\n \n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n \n"}
{"identifier": "Closure-31", "buggy_code": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n", "fixed_code": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d98be4a..b76bbb5 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,6 +1282,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n+          !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n"}
{"identifier": "Closure-163", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\nindex 1eca61c..10989ec 100644\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n@@ -198,50 +198,36 @@ class AnalyzePrototypeProperties implements CompilerPass {\n     //    given a name context. These contexts do not have scopes.\n     private Stack<NameContext> symbolStack = new Stack<NameContext>();\n \n+    private ProcessProperties() {\n+      symbolStack.push(new NameContext(globalNode));\n+    }\n     @Override\n     public void enterScope(NodeTraversal t) {\n-      Node n = t.getCurrentNode();\n-      if (n.isFunction()) {\n-        String propName = getPrototypePropertyNameFromRValue(n);\n-        if (propName != null) {\n-          symbolStack.push(\n-              new NameContext(\n-                  getNameInfoForName(propName, PROPERTY),\n-                  t.getScope()));\n-        } else if (isGlobalFunctionDeclaration(t, n)) {\n-          Node parent = n.getParent();\n-          String name = parent.isName() ?\n-              parent.getString() /* VAR */ :\n-              n.getFirstChild().getString() /* named function */;\n-          symbolStack.push(\n-              new NameContext(getNameInfoForName(name, VAR), t.getScope()));\n-        } else {\n+      symbolStack.peek().scope = t.getScope();\n           // NOTE(nicksantos): We use the same anonymous node for all\n           // functions that do not have reasonable names. I can't remember\n           // at the moment why we do this. I think it's because anonymous\n           // nodes can never have in-edges. They're just there as a placeholder\n           // for scope information, and do not matter in the edge propagation.\n-          symbolStack.push(new NameContext(anonymousNode, t.getScope()));\n-        }\n-      } else {\n-        Preconditions.checkState(t.inGlobalScope());\n-        symbolStack.push(new NameContext(globalNode, t.getScope()));\n-      }\n     }\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n-      symbolStack.pop();\n     }\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       // Process prototype assignments to non-functions.\n-      String propName = processNonFunctionPrototypeAssign(n, parent);\n-      if (propName != null) {\n-        symbolStack.push(\n-            new NameContext(\n-                getNameInfoForName(propName, PROPERTY), null));\n+      if (isPrototypePropertyAssign(n)) {\n+        symbolStack.push(new NameContext(getNameInfoForName(\n+                n.getFirstChild().getLastChild().getString(), PROPERTY)));\n+      } else if (isGlobalFunctionDeclaration(t, n)) {\n+        String name = parent.isName() ?\n+            parent.getString() /* VAR */ :\n+            n.getFirstChild().getString() /* named function */;\n+        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n+      } else if (n.isFunction()) {\n+        symbolStack.push(new NameContext(anonymousNode));\n       }\n       return true;\n     }\n@@ -251,35 +237,23 @@ class AnalyzePrototypeProperties implements CompilerPass {\n       if (n.isGetProp()) {\n         String propName = n.getFirstChild().getNext().getString();\n \n-        if (n.isQualifiedName()) {\n           if (propName.equals(\"prototype\")) {\n-            if (processPrototypeRef(t, n)) {\n-              return;\n-            }\n+          processPrototypeParent(t, parent);\n           } else if (compiler.getCodingConvention().isExported(propName)) {\n             addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-            return;\n           } else {\n             // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            if (n.getParent().isAssign() && n.getNext() != null) {\n-              String rValueName = getPrototypePropertyNameFromRValue(n);\n-              if (rValueName != null) {\n-                return;\n-              }\n-            }\n-          }\n+          addSymbolUse(propName, t.getModule(), PROPERTY);\n         }\n \n-        addSymbolUse(propName, t.getModule(), PROPERTY);\n-      } else if (n.isObjectLit()) {\n+      } else if (n.isObjectLit() &&\n         // Make sure that we're not handling object literals being\n         // assigned to a prototype, as in:\n         // Foo.prototype = {bar: 3, baz: 5};\n-        String lValueName = NodeUtil.getBestLValueName(\n-            NodeUtil.getBestLValue(n));\n-        if (lValueName != null && lValueName.endsWith(\".prototype\")) {\n-          return;\n-        }\n+          !(parent.isAssign() &&\n+            parent.getFirstChild().isGetProp() &&\n+            parent.getFirstChild().getLastChild().getString().equals(\n+                \"prototype\"))) {\n \n         // var x = {a: 1, b: 2}\n         // should count as a use of property a and b.\n@@ -300,7 +274,8 @@ class AnalyzePrototypeProperties implements CompilerPass {\n             if (var.getInitialValue() != null &&\n                 var.getInitialValue().isFunction()) {\n               if (t.inGlobalScope()) {\n-                if (!processGlobalFunctionDeclaration(t, n, var)) {\n+                if (!processGlobalFunctionDeclaration(t, n, parent,\n+                        parent.getParent())) {\n                   addGlobalUseOfSymbol(name, t.getModule(), VAR);\n                 }\n               } else {\n@@ -325,7 +300,9 @@ class AnalyzePrototypeProperties implements CompilerPass {\n       }\n \n       // Process prototype assignments to non-functions.\n-      if (processNonFunctionPrototypeAssign(n, parent) != null) {\n+      if (isPrototypePropertyAssign(n) ||\n+          isGlobalFunctionDeclaration(t, n) ||\n+          n.isFunction()) {\n         symbolStack.pop();\n       }\n     }\n@@ -349,12 +326,6 @@ class AnalyzePrototypeProperties implements CompilerPass {\n      * If this is a non-function prototype assign, return the prop name.\n      * Otherwise, return null.\n      */\n-    private String processNonFunctionPrototypeAssign(Node n, Node parent) {\n-      if (isAssignRValue(n, parent) && !n.isFunction()) {\n-        return getPrototypePropertyNameFromRValue(n);\n-      }\n-      return null;\n-    }\n \n     /**\n      * Determines whether {@code n} is the FUNCTION node in a global function\n@@ -363,22 +334,23 @@ class AnalyzePrototypeProperties implements CompilerPass {\n     private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n       // Make sure we're either in the global scope, or the function\n       // we're looking at is the root of the current local scope.\n-      Scope s = t.getScope();\n-      if (!(s.isGlobal() ||\n-            s.getDepth() == 1 && s.getRootNode() == n)) {\n-        return false;\n-      }\n \n-      return NodeUtil.isFunctionDeclaration(n) ||\n-          n.isFunction() && n.getParent().isName();\n+      return t.inGlobalScope() &&\n+          (NodeUtil.isFunctionDeclaration(n) ||\n+           n.isFunction() &&\n+           n.getParent().isName());\n     }\n \n     /**\n      * Returns true if this is the r-value of an assignment.\n      */\n-    private boolean isAssignRValue(Node n, Node parent) {\n-      return parent != null && parent.isAssign() && parent.getFirstChild() != n;\n-    }\n+    private boolean isPrototypePropertyAssign(Node assign) {\n+      Node n = assign.getFirstChild();\n+      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n+          && n.isGetProp()\n+          && assign.getParent().isExprResult()) {\n+        boolean isChainedProperty =\n+            n.getFirstChild().isGetProp();\n \n     /**\n      * Returns the name of a prototype property being assigned to this r-value.\n@@ -387,32 +359,18 @@ class AnalyzePrototypeProperties implements CompilerPass {\n      * the R-value is used in multiple expressions (i.e., if there's\n      * a prototype property assignment in a more complex expression).\n      */\n-    private String getPrototypePropertyNameFromRValue(Node rValue) {\n-      Node lValue = NodeUtil.getBestLValue(rValue);\n-      if (lValue == null ||\n-          lValue.getParent() == null ||\n-          lValue.getParent().getParent() == null ||\n-          !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) ||\n-            NodeUtil.isExprAssign(lValue.getParent().getParent()))) {\n-        return null;\n-      }\n+        if (isChainedProperty) {\n+          Node child = n.getFirstChild().getFirstChild().getNext();\n \n-      String lValueName =\n-          NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue));\n-      if (lValueName == null) {\n-        return null;\n-      }\n-      int lastDot = lValueName.lastIndexOf('.');\n-      if (lastDot == -1) {\n-        return null;\n+          if (child.isString() &&\n+              child.getString().equals(\"prototype\")) {\n+            return true;\n+          }\n+        }\n       }\n \n-      String firstPart = lValueName.substring(0, lastDot);\n-      if (!firstPart.endsWith(\".prototype\")) {\n-        return null;\n-      }\n \n-      return lValueName.substring(lastDot + 1);\n+      return false;\n     }\n \n     /**\n@@ -420,9 +378,8 @@ class AnalyzePrototypeProperties implements CompilerPass {\n      * If it is, record it and return true. Otherwise, return false.\n      */\n     private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n-        Node nameNode, Var v) {\n+        Node nameNode, Node parent, Node gramps) {\n       Node firstChild = nameNode.getFirstChild();\n-      Node parent = nameNode.getParent();\n \n       if (// Check for a named FUNCTION.\n           isGlobalFunctionDeclaration(t, parent) ||\n@@ -431,7 +388,7 @@ class AnalyzePrototypeProperties implements CompilerPass {\n           isGlobalFunctionDeclaration(t, firstChild)) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(\n-            new GlobalFunction(nameNode, v, t.getModule()));\n+            new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n \n         // If the function name is exported, we should create an edge here\n         // so that it's never removed.\n@@ -451,10 +408,8 @@ class AnalyzePrototypeProperties implements CompilerPass {\n      * under an assignment (in the case of Foo.prototype = ...).\n      * @return True if a declaration was added.\n      */\n-    private boolean processPrototypeRef(NodeTraversal t, Node ref) {\n-      Node root = NodeUtil.getRootOfQualifiedName(ref);\n+    private void processPrototypeParent(NodeTraversal t, Node n) {\n \n-      Node n = ref.getParent();\n       switch (n.getType()) {\n         // Foo.prototype.getBar = function() { ... }\n         case Token.GETPROP:\n@@ -468,10 +423,8 @@ class AnalyzePrototypeProperties implements CompilerPass {\n             String name = dest.getString();\n             Property prop = new AssignmentProperty(\n                 grandParent,\n-                t.getScope().getVar(root.getString()),\n                 t.getModule());\n             getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n-            return true;\n           }\n           break;\n \n@@ -485,15 +438,12 @@ class AnalyzePrototypeProperties implements CompilerPass {\n               String name = key.getString();\n               Property prop = new LiteralProperty(\n                   key, key.getFirstChild(), map, n,\n-                  t.getScope().getVar(root.getString()),\n                   t.getModule());\n               getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n             }\n-            return true;\n           }\n           break;\n       }\n-      return false;\n     }\n \n     private void addGlobalUseOfSymbol(String name, JSModule module,\n@@ -545,7 +495,6 @@ class AnalyzePrototypeProperties implements CompilerPass {\n     /**\n      * The variable for the root of this symbol.\n      */\n-    Var getRootVar();\n \n     /**\n      * Returns the module where this appears.\n@@ -563,25 +512,18 @@ class AnalyzePrototypeProperties implements CompilerPass {\n    */\n   class GlobalFunction implements Symbol {\n     private final Node nameNode;\n-    private final Var var;\n     private final JSModule module;\n \n-    GlobalFunction(Node nameNode, Var var, JSModule module) {\n-      Node parent = nameNode.getParent();\n+    GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n       Preconditions.checkState(\n           parent.isVar() ||\n           NodeUtil.isFunctionDeclaration(parent));\n       this.nameNode = nameNode;\n-      this.var = var;\n       this.module = module;\n     }\n \n     @Override\n-    public Var getRootVar() {\n-      return var;\n-    }\n \n-    @Override\n     public void remove() {\n       Node parent = nameNode.getParent();\n       if (parent.isFunction() || parent.hasOneChild()) {\n@@ -630,24 +572,18 @@ class AnalyzePrototypeProperties implements CompilerPass {\n    */\n   static class AssignmentProperty implements Property {\n     private final Node exprNode;\n-    private final Var rootVar;\n     private final JSModule module;\n \n     /**\n      * @param node An EXPR node.\n      */\n-    AssignmentProperty(Node node, Var rootVar, JSModule module) {\n+    AssignmentProperty(Node node, JSModule module) {\n       this.exprNode = node;\n-      this.rootVar = rootVar;\n       this.module = module;\n     }\n \n     @Override\n-    public Var getRootVar() {\n-      return rootVar;\n-    }\n \n-    @Override\n     public void remove() {\n       NodeUtil.removeChild(exprNode.getParent(), exprNode);\n     }\n@@ -683,25 +619,19 @@ class AnalyzePrototypeProperties implements CompilerPass {\n     private final Node value;\n     private final Node map;\n     private final Node assign;\n-    private final Var rootVar;\n     private final JSModule module;\n \n     LiteralProperty(Node key, Node value, Node map, Node assign,\n-        Var rootVar, JSModule module) {\n+        JSModule module) {\n       this.key = key;\n       this.value = value;\n       this.map = map;\n       this.assign = assign;\n-      this.rootVar = rootVar;\n       this.module = module;\n     }\n \n     @Override\n-    public Var getRootVar() {\n-      return rootVar;\n-    }\n \n-    @Override\n     public void remove() {\n       map.removeChild(key);\n     }\n@@ -731,11 +661,10 @@ class AnalyzePrototypeProperties implements CompilerPass {\n \n     // If this is a function context, then scope will be the scope of the\n     // corresponding function. Otherwise, it will be null.\n-    final Scope scope;\n+    Scope scope;\n \n-    NameContext(NameInfo name, Scope scope) {\n+    NameContext(NameInfo name) {\n       this.name = name;\n-      this.scope = scope;\n     }\n   }\n \ndiff --git a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\nindex d52a390..1bd14b3 100644\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n@@ -138,9 +138,6 @@ class CrossModuleMethodMotion implements CompilerPass {\n         // So if we move a prototype method into a deeper module, we must\n         // replace it with a stub function so that it preserves its original\n         // behavior.\n-        if (!(prop.getRootVar() != null && prop.getRootVar().isGlobal())) {\n-          continue;\n-        }\n \n         Node value = prop.getValue();\n         if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n"}
{"identifier": "Jsoup-22", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex dc352dc..fd2b542 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -431,15 +431,8 @@ public class Element extends Node {\n      * @return sibling elements\n      */\n     public Elements siblingElements() {\n-        if (parentNode == null)\n-            return new Elements(0);\n \n-        List<Element> elements = parent().children();\n-        Elements siblings = new Elements(elements.size() - 1);\n-        for (Element el: elements)\n-            if (el != this)\n-                siblings.add(el);\n-        return siblings;\n+        return parent().children();\n     }\n \n     /**\n@@ -451,7 +444,6 @@ public class Element extends Node {\n      * @see #previousElementSibling()\n      */\n     public Element nextElementSibling() {\n-        if (parentNode == null) return null;\n         List<Element> siblings = parent().children();\n         Integer index = indexInList(this, siblings);\n         Validate.notNull(index);\n@@ -467,7 +459,6 @@ public class Element extends Node {\n      * @see #nextElementSibling()\n      */\n     public Element previousElementSibling() {\n-        if (parentNode == null) return null;\n         List<Element> siblings = parent().children();\n         Integer index = indexInList(this, siblings);\n         Validate.notNull(index);\ndiff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java\nindex c0640cd..5537db3 100644\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n@@ -441,15 +441,8 @@ public abstract class Node implements Cloneable {\n      @return node siblings. If the node has no parent, returns an empty list.\n      */\n     public List<Node> siblingNodes() {\n-        if (parentNode == null)\n-            return Collections.emptyList();\n \n-        List<Node> nodes = parentNode.childNodes;\n-        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n-        for (Node node: nodes)\n-            if (node != this)\n-                siblings.add(node);\n-        return siblings;\n+        return parent().childNodes();\n     }\n \n     /**\n@@ -474,8 +467,6 @@ public abstract class Node implements Cloneable {\n      @return the previous sibling, or null if this is the first sibling\n      */\n     public Node previousSibling() {\n-        if (parentNode == null)\n-            return null; // root\n \n         List<Node> siblings = parentNode.childNodes;\n         Integer index = siblingIndex();\ndiff --git a/src/main/java/org/jsoup/select/Elements.java b/src/main/java/org/jsoup/select/Elements.java\nindex 7f8f66a..a10ae3b 100644\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n@@ -19,9 +19,6 @@ public class Elements implements List<Element>, Cloneable {\n         contents = new ArrayList<Element>();\n     }\n \n-    public Elements(int initialCapacity) {\n-        contents = new ArrayList<Element>(initialCapacity);\n-    }\n \n     public Elements(Collection<Element> elements) {\n         contents = new ArrayList<Element>(elements);\n"}
{"identifier": "Csv-3", "buggy_code": "    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n                return c;\n            // indicate unexpected char - available from in.getLastChar()\n        }\n    }\n", "fixed_code": "    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) {\n                return c;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/Lexer.java b/src/main/java/org/apache/commons/csv/Lexer.java\nindex af99745..0a6a090 100644\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n@@ -108,11 +108,8 @@ abstract class Lexer {\n             throw new IOException(\"EOF whilst processing escape sequence\");\n         default:\n             // Now check for meta-characters\n-            if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) {\n                 return c;\n-            }\n             // indicate unexpected char - available from in.getLastChar()\n-            return END_OF_STREAM;\n         }\n     }\n \n"}
{"identifier": "Mockito-24", "buggy_code": "    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n", "fixed_code": "    /* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = mockUtil.getMockName(mock);\n            if (name.isDefault()) {\n                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/* (non-Javadoc)\n     * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     */\n    public Object answer(InvocationOnMock invocation)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\nindex d19fcda..4c00f50 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n@@ -73,7 +73,7 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n+            return 1;\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n"}
{"identifier": "Math-34", "buggy_code": "    /**\n     * Returns an iterator over the unmodifiable list of chromosomes.\n     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n     *\n     * @return chromosome iterator\n     */\n    public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n    }\n", "fixed_code": "    /**\n     * Returns an iterator over the unmodifiable list of chromosomes.\n     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n     *\n     * @return chromosome iterator\n     */\n    public Iterator<Chromosome> iterator() {\n        return getChromosomes().iterator();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns an iterator over the unmodifiable list of chromosomes.\n     * <p>Any call to\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 3f3919c..1eb0053 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -206,6 +206,6 @@ public abstract class ListPopulation implements Population {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return getChromosomes().iterator();\n+        return chromosomes.iterator();\n     }\n }\n"}
{"identifier": "JacksonDatabind-57", "buggy_code": "    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),\n                true));\n    }\n", "fixed_code": "    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n                true));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Overloaded version of\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\nindex 2279c1fc1..10fddc4d6 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n@@ -1438,7 +1438,7 @@ public class ObjectReader\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n+        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n                 true));\n     }\n \n"}
{"identifier": "Math-56", "buggy_code": "    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        int idx = 1;\n        while (count < index) {\n            count += idx;\n            ++idx;\n        }\n        --idx;\n        indices[last] = idx;\n\n        return indices;\n    }\n", "fixed_code": "    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        indices[last] = index - count;\n\n        return indices;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\nindex fb0614e..56c9ffe 100644\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n@@ -234,7 +234,13 @@ public class MultidimensionalCounter implements Iterable<Integer> {\n             indices[i] = idx;\n         }\n \n-        indices[last] = index - count;\n+        int idx = 1;\n+        while (count < index) {\n+            count += idx;\n+            ++idx;\n+        }\n+        --idx;\n+        indices[last] = idx;\n \n         return indices;\n     }\n"}
{"identifier": "Closure-48", "buggy_code": "    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      // NOTE(nicksantos): Determining whether a property is declared or not\n      // is really really obnoxious.\n      //\n      // The problem is that there are two (equally valid) coding styles:\n      //\n      // (function() {\n      //   /* The authoritative definition of goog.bar. */\n      //   goog.bar = function() {};\n      // })();\n      //\n      // function f() {\n      //   goog.bar();\n      //   /* Reset goog.bar to a no-op. */\n      //   goog.bar = function() {};\n      // }\n      //\n      // In a dynamic language with first-class functions, it's very difficult\n      // to know which one the user intended without looking at lots of\n      // contextual information (the second example demonstrates a small case\n      // of this, but there are some really pathological cases as well).\n      //\n      // The current algorithm checks if either the declaration has\n      // jsdoc type information, or @const with a known type,\n      // or a function literal with a name we haven't seen before.\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n", "fixed_code": "    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      // NOTE(nicksantos): Determining whether a property is declared or not\n      // is really really obnoxious.\n      //\n      // The problem is that there are two (equally valid) coding styles:\n      //\n      // (function() {\n      //   /* The authoritative definition of goog.bar. */\n      //   goog.bar = function() {};\n      // })();\n      //\n      // function f() {\n      //   goog.bar();\n      //   /* Reset goog.bar to a no-op. */\n      //   goog.bar = function() {};\n      // }\n      //\n      // In a dynamic language with first-class functions, it's very difficult\n      // to know which one the user intended without looking at lots of\n      // contextual information (the second example demonstrates a small case\n      // of this, but there are some really pathological cases as well).\n      //\n      // The current algorithm checks if either the declaration has\n      // jsdoc type information, or @const with a known type,\n      // or a function literal with a name we haven't seen before.\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        // Determining declaration for #2\n        if (info != null) {\n          inferred = false;\n        } else if (!scope.isDeclared(qName, false) &&\n                   n.isUnscopedQualifiedName()) {\n          inferred = false;\n        }\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 09aba12..3fb4813 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1518,14 +1518,11 @@ final class TypedScopeCreator implements ScopeCreator {\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n+      if (inferred) {\n         // Determining declaration for #2\n-        if (info != null) {\n-          inferred = false;\n-        } else if (!scope.isDeclared(qName, false) &&\n-                   n.isUnscopedQualifiedName()) {\n-          inferred = false;\n-        }\n+        inferred = !(rhsValue != null &&\n+            rhsValue.isFunction() &&\n+            (info != null || !scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n"}
{"identifier": "Closure-70", "buggy_code": "    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments\n", "fixed_code": "    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex aa7e245..210bb66 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), false);\n+                  jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n"}
{"identifier": "Math-62", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex 952e565..1200544 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -143,7 +143,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n-        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+        return optimize(f, goal, min, max, 0);\n     }\n \n     /** {@inheritDoc} */\n@@ -157,8 +157,9 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n             try {\n-                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, min, max, s);\n+                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n+                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n"}
{"identifier": "Cli-11", "buggy_code": "    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && (option.getArgName() != null))\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n", "fixed_code": "    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 9a841fd..183cae3 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -629,7 +629,7 @@ public class HelpFormatter {\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && option.hasArgName())\n+        if (option.hasArg() && (option.getArgName() != null))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n"}
{"identifier": "Cli-27", "buggy_code": "    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getOpt()))\n        {\n            selected = option.getOpt();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n", "fixed_code": "    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getKey()))\n        {\n            selected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/OptionGroup.java b/src/java/org/apache/commons/cli/OptionGroup.java\nindex 67cd5e2..dd474cc 100644\n--- a/src/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/java/org/apache/commons/cli/OptionGroup.java\n@@ -95,9 +95,9 @@ public class OptionGroup implements Serializable\n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getKey()))\n+        if (selected == null || selected.equals(option.getOpt()))\n         {\n-            selected = option.getKey();\n+            selected = option.getOpt();\n         }\n         else\n         {\n"}
{"identifier": "Math-21", "buggy_code": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n\n        int[] swap  = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0;\n        for (boolean loop = true; loop;) {\n\n            // find maximal diagonal element\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\n\n            // swap elements\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            // check diagonal element\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n\n                // check remaining diagonal elements\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        // there is at least one sufficiently negative diagonal element,\n                        // the symmetric positive semidefinite matrix is wrong\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                    }\n                }\n\n                // all remaining diagonal elements are close to zero, we consider we have\n                // found the rank of the symmetric positive semidefinite matrix\n                ++r;\n                loop = false;\n\n            } else {\n\n                // transform the matrix\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 / sqrt;\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i];\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e;\n                    c[ii][ii] -= e * e;\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n\n                // prepare next iteration\n                loop = ++r < order;\n            }\n        }\n\n        // build the root matrix\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n\n    }\n", "fixed_code": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0;\n        for (boolean loop = true; loop;) {\n\n            // find maximal diagonal element\n            int swapR = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isr = index[swapR];\n                if (c[ii][ii] > c[isr][isr]) {\n                    swapR = i;\n                }\n            }\n\n\n            // swap elements\n            if (swapR != r) {\n                final int tmpIndex    = index[r];\n                index[r]              = index[swapR];\n                index[swapR]          = tmpIndex;\n                final double[] tmpRow = b[r];\n                b[r]                  = b[swapR];\n                b[swapR]              = tmpRow;\n            }\n\n            // check diagonal element\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n\n                // check remaining diagonal elements\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        // there is at least one sufficiently negative diagonal element,\n                        // the symmetric positive semidefinite matrix is wrong\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                    }\n                }\n\n                // all remaining diagonal elements are close to zero, we consider we have\n                // found the rank of the symmetric positive semidefinite matrix\n                ++r;\n                loop = false;\n\n            } else {\n\n                // transform the matrix\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 / sqrt;\n                final double inverse2 = 1 / c[ir][ir];\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i];\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e;\n                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n\n                // prepare next iteration\n                loop = ++r < order;\n            }\n        }\n\n        // build the root matrix\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex aba7b98..04488e5 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n"}
{"identifier": "Chart-11", "buggy_code": "    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n", "fixed_code": "    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex f49ecb5..31aa6c6 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p2.getPathIterator(null);\n+        PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n"}
{"identifier": "Cli-9", "buggy_code": "    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Throws a\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex cf53a90..dbace06 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -317,10 +317,9 @@ public abstract class Parser implements CommandLineParser {\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n-                buff.append(\", \");\n             }\n \n-            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n+            throw new MissingOptionException(buff.toString());\n         }\n     }\n \n"}
{"identifier": "Jsoup-13", "buggy_code": "    /**\n     * Test if this element has an attribute.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        return attributes.hasKey(attributeKey);\n    }\n", "fixed_code": "    /**\n     * Test if this element has an attribute.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n\n        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n            String key = attributeKey.substring(\"abs:\".length());\n            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                return true;\n        }\n        return attributes.hasKey(attributeKey);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Test if this element has an attribute.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java\nindex 9456fc4..3d0bf2e 100644\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n@@ -104,11 +104,6 @@ public abstract class Node implements Cloneable {\n     public boolean hasAttr(String attributeKey) {\n         Validate.notNull(attributeKey);\n \n-        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n-            String key = attributeKey.substring(\"abs:\".length());\n-            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n-                return true;\n-        }\n         return attributes.hasKey(attributeKey);\n     }\n \n"}
{"identifier": "Codec-13", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/codec/binary/CharSequenceUtils.java b/src/main/java/org/apache/commons/codec/binary/CharSequenceUtils.java\ndeleted file mode 100644\nindex fe20eb02..00000000\n--- a/src/main/java/org/apache/commons/codec/binary/CharSequenceUtils.java\n+++ /dev/null\n@@ -1,63 +0,0 @@\n-package org.apache.commons.codec.binary;\n-\n-/**\n- * <p>\n- * Operations on {@link CharSequence} that are {@code null} safe.\n- * </p>\n- * <p>\n- * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release).\n- * </p>\n- * \n- * @see CharSequence\n- * @since 1.10\n- */\n-public class CharSequenceUtils {\n-\n-    /**\n-     * Green implementation of regionMatches.\n-     * \n-     * @param cs\n-     *            the {@code CharSequence} to be processed\n-     * @param ignoreCase\n-     *            whether or not to be case insensitive\n-     * @param thisStart\n-     *            the index to start on the {@code cs} CharSequence\n-     * @param substring\n-     *            the {@code CharSequence} to be looked for\n-     * @param start\n-     *            the index to start on the {@code substring} CharSequence\n-     * @param length\n-     *            character length of the region\n-     * @return whether the region matched\n-     */\n-    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\n-            final CharSequence substring, final int start, final int length) {\n-        if (cs instanceof String && substring instanceof String) {\n-            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n-        }\n-        int index1 = thisStart;\n-        int index2 = start;\n-        int tmpLen = length;\n-\n-        while (tmpLen-- > 0) {\n-            char c1 = cs.charAt(index1++);\n-            char c2 = substring.charAt(index2++);\n-\n-            if (c1 == c2) {\n-                continue;\n-            }\n-\n-            if (!ignoreCase) {\n-                return false;\n-            }\n-\n-            // The same check as in String.regionMatches():\n-            if (Character.toUpperCase(c1) != Character.toUpperCase(c2)\n-                    && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-}\ndiff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex 8f1f57fa..b3c399f5 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -67,18 +67,6 @@ public class StringUtils {\n      * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n      * @since 1.10\n      */\n-    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n-        if (cs1 == cs2) {\n-            return true;\n-        }\n-        if (cs1 == null || cs2 == null) {\n-            return false;\n-        }\n-        if (cs1 instanceof String && cs2 instanceof String) {\n-            return cs1.equals(cs2);\n-        }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n-    }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\ndiff --git a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\nindex 6ccd3f27..125503ac 100644\n--- a/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\n@@ -19,7 +19,6 @@ package org.apache.commons.codec.language;\n \n import org.apache.commons.codec.EncoderException;\n import org.apache.commons.codec.StringEncoder;\n-import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence\n@@ -242,7 +241,7 @@ public class DoubleMetaphone implements StringEncoder {\n      *          {@code false} otherwise.\n      */\n     public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\n-        return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));\n+        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\n     }\n \n     /**\n"}
{"identifier": "Math-42", "buggy_code": "    /**\n     * Get the current solution.\n     *\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n          if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n", "fixed_code": "    /**\n     * Get the current solution.\n     *\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Get the current solution.\n     *\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex d96c916..02c22b5 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -407,12 +407,10 @@ class SimplexTableau implements Serializable {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n-          if (basicRow != null && basicRow == 0) {\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-              coefficients[i] = 0;\n-          } else if (basicRows.contains(basicRow)) {\n+          if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n"}
{"identifier": "Math-10", "buggy_code": "    /** Compute two arguments arc tangent of a derivative structure.\n     * @param y array holding the first operand\n     * @param yOffset offset of the first operand in its array\n     * @param x array holding the second operand\n     * @param xOffset offset of the second operand in its array\n     * @param result array where result must be stored (for\n     * two arguments arc tangent the result array <em>cannot</em>\n     * be the input array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void atan2(final double[] y, final int yOffset,\n                      final double[] x, final int xOffset,\n                      final double[] result, final int resultOffset) {\n\n        // compute r = sqrt(x^2+y^2)\n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n        double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n\n        if (x[xOffset] >= 0) {\n\n            // compute atan2(y, x) = 2 atan(y / (r + x))\n            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n            for (int i = 0; i < tmp2.length; ++i) {\n                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n            }\n\n        } else {\n\n            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n            result[resultOffset] =\n                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n            for (int i = 1; i < tmp2.length; ++i) {\n                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n            }\n\n        }\n\n        // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n\n    }\n", "fixed_code": "    /** Compute two arguments arc tangent of a derivative structure.\n     * @param y array holding the first operand\n     * @param yOffset offset of the first operand in its array\n     * @param x array holding the second operand\n     * @param xOffset offset of the second operand in its array\n     * @param result array where result must be stored (for\n     * two arguments arc tangent the result array <em>cannot</em>\n     * be the input array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void atan2(final double[] y, final int yOffset,\n                      final double[] x, final int xOffset,\n                      final double[] result, final int resultOffset) {\n\n        // compute r = sqrt(x^2+y^2)\n        double[] tmp1 = new double[getSize()];\n        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n        double[] tmp2 = new double[getSize()];\n        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n\n        if (x[xOffset] >= 0) {\n\n            // compute atan2(y, x) = 2 atan(y / (r + x))\n            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n            for (int i = 0; i < tmp2.length; ++i) {\n                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n            }\n\n        } else {\n\n            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n            result[resultOffset] =\n                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n            for (int i = 1; i < tmp2.length; ++i) {\n                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n            }\n\n        }\n\n        // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Compute two arguments arc tangent of a derivative structure.\n     * @param y array holding the first operand\n     * @param yOffset offset of the first operand in its array\n     * @param x array holding the second operand\n     * @param xOffset offset of the second operand in its array\n     * @param result array where result must be stored (for\n     * two arguments arc tangent the result array <em>cannot</em>\n     * be the input array)\n     * @param resultOffset offset of the result in its array\n     */\n    public void atan2(final double[] y, final int yOffset,\n                      final double[] x, final int xOffset,\n                      final double[] result, final int resultOffset)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\nindex d5a3c18..bf6dd65 100644\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n@@ -1416,7 +1416,6 @@ public class DSCompiler {\n         }\n \n         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n-        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n \n     }\n \n"}
{"identifier": "Jsoup-84", "buggy_code": "        public void head(org.jsoup.nodes.Node source, int depth) {\n            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n            if (source instanceof org.jsoup.nodes.Element) {\n                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n                String prefix = updateNamespaces(sourceEl);\n                String namespace = namespacesStack.peek().get(prefix);\n                String tagName = sourceEl.tagName();\n\n                Element el =\n                    doc.createElementNS(namespace, tagName);\n                copyAttributes(sourceEl, el);\n                if (dest == null) { // sets up the root\n                    doc.appendChild(el);\n                } else {\n                    dest.appendChild(el);\n                }\n                dest = el; // descend\n            } else if (source instanceof org.jsoup.nodes.TextNode) {\n                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n                Text text = doc.createTextNode(sourceText.getWholeText());\n                dest.appendChild(text);\n            } else if (source instanceof org.jsoup.nodes.Comment) {\n                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n                Comment comment = doc.createComment(sourceComment.getData());\n                dest.appendChild(comment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                dest.appendChild(node);\n            } else {\n                // unhandled\n            }\n        }\n", "fixed_code": "        public void head(org.jsoup.nodes.Node source, int depth) {\n            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n            if (source instanceof org.jsoup.nodes.Element) {\n                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n                String prefix = updateNamespaces(sourceEl);\n                String namespace = namespacesStack.peek().get(prefix);\n                String tagName = sourceEl.tagName();\n\n                Element el = namespace == null && tagName.contains(\":\") ?\n                    doc.createElementNS(\"\", tagName) : // doesn't have a real namespace defined\n                    doc.createElementNS(namespace, tagName);\n                copyAttributes(sourceEl, el);\n                if (dest == null) { // sets up the root\n                    doc.appendChild(el);\n                } else {\n                    dest.appendChild(el);\n                }\n                dest = el; // descend\n            } else if (source instanceof org.jsoup.nodes.TextNode) {\n                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n                Text text = doc.createTextNode(sourceText.getWholeText());\n                dest.appendChild(text);\n            } else if (source instanceof org.jsoup.nodes.Comment) {\n                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n                Comment comment = doc.createComment(sourceComment.getData());\n                dest.appendChild(comment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                dest.appendChild(node);\n            } else {\n                // unhandled\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic void head(org.jsoup.nodes.Node source, int depth)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/W3CDom.java b/src/main/java/org/jsoup/helper/W3CDom.java\nindex 6847574..7b309a3 100644\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n@@ -88,8 +88,7 @@ public class W3CDom {\n                 String namespace = namespacesStack.peek().get(prefix);\n                 String tagName = sourceEl.tagName();\n \n-                Element el = namespace == null && tagName.contains(\":\") ?\n-                    doc.createElementNS(\"\", tagName) : // doesn't have a real namespace defined\n+                Element el = \n                     doc.createElementNS(namespace, tagName);\n                 copyAttributes(sourceEl, el);\n                 if (dest == null) { // sets up the root\n"}
{"identifier": "Jsoup-46", "buggy_code": "    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n", "fixed_code": "    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex ad80489..6ccb84e 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -115,7 +115,7 @@ public class Entities {\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(\"&#xa0;\");\n+                            accum.append(c);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n"}
{"identifier": "Gson-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\nindex f66ac157..17ed0ff2 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n@@ -339,12 +339,7 @@ public final class $Gson$Types {\n     while (true) {\n       if (toResolve instanceof TypeVariable) {\n         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n-        if (visitedTypeVariables.contains(typeVariable)) {\n           // cannot reduce due to infinite recursion\n-          return toResolve;\n-        } else {\n-          visitedTypeVariables.add(typeVariable);\n-        }\n         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n         if (toResolve == typeVariable) {\n           return toResolve;\n"}
{"identifier": "Math-98", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\nindex 919a5ba..7cd61cb 100644\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n@@ -988,7 +988,7 @@ public class BigMatrixImpl implements BigMatrix, Serializable {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[nRows];\n+        final BigDecimal[] out = new BigDecimal[v.length];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\ndiff --git a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\nindex 3a717ff..7910644 100644\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n@@ -776,7 +776,7 @@ public class RealMatrixImpl implements RealMatrix, Serializable {\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        final double[] out = new double[nRows];\n+        final double[] out = new double[v.length];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;\n"}
{"identifier": "JacksonDatabind-89", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex 9301c666a..1ae69f6e5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -62,13 +62,7 @@ public class BeanDeserializerFactory\n         // [databind#1680]: may or may not be problem, take no chance\n         s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n         // [databind#1737]; JDK provided\n-        s.add(\"java.util.logging.FileHandler\");\n-        s.add(\"java.rmi.server.UnicastRemoteObject\");\n         // [databind#1737]; 3rd party\n-        s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\");\n-        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n-        s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n-        s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n \n         DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n     }\n"}
{"identifier": "Lang-57", "buggy_code": "    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }\n", "fixed_code": "    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex 139d9a7..ceb886e 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return availableLocaleList().contains(locale);\n+        return cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n"}
{"identifier": "Jsoup-50", "buggy_code": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // look for BOM - overrides any other header or input\n\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n", "fixed_code": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // look for BOM - overrides any other header or input\n        byteData.mark();\n        byte[] bom = new byte[4];\n        byteData.get(bom);\n        byteData.rewind();\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n            charsetName = \"UTF-32\"; // and I hope it's on your system\n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            charsetName = \"UTF-16\"; // in all Javas\n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            charsetName = \"UTF-8\"; // in all Javas\n            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed\n        }\n\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex 57d0e4c..34880d8 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -90,20 +90,6 @@ public final class DataUtil {\n         Document doc = null;\n \n         // look for BOM - overrides any other header or input\n-        byteData.mark();\n-        byte[] bom = new byte[4];\n-        byteData.get(bom);\n-        byteData.rewind();\n-        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n-                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n-            charsetName = \"UTF-32\"; // and I hope it's on your system\n-        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n-                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n-            charsetName = \"UTF-16\"; // in all Javas\n-        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n-            charsetName = \"UTF-8\"; // in all Javas\n-            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed\n-        }\n \n         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n@@ -137,6 +123,13 @@ public final class DataUtil {\n             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n             docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n+        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n+            byteData.rewind();\n+            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+            docData = docData.substring(1);\n+            charsetName = defaultCharset;\n+            doc = null;\n+        }\n         if (doc == null) {\n             doc = parser.parseInput(docData, baseUri);\n             doc.outputSettings().charset(charsetName);\n"}
{"identifier": "Jsoup-70", "buggy_code": "    static boolean preserveWhitespace(Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node != null && node instanceof Element) {\n            Element el = (Element) node;\n                if (el.tag.preserveWhitespace())\n                    return true;\n                else\n                    return el.parent() != null && el.parent().tag.preserveWhitespace();\n        }\n        return false;\n    }\n", "fixed_code": "    static boolean preserveWhitespace(Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node != null && node instanceof Element) {\n            Element el = (Element) node;\n            int i = 0;\n            do {\n                if (el.tag.preserveWhitespace())\n                    return true;\n                el = el.parent();\n                i++;\n            } while (i < 6 && el != null);\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nstatic boolean preserveWhitespace(Node node)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex ba1470b..faca4c8 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1088,13 +1088,10 @@ public class Element extends Node {\n         // looks only at this element and five levels up, to prevent recursion & needless stack searches\n         if (node != null && node instanceof Element) {\n             Element el = (Element) node;\n-            int i = 0;\n-            do {\n                 if (el.tag.preserveWhitespace())\n                     return true;\n-                el = el.parent();\n-                i++;\n-            } while (i < 6 && el != null);\n+                else\n+                    return el.parent() != null && el.parent().tag.preserveWhitespace();\n         }\n         return false;\n     }\n"}
{"identifier": "Math-25", "buggy_code": "        /**\n         * Estimate a first guess of the amplitude and angular frequency.\n         * This method assumes that the {@link #sortObservations()} method\n         * has been called previously.\n         *\n         * @throws ZeroException if the abscissa range is zero.\n         * @throws MathIllegalStateException when the guessing procedure cannot\n         * produce sensible results.\n         */\n        private void guessAOmega() {\n            // initialize the sums for the linear model between the two integrals\n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                // one step forward\n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n\n                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n                // considering a linear model for f (and therefore constant f')\n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n\n            // compute the amplitude and pulsation coefficients\n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                // Range of the observations, assuming that the\n                // observations are sorted.\n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n                    // procedure cannot produce sensible results.\n\n                a = FastMath.sqrt(c1 / c2);\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }\n", "fixed_code": "        /**\n         * Estimate a first guess of the amplitude and angular frequency.\n         * This method assumes that the {@link #sortObservations()} method\n         * has been called previously.\n         *\n         * @throws ZeroException if the abscissa range is zero.\n         * @throws MathIllegalStateException when the guessing procedure cannot\n         * produce sensible results.\n         */\n        private void guessAOmega() {\n            // initialize the sums for the linear model between the two integrals\n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                // one step forward\n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n\n                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n                // considering a linear model for f (and therefore constant f')\n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n\n            // compute the amplitude and pulsation coefficients\n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                // Range of the observations, assuming that the\n                // observations are sorted.\n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                if (c2 == 0) {\n                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n                    // procedure cannot produce sensible results.\n                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n                }\n\n                a = FastMath.sqrt(c1 / c2);\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n         * Estimate a first guess of the amplitude and angular frequency.\n         * This method assumes that the\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex c7af9ae..1da2c45 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -320,11 +320,8 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n-                if (c2 == 0) {\n                     // In some ill-conditioned cases (cf. MATH-844), the guesser\n                     // procedure cannot produce sensible results.\n-                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n-                }\n \n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);\n"}
{"identifier": "Math-102", "buggy_code": "     /**\n     * {@inheritDoc}\n     * <p><strong>Note: </strong>This implementation rescales the \n     * <code>expected</code> array if necessary to ensure that the sum of the\n     * expected and observed counts are equal.</p>\n     * \n     * @param observed array of observed frequency counts\n     * @param expected array of expected frequency counts\n     * @return chi-square test statistic\n     * @throws IllegalArgumentException if preconditions are not met\n     * or length is less than 2\n     */\n    public double chiSquare(double[] expected, long[] observed)\n        throws IllegalArgumentException {\n        if ((expected.length < 2) || (expected.length != observed.length)) {\n            throw new IllegalArgumentException(\n                    \"observed, expected array lengths incorrect\");\n        }\n        if (!isPositive(expected) || !isNonNegative(observed)) {\n            throw new IllegalArgumentException(\n                \"observed counts must be non-negative and expected counts must be postive\");\n        }\n        double sumSq = 0.0d;\n        double dev = 0.0d;\n        for (int i = 0; i < observed.length; i++) {\n                dev = ((double) observed[i] - expected[i]);\n                sumSq += dev * dev / expected[i];\n        }\n        return sumSq;\n    }\n", "fixed_code": "     /**\n     * {@inheritDoc}\n     * <p><strong>Note: </strong>This implementation rescales the \n     * <code>expected</code> array if necessary to ensure that the sum of the\n     * expected and observed counts are equal.</p>\n     * \n     * @param observed array of observed frequency counts\n     * @param expected array of expected frequency counts\n     * @return chi-square test statistic\n     * @throws IllegalArgumentException if preconditions are not met\n     * or length is less than 2\n     */\n    public double chiSquare(double[] expected, long[] observed)\n        throws IllegalArgumentException {\n        if ((expected.length < 2) || (expected.length != observed.length)) {\n            throw new IllegalArgumentException(\n                    \"observed, expected array lengths incorrect\");\n        }\n        if (!isPositive(expected) || !isNonNegative(observed)) {\n            throw new IllegalArgumentException(\n                \"observed counts must be non-negative and expected counts must be postive\");\n        }\n        double sumExpected = 0d;\n        double sumObserved = 0d;\n        for (int i = 0; i < observed.length; i++) {\n            sumExpected += expected[i];\n            sumObserved += observed[i];\n        }\n        double ratio = 1.0d;\n        boolean rescale = false;\n        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n            ratio = sumObserved / sumExpected;\n            rescale = true;\n        }\n        double sumSq = 0.0d;\n        double dev = 0.0d;\n        for (int i = 0; i < observed.length; i++) {\n            if (rescale) {\n                dev = ((double) observed[i] - ratio * expected[i]);\n                sumSq += dev * dev / (ratio * expected[i]);\n            } else {\n                dev = ((double) observed[i] - expected[i]);\n                sumSq += dev * dev / expected[i];\n            }\n        }\n        return sumSq;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\nindex 984d56d..c87b010 100644\n--- a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n@@ -71,28 +71,11 @@ public class ChiSquareTestImpl implements UnknownDistributionChiSquareTest {\n             throw new IllegalArgumentException(\n                 \"observed counts must be non-negative and expected counts must be postive\");\n         }\n-        double sumExpected = 0d;\n-        double sumObserved = 0d;\n-        for (int i = 0; i < observed.length; i++) {\n-            sumExpected += expected[i];\n-            sumObserved += observed[i];\n-        }\n-        double ratio = 1.0d;\n-        boolean rescale = false;\n-        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n-            ratio = sumObserved / sumExpected;\n-            rescale = true;\n-        }\n         double sumSq = 0.0d;\n         double dev = 0.0d;\n         for (int i = 0; i < observed.length; i++) {\n-            if (rescale) {\n-                dev = ((double) observed[i] - ratio * expected[i]);\n-                sumSq += dev * dev / (ratio * expected[i]);\n-            } else {\n                 dev = ((double) observed[i] - expected[i]);\n                 sumSq += dev * dev / expected[i];\n-            }\n         }\n         return sumSq;\n     }\n"}
{"identifier": "Closure-88", "buggy_code": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Expressions are evaluated left-right, depth first.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }\n", "fixed_code": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Expressions are evaluated left-right, depth first.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\nindex 879056f..ef33e4c 100644\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n@@ -324,15 +324,9 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n-        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n         // The expression to which the assignment is made is evaluated before\n         // the RHS is evaluated (normal left to right evaluation) but the KILL\n         // occurs after the RHS is evaluated.\n-        Node rhs = n.getNext();\n-        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n-        if (state == VariableLiveness.READ) {\n-          return state;\n-        }\n         return VariableLiveness.KILL;\n       } else {\n         return VariableLiveness.READ;\n"}
{"identifier": "Closure-136", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/MethodCompilerPass.java b/src/com/google/javascript/jscomp/MethodCompilerPass.java\nindex 5e0268f9..cd39b6ee 100644\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n@@ -99,10 +99,30 @@ abstract class MethodCompilerPass implements CompilerPass {\n    * itself or the name of a function).\n    */\n   private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n+    boolean signatureAdded = false;\n     if (node.getType() == Token.FUNCTION) {\n       // The node we're looking at is a function, so we can add it directly\n       addSignature(name, node, t.getSourceName());\n-    } else {\n+      signatureAdded = true;\n+    } else if (node.getType() == Token.NAME) {\n+      String functionName = node.getString();\n+      Scope.Var v = t.getScope().getVar(functionName);\n+      if (v == null) {\n+        if (compiler.isIdeMode()) {\n+          return;\n+        } else {\n+          throw new IllegalStateException(\n+              \"VarCheck should have caught this undefined function\");\n+        }\n+      }\n+      Node function = v.getInitialValue();\n+      if (function != null &&\n+          function.getType() == Token.FUNCTION) {\n+        addSignature(name, function, v.getInputName());\n+        signatureAdded = true;\n+      }\n+    }\n+    if (!signatureAdded) {\n       nonMethodProperties.add(name);\n     }\n   }\ndiff --git a/src/com/google/javascript/jscomp/RenameVars.java b/src/com/google/javascript/jscomp/RenameVars.java\nindex fb13e4de..29f4d7a4 100644\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n@@ -200,15 +200,7 @@ final class RenameVars implements CompilerPass {\n \n       // Check if we can rename this.\n       if (!okToRenameVar(name, local)) {\n-        if (local) {\n           // Blindly de-uniquify for the Prototype library for issue 103.\n-          String newName =\n-            MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n-                name);\n-          if (!newName.equals(name)) {\n-            n.setString(newName);\n-          }\n-        }\n         return;\n       }\n \n"}
{"identifier": "Chart-22", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/data/KeyedObjects2D.java b/source/org/jfree/data/KeyedObjects2D.java\nindex 7cc5ad6..d0e832f 100644\n--- a/source/org/jfree/data/KeyedObjects2D.java\n+++ b/source/org/jfree/data/KeyedObjects2D.java\n@@ -228,10 +228,9 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \n                     + \") not recognised.\");\n         }\n+        if (row >= 0) {\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n-        int index = rowData.getIndex(columnKey);\n-        if (index >= 0) {\n-            return rowData.getObject(index);\n+            return rowData.getObject(columnKey);\n         }\n         else {\n             return null;\n@@ -316,29 +315,8 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n         }\n         \n         // 2. check whether the column is now empty.\n-        allNull = true;\n         \n-        for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n-             item++) {\n-            row = (KeyedObjects) this.rows.get(item);\n-            int columnIndex = row.getIndex(columnKey);\n-            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {\n-                allNull = false;\n-                break;\n-            }\n-        }\n         \n-        if (allNull) {\n-            for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n-                 item++) {\n-                row = (KeyedObjects) this.rows.get(item);\n-                int columnIndex = row.getIndex(columnKey);\n-                if (columnIndex >= 0) {\n-                    row.removeValue(columnIndex);\n-                }\n-            }\n-            this.columnKeys.remove(columnKey);\n-        }\n     }\n \n     /**\n@@ -364,10 +342,6 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n      */\n     public void removeRow(Comparable rowKey) {\n         int index = getRowIndex(rowKey);\n-        if (index < 0) {\n-            throw new UnknownKeyException(\"Row key (\" + rowKey \n-                    + \") not recognised.\");\n-        }\n         removeRow(index);\n     }\n \n@@ -401,10 +375,7 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n         Iterator iterator = this.rows.iterator();\n         while (iterator.hasNext()) {\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\n-            int i = rowData.getIndex(columnKey);\n-            if (i >= 0) {\n-                rowData.removeValue(i);\n-            }\n+                rowData.removeValue(columnKey);\n         }\n         this.columnKeys.remove(columnKey);\n     }\n"}
{"identifier": "Math-91", "buggy_code": "    /**\n     * Compares this object to another based on size.\n     * @param object the object to compare to\n     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n     *         than <tt>object</tt>, 0 if they are equal.\n     */\n    public int compareTo(Fraction object) {\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n", "fixed_code": "    /**\n     * Compares this object to another based on size.\n     * @param object the object to compare to\n     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n     *         than <tt>object</tt>, 0 if they are equal.\n     */\n    public int compareTo(Fraction object) {\n        long nOd = ((long) numerator) * object.denominator;\n        long dOn = ((long) denominator) * object.numerator;\n        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Compares this object to another based on size.\n     * @param object the object to compare to\n     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n     *         than <tt>object</tt>, 0 if they are equal.\n     */\n    public int compareTo(Fraction object)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/fraction/Fraction.java b/src/java/org/apache/commons/math/fraction/Fraction.java\nindex d6d2f18..0706f8c 100644\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n@@ -256,8 +256,8 @@ public class Fraction extends Number implements Comparable<Fraction> {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        long nOd = ((long) numerator) * object.denominator;\n-        long dOn = ((long) denominator) * object.numerator;\n+        double nOd = doubleValue();\n+        double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n"}
{"identifier": "Mockito-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/Mockito.java b/src/org/mockito/Mockito.java\nindex 980587d..5eb16aa 100644\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n@@ -824,7 +824,7 @@ public class Mockito extends Matchers {\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n-        return MOCKITO_CORE.mock(classToMock, mockSettings, true);\n+        return MOCKITO_CORE.mock(classToMock, mockSettings);\n     }\n     \n     /**\n@@ -896,7 +896,7 @@ public class Mockito extends Matchers {\n     public static <T> T spy(T object) {\n         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                 .spiedInstance(object)\n-                .defaultAnswer(CALLS_REAL_METHODS), true); \n+                .defaultAnswer(CALLS_REAL_METHODS)); \n     }\n \n     /**\ndiff --git a/src/org/mockito/internal/MockitoCore.java b/src/org/mockito/internal/MockitoCore.java\nindex 61acce8..5321566 100755\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n@@ -29,11 +29,10 @@ public class MockitoCore {\n     private final MockUtil mockUtil = new MockUtil();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {\n+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }\n+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n         mockingProgress.validateState();\n-        if (shouldResetOngoingStubbing) {\n             mockingProgress.resetOngoingStubbing();\n-        }\n         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n     }\n     \n"}
{"identifier": "JacksonDatabind-68", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\nindex 3c686044f..0b36b0b04 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n@@ -1189,10 +1189,9 @@ public abstract class BeanDeserializerBase\n     protected Object deserializeFromObjectUsingNonDefault(JsonParser p,\n             DeserializationContext ctxt) throws IOException\n     {\n-        final JsonDeserializer<Object> delegateDeser = _delegateDeserializer();\n-        if (delegateDeser != null) {\n+        if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n-                    delegateDeser.deserialize(p, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n             return _deserializeUsingPropertyBased(p, ctxt);\n@@ -1218,13 +1217,12 @@ public abstract class BeanDeserializerBase\n         if (_objectIdReader != null) {\n             return deserializeFromObjectId(p, ctxt);\n         }\n-        final JsonDeserializer<Object> delegateDeser = _delegateDeserializer();\n         switch (p.getNumberType()) {\n         case INT:\n-            if (delegateDeser != null) {\n+            if (_delegateDeserializer != null) {\n                 if (!_valueInstantiator.canCreateFromInt()) {\n                     Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n-                            delegateDeser.deserialize(p, ctxt));\n+                            _delegateDeserializer.deserialize(p, ctxt));\n                     if (_injectables != null) {\n                         injectValues(ctxt, bean);\n                     }\n@@ -1233,10 +1232,10 @@ public abstract class BeanDeserializerBase\n             }\n             return _valueInstantiator.createFromInt(ctxt, p.getIntValue());\n         case LONG:\n-            if (delegateDeser != null) {\n+            if (_delegateDeserializer != null) {\n                 if (!_valueInstantiator.canCreateFromInt()) {\n                     Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n-                            delegateDeser.deserialize(p, ctxt));\n+                            _delegateDeserializer.deserialize(p, ctxt));\n                     if (_injectables != null) {\n                         injectValues(ctxt, bean);\n                     }\n@@ -1246,9 +1245,9 @@ public abstract class BeanDeserializerBase\n             return _valueInstantiator.createFromLong(ctxt, p.getLongValue());\n         }\n         // actually, could also be BigInteger, so:\n-        if (delegateDeser != null) {\n+        if (_delegateDeserializer != null) {\n             Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n-                    delegateDeser.deserialize(p, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n             if (_injectables != null) {\n                 injectValues(ctxt, bean);\n             }\n@@ -1268,11 +1267,10 @@ public abstract class BeanDeserializerBase\n         /* Bit complicated if we have delegating creator; may need to use it,\n          * or might not...\n          */\n-        JsonDeserializer<Object> delegateDeser = _delegateDeserializer();\n-        if (delegateDeser != null) {\n+        if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromString()) {\n                 Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n-                        delegateDeser.deserialize(p, ctxt));\n+                        _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n@@ -1291,11 +1289,10 @@ public abstract class BeanDeserializerBase\n         NumberType t = p.getNumberType();\n         // no separate methods for taking float...\n         if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) {\n-            JsonDeserializer<Object> delegateDeser = _delegateDeserializer();\n-            if (delegateDeser != null) {\n+            if (_delegateDeserializer != null) {\n                 if (!_valueInstantiator.canCreateFromDouble()) {\n                     Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n-                            delegateDeser.deserialize(p, ctxt));\n+                            _delegateDeserializer.deserialize(p, ctxt));\n                     if (_injectables != null) {\n                         injectValues(ctxt, bean);\n                     }\n@@ -1305,10 +1302,9 @@ public abstract class BeanDeserializerBase\n             return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());\n         }\n         // actually, could also be BigDecimal, so:\n-        JsonDeserializer<Object> delegateDeser = _delegateDeserializer();\n-        if (delegateDeser != null) {\n+        if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n-                    delegateDeser.deserialize(p, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         return ctxt.handleMissingInstantiator(handledType(), p,\n                 \"no suitable creator method found to deserialize from Number value (%s)\",\n@@ -1320,11 +1316,10 @@ public abstract class BeanDeserializerBase\n      */\n     public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n-        JsonDeserializer<Object> delegateDeser = _delegateDeserializer();\n-        if (delegateDeser != null) {\n+        if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromBoolean()) {\n                 Object bean = _valueInstantiator.createUsingDelegate(ctxt,\n-                        delegateDeser.deserialize(p, ctxt));\n+                        _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n@@ -1338,15 +1333,30 @@ public abstract class BeanDeserializerBase\n     public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         // note: can not call `_delegateDeserializer()` since order reversed here:\n-        JsonDeserializer<Object> delegateDeser = _arrayDelegateDeserializer;\n+        if (_arrayDelegateDeserializer != null) {\n+            try {\n+                Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            } catch (Exception e) {\n+                return wrapInstantiationProblem(e, ctxt);\n+            }\n+        }\n         // fallback to non-array delegate\n-        if ((delegateDeser != null) || ((delegateDeser = _delegateDeserializer) != null)) {\n+        if (_delegateDeserializer != null) {\n+            try {\n             Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt,\n-                    delegateDeser.deserialize(p, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n             if (_injectables != null) {\n                 injectValues(ctxt, bean);\n             }\n             return bean;\n+            } catch (Exception e) {\n+                wrapInstantiationProblem(e, ctxt);\n+                return null;\n+            }\n         }\n         if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             JsonToken t = p.nextToken();\n@@ -1387,13 +1397,6 @@ public abstract class BeanDeserializerBase\n     /**\n      * @since 2.9\n      */\n-    private final JsonDeserializer<Object> _delegateDeserializer() {\n-        JsonDeserializer<Object> deser = _delegateDeserializer;\n-        if (deser == null) {\n-            deser = _arrayDelegateDeserializer;\n-        }\n-        return deser;\n-    }\n \n     /*\n     /**********************************************************\n"}
{"identifier": "Chart-10", "buggy_code": "    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText\n            + \"\\\" alt=\\\"\\\"\";\n    }\n", "fixed_code": "    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n            + \"\\\" alt=\\\"\\\"\";\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java b/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\nindex 4755d8c..cf2934c 100644\n--- a/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\n+++ b/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\n@@ -62,7 +62,7 @@ public class StandardToolTipTagFragmentGenerator\n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n+        return \" title=\\\"\" + toolTipText\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n"}
{"identifier": "Csv-6", "buggy_code": "    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n                map.put(entry.getKey(), values[col]);\n        }\n        return map;\n    }\n", "fixed_code": "    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex ae7762d..7380d9f 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -179,9 +179,7 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n     <M extends Map<String, String>> M putIn(final M map) {\n         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n             final int col = entry.getValue().intValue();\n-            if (col < values.length) {\n                 map.put(entry.getKey(), values[col]);\n-            }\n         }\n         return map;\n     }\n"}
{"identifier": "Jsoup-61", "buggy_code": "    // performance sensitive\n    public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    // we're in a class name : keep the start of the substring\n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        // check the last entry\n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }\n", "fixed_code": "    // performance sensitive\n    public boolean hasClass(String className) {\n        final String classAttr = attributes.getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    // we're in a class name : keep the start of the substring\n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        // check the last entry\n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// performance sensitive\n    public boolean hasClass(String className)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex 175654e..caf1110 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1089,7 +1089,7 @@ public class Element extends Node {\n      */\n     // performance sensitive\n     public boolean hasClass(String className) {\n-        final String classAttr = attributes.getIgnoreCase(\"class\");\n+        final String classAttr = attributes.get(\"class\");\n         final int len = classAttr.length();\n         final int wantLen = className.length();\n \n"}
{"identifier": "Math-11", "buggy_code": "    /** {@inheritDoc} */\n    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\nindex fd18c28..1570681 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n@@ -180,7 +180,7 @@ public class MultivariateNormalDistribution\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n+        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n"}
{"identifier": "JacksonDatabind-30", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\nindex 2fd10fb56..caa09c304 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n@@ -2507,9 +2507,6 @@ public class ObjectMapper\n     {\n         if (fromValue == null) return null;\n         TokenBuffer buf = new TokenBuffer(this, false);\n-        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-            buf = buf.forceUseOfBigDecimal(true);\n-        }\n         JsonNode result;\n         try {\n             writeValue(buf, fromValue);\n@@ -3426,9 +3423,6 @@ public class ObjectMapper\n         \n         // Then use TokenBuffer, which is a JsonGenerator:\n         TokenBuffer buf = new TokenBuffer(this, false);\n-        if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-            buf = buf.forceUseOfBigDecimal(true);\n-        }\n         try {\n             // inlined 'writeValue' with minor changes:\n             // first: disable wrapping when writing\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\nindex fc3600ad9..39d9e7186 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n@@ -77,7 +77,6 @@ public class TokenBuffer\n      *\n      * @since 2.7\n      */\n-    protected boolean _forceBigDecimal;\n     \n     /*\n     /**********************************************************\n@@ -186,17 +185,11 @@ public class TokenBuffer\n         _hasNativeTypeIds = p.canReadTypeId();\n         _hasNativeObjectIds = p.canReadObjectId();\n         _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n-        _forceBigDecimal = (ctxt == null) ? false\n-                : ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n     }\n \n     /**\n      * @since 2.7\n      */\n-    public TokenBuffer forceUseOfBigDecimal(boolean b) {\n-        _forceBigDecimal = b;\n-        return this;\n-    }\n \n     @Override\n     public Version version() {\n@@ -963,14 +956,11 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n             }\n             break;\n         case VALUE_NUMBER_FLOAT:\n-            if (_forceBigDecimal) {\n                 /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                  *   number is already decoded into a number (in which case might as well\n                  *   access as number); or is still retained as text (in which case we\n                  *   should further defer decoding that may not need BigDecimal):\n                  */\n-                writeNumber(p.getDecimalValue());\n-            } else {\n                 switch (p.getNumberType()) {\n                 case BIG_DECIMAL:\n                     writeNumber(p.getDecimalValue());\n@@ -980,7 +970,6 @@ sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n                     break;\n                 default:\n                     writeNumber(p.getDoubleValue());\n-                }\n             }\n             break;\n         case VALUE_TRUE:\n"}
{"identifier": "Math-58", "buggy_code": "    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n    }\n", "fixed_code": "    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(guess);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex e1b54f4..ae7ac39 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -118,7 +118,7 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(guess);\n+        return fit(new Gaussian.Parametric(), guess);\n     }\n \n     /**\n"}
{"identifier": "Cli-37", "buggy_code": "    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n        // remove leading \"-\" and \"=value\"\n    }\n", "fixed_code": "    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex f34173e..6aeaebe 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -299,15 +299,9 @@ public class DefaultParser implements CommandLineParser\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        if (!token.startsWith(\"-\") || token.length() == 1)\n-        {\n-            return false;\n-        }\n+        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n-        int pos = token.indexOf(\"=\");\n-        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n     }\n \n     /**\n"}
{"identifier": "Jsoup-25", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java\nindex caebf4e..40b7557 100644\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n@@ -215,7 +215,7 @@ public class Tag {\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n+    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n \n     static {\n         // creates\n"}
{"identifier": "JacksonDatabind-20", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\nindex 1ca18f142..147ac71a1 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n@@ -1,7 +1,6 @@\n package com.fasterxml.jackson.databind.node;\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n-import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n@@ -322,7 +321,6 @@ public class ObjectNode\n      *\n      * @since 2.1\n      */\n-    @JsonIgnore // work-around for [databind#815]\n     public JsonNode setAll(Map<String,? extends JsonNode> properties)\n     {\n         for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {\n"}
{"identifier": "Csv-10", "buggy_code": "    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n    }\n", "fixed_code": "    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n        if (format.getHeader() != null) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex d2968b5..94e5852 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -67,9 +67,6 @@ public final class CSVPrinter implements Flushable, Closeable {\n         this.format.validate();\n         // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n         // It seems a pain to have to track whether the header has already been printed or not.\n-        if (format.getHeader() != null) {\n-            this.printRecord((Object[]) format.getHeader());\n-        }\n     }\n \n     // ======================================================\n"}
{"identifier": "Time-17", "buggy_code": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n        \n        // calculate result\n          // currently in later offset\n          // currently in earlier offset\n    }\n", "fixed_code": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBefore);\n        long offsetAfter = getOffset(instantAfter);\n        if (offsetBefore <= offsetAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long diff = offsetBefore - offsetAfter;\n        long transition = nextTransition(instantBefore);\n        long overlapStart = transition - diff;\n        long overlapEnd = transition + diff;\n        if (instant < overlapStart || instant >= overlapEnd) {\n          return instant;  // not an overlap\n        }\n        \n        // calculate result\n        long afterStart = instant - overlapStart;\n        if (afterStart >= diff) {\n          // currently in later offset\n          return earlierOrLater ? instant : instant - diff;\n        } else {\n          // currently in earlier offset\n          return earlierOrLater ? instant + diff : instant;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 7219899..74a3802 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1164,32 +1164,19 @@ public abstract class DateTimeZone implements Serializable {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n-        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n-        long offsetBefore = getOffset(instantBefore);\n-        long offsetAfter = getOffset(instantAfter);\n-        if (offsetBefore <= offsetAfter) {\n+        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        if (instantBefore == instantAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }\n         \n         // work out range of instants that have duplicate local times\n-        long diff = offsetBefore - offsetAfter;\n-        long transition = nextTransition(instantBefore);\n-        long overlapStart = transition - diff;\n-        long overlapEnd = transition + diff;\n-        if (instant < overlapStart || instant >= overlapEnd) {\n-          return instant;  // not an overlap\n-        }\n+        long local = convertUTCToLocal(instant);\n+        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n         \n         // calculate result\n-        long afterStart = instant - overlapStart;\n-        if (afterStart >= diff) {\n           // currently in later offset\n-          return earlierOrLater ? instant : instant - diff;\n-        } else {\n           // currently in earlier offset\n-          return earlierOrLater ? instant + diff : instant;\n-        }\n     }\n //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n \n"}
{"identifier": "Closure-104", "buggy_code": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    JSType result = builder.build();\n    if (result != null) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n", "fixed_code": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      if (alternate.isSubtype(that)) {\n        builder.addAlternate(alternate);\n      }\n    }\n\n    if (that instanceof UnionType) {\n      for (JSType otherAlternate : ((UnionType) that).alternates) {\n        if (otherAlternate.isSubtype(this)) {\n          builder.addAlternate(otherAlternate);\n        }\n      }\n    } else if (that.isSubtype(this)) {\n      builder.addAlternate(that);\n    }\n    JSType result = builder.build();\n    if (!result.isNoType()) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nJSType meet(JSType that)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex 6f0d798..a9c9a0a 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -288,7 +288,7 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (!result.isNoType()) {\n+    if (result != null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n"}
{"identifier": "JacksonDatabind-82", "buggy_code": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex 1423f2867..4b0434e41 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -492,7 +492,7 @@ public class BeanDeserializerFactory\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.findIgnoredForDeserialization();\n+            ignored = ignorals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n"}
{"identifier": "Mockito-15", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\nindex 673de91..637c450 100644\n--- a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n@@ -1,7 +1,6 @@\n package org.mockito.internal.configuration.injection;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.util.reflection.BeanPropertySetter;\n import org.mockito.internal.util.reflection.FieldSetter;\n \n import java.lang.reflect.Field;\n@@ -23,9 +22,7 @@ public class FinalMockCandidateFilter implements MockCandidateFilter {\n             return new OngoingInjecter() {\n                 public boolean thenInject() {\n                     try {\n-                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\n-                        }\n                     } catch (Exception e) {\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                     }\n"}
{"identifier": "Jsoup-5", "buggy_code": "    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n        String key = tq.consumeAttributeKey();\n        String value = \"\";\n        tq.consumeWhitespace();\n        if (tq.matchChomp(\"=\")) {\n            tq.consumeWhitespace();\n\n            if (tq.matchChomp(SQ)) {\n                value = tq.chompTo(SQ);\n            } else if (tq.matchChomp(DQ)) {\n                value = tq.chompTo(DQ);\n            } else {\n                StringBuilder valueAccum = new StringBuilder();\n                // no ' or \" to look for, so scan to end tag or space (or end of stream)\n                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                    valueAccum.append(tq.consume());\n                }\n                value = valueAccum.toString();\n            }\n            tq.consumeWhitespace();\n        }\n        if (key.length() != 0)\n            return Attribute.createFromEncoded(key, value);\n        else {\n            tq.consume();\n                \n            return null;\n        }\n    }\n", "fixed_code": "    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n        String key = tq.consumeAttributeKey();\n        String value = \"\";\n        tq.consumeWhitespace();\n        if (tq.matchChomp(\"=\")) {\n            tq.consumeWhitespace();\n\n            if (tq.matchChomp(SQ)) {\n                value = tq.chompTo(SQ);\n            } else if (tq.matchChomp(DQ)) {\n                value = tq.chompTo(DQ);\n            } else {\n                StringBuilder valueAccum = new StringBuilder();\n                // no ' or \" to look for, so scan to end tag or space (or end of stream)\n                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                    valueAccum.append(tq.consume());\n                }\n                value = valueAccum.toString();\n            }\n            tq.consumeWhitespace();\n        }\n        if (key.length() != 0)\n            return Attribute.createFromEncoded(key, value);\n        else {\n            if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck\n                tq.advance();\n                \n            return null;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate Attribute parseAttribute()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java\nindex 38eb6f0..4af0a68 100644\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n@@ -203,8 +203,7 @@ public class Parser {\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck\n-                tq.advance();\n+            tq.consume();\n                 \n             return null;\n         }\n"}
{"identifier": "JacksonDatabind-91", "buggy_code": "    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.8.11\n     */\n    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            // First: value types may have both value and type handlers\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n            }\n        }\n        return false;\n    }\n", "fixed_code": "    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.8.11\n     */\n    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            // First: value types may have both value and type handlers\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                    return true;\n                }\n            }\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n            if (t.isMapLikeType()) {\n                JavaType kt = t.getKeyType();\n                if (kt.getValueHandler() != null) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.8.11\n     */\n    private boolean _hasCustomHandlers(JavaType t)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\nindex ded6b68fd..aae7e87f5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n@@ -538,16 +538,8 @@ public final class DeserializerCache\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n-                    return true;\n-                }\n-            }\n+                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n-            if (t.isMapLikeType()) {\n-                JavaType kt = t.getKeyType();\n-                if (kt.getValueHandler() != null) {\n-                    return true;\n-                }\n             }\n         }\n         return false;\n"}
{"identifier": "Lang-44", "buggy_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }   \n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                dec = val.substring(decPos + 1);\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = val.substring(0, expPos);\n            } else {\n                mant = val;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = val.substring(0, val.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // empty catch\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // empty catch\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                return createBigInteger(val);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n                try {\n                    Double d = createDouble(val);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // empty catch\n                }\n\n                return createBigDecimal(val);\n\n            }\n\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex c5ca8cd..18a05ef 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -142,9 +142,6 @@ public final class NumberUtils {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n-        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n-            throw new NumberFormatException(val + \" is not a valid number.\");\n-        }\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n"}
{"identifier": "Jsoup-66", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex 85d335a..461a922 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -86,7 +86,7 @@ public class Element extends Node {\n \n     protected List<Node> ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n-            childNodes = new NodeList(this, 4);\n+            childNodes = new NodeList(4);\n         }\n         return childNodes;\n     }\n@@ -1399,22 +1399,19 @@ public class Element extends Node {\n         Element clone = (Element) super.doClone(parent);\n         clone.attributes = attributes != null ? attributes.clone() : null;\n         clone.baseUri = baseUri;\n-        clone.childNodes = new NodeList(clone, childNodes.size());\n+        clone.childNodes = new NodeList(childNodes.size());\n         clone.childNodes.addAll(childNodes);\n \n         return clone;\n     }\n \n-    private static final class NodeList extends ChangeNotifyingArrayList<Node> {\n-        private final Element owner;\n-\n-        NodeList(Element owner, int initialCapacity) {\n+    private final class NodeList extends ChangeNotifyingArrayList<Node> {\n+        NodeList(int initialCapacity) {\n             super(initialCapacity);\n-            this.owner = owner;\n         }\n \n         public void onContentsChanged() {\n-            owner.nodelistChanged();\n+            nodelistChanged();\n         }\n     }\n }\n"}
{"identifier": "Time-18", "buggy_code": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant;\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n", "fixed_code": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant;\n        try {\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalFieldValueException ex) {\n            if (monthOfYear != 2 || dayOfMonth != 29) {\n                throw ex;\n            }\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, 28,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                throw ex;\n            }\n        }\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/chrono/GJChronology.java b/src/main/java/org/joda/time/chrono/GJChronology.java\nindex 0a19aa6..29e559d 100644\n--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n@@ -361,21 +361,9 @@ public final class GJChronology extends AssembledChronology {\n \n         // Assume date is Gregorian.\n         long instant;\n-        try {\n             instant = iGregorianChronology.getDateTimeMillis\n                 (year, monthOfYear, dayOfMonth,\n                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        } catch (IllegalFieldValueException ex) {\n-            if (monthOfYear != 2 || dayOfMonth != 29) {\n-                throw ex;\n-            }\n-            instant = iGregorianChronology.getDateTimeMillis\n-                (year, monthOfYear, 28,\n-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-            if (instant >= iCutoverMillis) {\n-                throw ex;\n-            }\n-        }\n         if (instant < iCutoverMillis) {\n             // Maybe it's Julian.\n             instant = iJulianChronology.getDateTimeMillis\n"}
{"identifier": "Lang-22", "buggy_code": "    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n", "fixed_code": "    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex bf15a49..b36a156 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -580,14 +580,8 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n-        if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n-                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n-            }\n-            return Math.abs(u) + Math.abs(v);\n-        }\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n+        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n"}
{"identifier": "Closure-61", "buggy_code": "  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   */\n  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.getType() == Token.NAME) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.getType() == Token.GETPROP) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Functions in the \"Math\" namespace have no side effects.\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.getType() == Token.STRING\n                  || param.getType() == Token.REGEXP))\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n", "fixed_code": "  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   */\n  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.getType() == Token.NAME) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.getType() == Token.GETPROP) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Functions in the \"Math\" namespace have no side effects.\n      if (nameNode.getFirstChild().getType() == Token.NAME) {\n        String namespaceName = nameNode.getFirstChild().getString();\n        if (namespaceName.equals(\"Math\")) {\n          return false;\n        }\n      }\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.getType() == Token.STRING\n                  || param.getType() == Token.REGEXP))\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   */\n  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex f9ce42e..1844b18 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -955,12 +955,6 @@ public final class NodeUtil {\n       }\n \n       // Functions in the \"Math\" namespace have no side effects.\n-      if (nameNode.getFirstChild().getType() == Token.NAME) {\n-        String namespaceName = nameNode.getFirstChild().getString();\n-        if (namespaceName.equals(\"Math\")) {\n-          return false;\n-        }\n-      }\n \n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP\n"}
{"identifier": "Jsoup-56", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/DocumentType.java b/src/main/java/org/jsoup/nodes/DocumentType.java\nindex 4e7730b..fde181f 100644\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n@@ -12,7 +12,6 @@\n     public static final String PUBLIC_KEY = \"PUBLIC\";\n     public static final String SYSTEM_KEY = \"SYSTEM\";\n     private static final String NAME = \"name\";\n-    private static final String PUB_SYS_KEY = \"pubSysKey\"; // PUBLIC or SYSTEM\n     private static final String PUBLIC_ID = \"publicId\";\n     private static final String SYSTEM_ID = \"systemId\";\n     // todo: quirk mode from publicId and systemId\n@@ -29,9 +26,6 @@ public class DocumentType extends Node {\n \n         attr(NAME, name);\n         attr(PUBLIC_ID, publicId);\n-        if (has(PUBLIC_ID)) {\n-            attr(PUB_SYS_KEY, PUBLIC_KEY);\n-        }\n         attr(SYSTEM_ID, systemId);\n     }\n \n@@ -42,16 +36,7 @@ public class DocumentType extends Node {\n      * @param systemId the doctype's system ID\n      * @param baseUri the doctype's base URI\n      */\n-    public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n-        super(baseUri);\n \n-        attr(NAME, name);\n-        if (pubSysKey != null) {\n-            attr(PUB_SYS_KEY, pubSysKey);\n-        }\n-        attr(PUBLIC_ID, publicId);\n-        attr(SYSTEM_ID, systemId);\n-    }\n \n     @Override\n     public String nodeName() {\n@@ -68,10 +53,8 @@ public class DocumentType extends Node {\n         }\n         if (has(NAME))\n             accum.append(\" \").append(attr(NAME));\n-        if (has(PUB_SYS_KEY))\n-            accum.append(\" \").append(attr(PUB_SYS_KEY));\n         if (has(PUBLIC_ID))\n-            accum.append(\" \\\"\").append(attr(PUBLIC_ID)).append('\"');\n+            accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n         if (has(SYSTEM_ID))\n             accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n         accum.append('>');\ndiff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex c515462..9a40814 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -20,7 +20,7 @@ enum HtmlTreeBuilderState {\n                 // todo: quirk state check on doctype ids\n                 Token.Doctype d = t.asDoctype();\n                 DocumentType doctype = new DocumentType(\n-                    tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n+                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n                 tb.getDocument().appendChild(doctype);\n                 if (d.isForceQuirks())\n                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);\ndiff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java\nindex 34baf19..0eccbbe 100644\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n@@ -32,7 +32,6 @@ abstract class Token {\n \n     static final class Doctype extends Token {\n         final StringBuilder name = new StringBuilder();\n-        String pubSysKey = null;\n         final StringBuilder publicIdentifier = new StringBuilder();\n         final StringBuilder systemIdentifier = new StringBuilder();\n         boolean forceQuirks = false;\n@@ -44,7 +43,6 @@ abstract class Token {\n         @Override\n         Token reset() {\n             reset(name);\n-            pubSysKey = null;\n             reset(publicIdentifier);\n             reset(systemIdentifier);\n             forceQuirks = false;\n@@ -55,9 +53,6 @@ abstract class Token {\n             return name.toString();\n         }\n \n-        String getPubSysKey() {\n-            return pubSysKey;\n-        }\n \n         String getPublicIdentifier() {\n             return publicIdentifier.toString();\ndiff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex 6a97238..c0148f3 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -1192,10 +1192,8 @@\n                 t.emitDoctypePending();\n                 t.advanceTransition(Data);\n             } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\n-                t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY;\n                 t.transition(AfterDoctypePublicKeyword);\n             } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\n-                t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;\n                 t.transition(AfterDoctypeSystemKeyword);\n             } else {\n                 t.error(this);\ndiff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex cfcb1a3..2ac525f 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -97,7 +97,7 @@ public class XmlTreeBuilder extends TreeBuilder {\n     }\n \n     void insert(Token.Doctype d) {\n-        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n+        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n         insertNode(doctypeNode);\n     }\n \n"}
{"identifier": "JacksonDatabind-66", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\nindex d1148bac1..f827c318d 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n@@ -8,7 +8,6 @@ import java.net.URI;\n import java.net.URL;\n import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.io.NumberInput;\n import com.fasterxml.jackson.databind.*;\n@@ -16,7 +15,6 @@ import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n-import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Default {@link KeyDeserializer} implementation used for most {@link java.util.Map}\n@@ -313,13 +311,9 @@ public class StdKeyDeserializer extends KeyDeserializer\n             if (key == null) { // is this even legal call?\n                 return null;\n             }\n-            TokenBuffer tb = new TokenBuffer(ctxt.getParser(), ctxt);\n-            tb.writeString(key);\n             try {\n                 // Ugh... should not have to give parser which may or may not be correct one...\n-                JsonParser p = tb.asParser();\n-                p.nextToken();\n-                Object result = _delegate.deserialize(p, ctxt);\n+                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n                 if (result != null) {\n                     return result;\n                 }\n"}
{"identifier": "Closure-140", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 448e2b56..d2524b4f 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -261,7 +261,6 @@ public class Compiler extends AbstractCompiler {\n     initOptions(options);\n \n     checkFirstModule(modules);\n-    fillEmptyModules(modules);\n \n     this.externs = makeCompilerInput(externs, true);\n     this.modules = modules;\n@@ -326,14 +325,6 @@ public class Compiler extends AbstractCompiler {\n    * Fill any empty modules with a place holder file. It makes any cross module\n    * motion easier.\n    */\n-  private void fillEmptyModules(JSModule[] modules) {\n-    for (int i = 1; i < modules.length; i ++) {\n-      JSModule module = modules[i];\n-      if (module.getInputs().isEmpty()) {\n-        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n-      }\n-    }\n-  }\n   \n   static final DiagnosticType DUPLICATE_INPUT_IN_MODULES =\n       DiagnosticType.error(\"JSC_DUPLICATE_INPUT_IN_MODULES_ERROR\",\n@@ -1588,6 +1579,12 @@ public class Compiler extends AbstractCompiler {\n     if (inputs.size() > 0) {\n       return inputs.get(0).getAstRoot(this);\n     }\n+    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {\n+      inputs = m.getInputs();\n+      if (inputs.size() > 0) {\n+        return inputs.get(0).getAstRoot(this);\n+      }\n+    }\n     throw new IllegalStateException(\"Root module has no inputs\");\n   }\n \n"}
{"identifier": "Cli-35", "buggy_code": "    /**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n", "fixed_code": "    /**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n        if(longOpts.keySet().contains(opt)) {\n            return Collections.singletonList(opt);\n        }\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/Options.java b/src/main/java/org/apache/commons/cli/Options.java\nindex 798b176..e9a0aa9 100644\n--- a/src/main/java/org/apache/commons/cli/Options.java\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n@@ -237,9 +237,6 @@ public class Options implements Serializable\n         List<String> matchingOpts = new ArrayList<String>();\n \n         // for a perfect match return the single option only\n-        if(longOpts.keySet().contains(opt)) {\n-            return Collections.singletonList(opt);\n-        }\n \n         for (String longOpt : longOpts.keySet())\n         {\n"}
{"identifier": "Compress-35", "buggy_code": "    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    digits = 6;\n                }\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }\n", "fixed_code": "    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                b = ' ';\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 204debff..65088eb2 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -591,7 +591,7 @@ public class TarUtils {\n      * @since 1.5\n      */\n     public static boolean verifyCheckSum(byte[] header) {\n-        long storedSum = parseOctal(header, CHKSUM_OFFSET, CHKSUMLEN);\n+        long storedSum = 0;\n         long unsignedSum = 0;\n         long signedSum = 0;\n \n@@ -599,6 +599,11 @@ public class TarUtils {\n         for (int i = 0; i < header.length; i++) {\n             byte b = header[i];\n             if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n+                if ('0' <= b && b <= '7' && digits++ < 6) {\n+                    storedSum = storedSum * 8 + b - '0';\n+                } else if (digits > 0) {\n+                    digits = 6;\n+                }\n                 b = ' ';\n             }\n             unsignedSum += 0xff & b;\n"}
{"identifier": "Jsoup-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex ad825d3..4d016ff 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -61,7 +61,7 @@ public class Entities {\n                 } catch (NumberFormatException e) {\n                 } // skip\n             } else {\n-                String name = m.group(1);\n+                String name = m.group(1).toLowerCase();\n                 if (full.containsKey(name))\n                     charval = full.get(name);\n             }\n@@ -2232,12 +2232,12 @@ public class Entities {\n \n         for (Object[] entity : baseArray) {\n             Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n-            baseByVal.put(c, ((String) entity[0]));\n+            baseByVal.put(c, ((String) entity[0]).toLowerCase());\n         }\n         for (Object[] entity : fullArray) {\n             Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n             full.put((String) entity[0], c);\n-            fullByVal.put(c, ((String) entity[0]));\n+            fullByVal.put(c, ((String) entity[0]).toLowerCase());\n         }\n     }\n \n"}
{"identifier": "Jsoup-51", "buggy_code": "    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n", "fixed_code": "    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nboolean matchesLetter()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex a34311a..6b0b9fb 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -297,7 +297,7 @@ final class CharacterReader {\n         if (isEmpty())\n             return false;\n         char c = input[pos];\n-        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n     }\n \n     boolean matchesDigit() {\n"}
{"identifier": "Mockito-23", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\nindex b18dd3b..c4384f7 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n@@ -41,16 +41,14 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n     \n     private static final long serialVersionUID = -7105341425736035847L;\n \n-    private transient MockitoCore mockitoCore;\n-    private transient ReturnsEmptyValues delegate;\n+    private MockitoCore mockitoCore = new MockitoCore();\n+    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         GenericMetadataSupport returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n-        instantiateMockitoCoreIfNeeded();\n-        instantiateDelegateIfNeeded();\n         if (!mockitoCore.isTypeMockable(rawType)) {\n             return delegate.returnValueFor(rawType);\n         }\n@@ -58,17 +56,7 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n         return getMock(invocation, returnTypeGenericMetadata);\n     }\n \n-    private synchronized void instantiateMockitoCoreIfNeeded() {\n-        if (mockitoCore == null) {\n-            mockitoCore = new MockitoCore();\n-        }\n-    }\n \n-    private synchronized void instantiateDelegateIfNeeded() {\n-        if (delegate == null) {\n-            delegate = new ReturnsEmptyValues();\n-        }\n-    }\n \n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n@@ -109,7 +97,6 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n                 : withSettings();\n \n         return mockSettings\n-\t\t        .serializable()\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n     }\n \n@@ -124,7 +111,7 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n \n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n \n-        container.addAnswer(new SerializableAnswer() {\n+        container.addAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n                 return mock;\n             }\n@@ -133,9 +120,7 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n         return mock;\n     }\n \t\n-\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\n \t\t\n-\t}\n \t\n \n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\n"}
{"identifier": "Mockito-33", "buggy_code": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        \t/* Avoid unnecessary cloning */\n        return m1.equals(m2);\n    }\n", "fixed_code": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \t/* Avoid unnecessary cloning */\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic boolean hasSameMethod(Invocation candidate)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex ffad2b1..203413f 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -95,19 +95,8 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n-        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n         \t/* Avoid unnecessary cloning */\n-        \tClass[] params1 = m1.getParameterTypes();\n-        \tClass[] params2 = m2.getParameterTypes();\n-        \tif (params1.length == params2.length) {\n-        \t    for (int i = 0; i < params1.length; i++) {\n-        \t\tif (params1[i] != params2[i])\n-        \t\t    return false;\n-        \t    }\n-        \t    return true;\n-        \t}\n-        }\n-        return false;\n+        return m1.equals(m2);\n     }\n     \n     public Location getLocation() {\n"}
{"identifier": "Math-77", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\nindex 22d0a28..37c4417 100644\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n@@ -718,7 +718,7 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max = Math.max(max, Math.abs(a));\n+            max += Math.max(max, Math.abs(a));\n         }\n         return max;\n     }\ndiff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex eb5be1b..e025960 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,6 +495,15 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV\n         return max;\n     }\n \n+    public double getLInfNorm() {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            max += iter.value();\n+        }\n+        return max;\n+    }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from\n"}
{"identifier": "Lang-37", "buggy_code": "    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n            // Check if problem is incompatible types\n        return joinedArray;\n    }\n", "fixed_code": "    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem is incompatible types\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T[] addAll(T[] array1, T... array2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang3/ArrayUtils.java b/src/java/org/apache/commons/lang3/ArrayUtils.java\nindex b9413e8..889497e 100644\n--- a/src/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -2959,16 +2959,8 @@ public class ArrayUtils {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        try {\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        } catch (ArrayStoreException ase) {\n             // Check if problem is incompatible types\n-            final Class<?> type2 = array2.getClass().getComponentType();\n-            if (!type1.isAssignableFrom(type2)){\n-                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n-            }\n-            throw ase; // No, so rethrow original\n-        }\n         return joinedArray;\n     }\n \n"}
{"identifier": "Time-26", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 23f70a5c..9edb1888 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -933,15 +933,6 @@ public abstract class DateTimeZone implements Serializable {\n      * @throws IllegalArgumentException if the zone has no equivalent local time\n      * @since 2.0\n      */\n-    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n-        int offsetOriginal = getOffset(originalInstantUTC);\n-        long instantUTC = instantLocal - offsetOriginal;\n-        int offsetLocalFromOriginal = getOffset(instantUTC);\n-        if (offsetLocalFromOriginal == offsetOriginal) {\n-            return instantUTC;\n-        }\n-        return convertLocalToUTC(instantLocal, strict);\n-    }\n \n     /**\n      * Converts a local instant to a standard UTC instant with the same\ndiff --git a/src/main/java/org/joda/time/chrono/ZonedChronology.java b/src/main/java/org/joda/time/chrono/ZonedChronology.java\nindex 819f64e..f165f3d 100644\n--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java\n@@ -433,7 +433,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false, instant);\n+               return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n@@ -445,7 +445,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false, instant);\n+               return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n@@ -457,14 +457,14 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.addWrapField(localInstant, value);\n-                return iZone.convertLocalToUTC(localInstant, false, instant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n-            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n+            long result = iZone.convertLocalToUTC(localInstant, false);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +\n@@ -478,7 +478,7 @@ public final class ZonedChronology extends AssembledChronology {\n             // cannot verify that new value stuck because set may be lenient\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n-            return iZone.convertLocalToUTC(localInstant, false, instant);\n+            return iZone.convertLocalToUTC(localInstant, false);\n         }\n \n         public int getDifference(long minuendInstant, long subtrahendInstant) {\n@@ -525,7 +525,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundFloor(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false, instant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n@@ -537,7 +537,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false, instant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \ndiff --git a/src/main/java/org/joda/time/field/LenientDateTimeField.java b/src/main/java/org/joda/time/field/LenientDateTimeField.java\nindex 6cf4c718..450a4eff 100644\n--- a/src/main/java/org/joda/time/field/LenientDateTimeField.java\n+++ b/src/main/java/org/joda/time/field/LenientDateTimeField.java\n@@ -72,6 +72,6 @@ public class LenientDateTimeField extends DelegatedDateTimeField {\n         long localInstant = iBase.getZone().convertUTCToLocal(instant);\n         long difference = FieldUtils.safeSubtract(value, get(instant));\n         localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n-        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n+        return iBase.getZone().convertLocalToUTC(localInstant, false);\n     }\n }\n"}
{"identifier": "Gson-12", "buggy_code": "  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n        pathNames[stackSize - 1] = \"null\";\n    }\n      pathIndices[stackSize - 1]++;\n  }\n", "fixed_code": "  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n      if (stackSize > 0) {\n        pathNames[stackSize - 1] = \"null\";\n      }\n    }\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override public void skipValue() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\nindex 387b29e9..2e7644f0 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n@@ -259,13 +259,9 @@ public final class JsonTreeReader extends JsonReader {\n       pathNames[stackSize - 2] = \"null\";\n     } else {\n       popStack();\n-      if (stackSize > 0) {\n         pathNames[stackSize - 1] = \"null\";\n-      }\n     }\n-    if (stackSize > 0) {\n       pathIndices[stackSize - 1]++;\n-    }\n   }\n \n   @Override public String toString() {\n"}
{"identifier": "Closure-80", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex dfcd3eb..08fb954 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1259,7 +1259,6 @@ public final class NodeUtil {\n       // Inversion\n       case Token.NOT:\n       // delete operator returns a boolean.\n-      case Token.DELPROP:\n         return true;\n       default:\n         return false;\n@@ -2908,7 +2907,6 @@ public final class NodeUtil {\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n         return true;\n-      case Token.DELPROP:\n       case Token.IN:\n         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n         return true;\n"}
{"identifier": "Lang-42", "buggy_code": "    /**\n     * <p>\n     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n     * passed.\n     * </p>\n     * \n     * @param writer\n     *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n     * @param str\n     *            The <code>String</code> to escape. Assumed to be a non-null value.\n     * @throws IOException\n     *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n     *             methods.\n     * \n     * @see #escape(String)\n     * @see Writer\n     */\n    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        for (int i = 0; i < len; i++) {\n            char c = str.charAt(i);\n            String entityName = this.entityName(c);\n            if (entityName == null) {\n                if (c > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(c, 10));\n                    writer.write(';');\n                } else {\n                    writer.write(c);\n                }\n            } else {\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n     * passed.\n     * </p>\n     * \n     * @param writer\n     *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n     * @param str\n     *            The <code>String</code> to escape. Assumed to be a non-null value.\n     * @throws IOException\n     *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n     *             methods.\n     * \n     * @see #escape(String)\n     * @see Writer\n     */\n    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        for (int i = 0; i < len; i++) {\n            int c = Character.codePointAt(str, i); \n            String entityName = this.entityName(c);\n            if (entityName == null) {\n                if (c >= 0x010000 && i < len - 1) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(c, 10));\n                    writer.write(';');\n                    i++;\n                } else if (c > 0x7F) { \n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(c, 10));\n                    writer.write(';');\n                } else {\n                    writer.write(c);\n                }\n            } else {\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n     * passed.\n     * </p>\n     * \n     * @param writer\n     *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n     * @param str\n     *            The <code>String</code> to escape. Assumed to be a non-null value.\n     * @throws IOException\n     *             when <code>Writer</code> passed throws the exception from calls to the\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/Entities.java b/src/java/org/apache/commons/lang/Entities.java\nindex 0d8f7f4..900e1a8 100644\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n@@ -825,15 +825,10 @@ class Entities {\n     public void escape(Writer writer, String str) throws IOException {\n         int len = str.length();\n         for (int i = 0; i < len; i++) {\n-            int c = Character.codePointAt(str, i); \n+            char c = str.charAt(i);\n             String entityName = this.entityName(c);\n             if (entityName == null) {\n-                if (c >= 0x010000 && i < len - 1) {\n-                    writer.write(\"&#\");\n-                    writer.write(Integer.toString(c, 10));\n-                    writer.write(';');\n-                    i++;\n-                } else if (c > 0x7F) { \n+                if (c > 0x7F) {\n                     writer.write(\"&#\");\n                     writer.write(Integer.toString(c, 10));\n                     writer.write(';');\n"}
{"identifier": "Jsoup-7", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Document.java b/src/main/java/org/jsoup/nodes/Document.java\nindex 47632fc..2f37b29 100644\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n@@ -2,7 +2,6 @@ package org.jsoup.nodes;\n \n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.Elements;\n \n import java.nio.charset.Charset;\n import java.nio.charset.CharsetEncoder;\n@@ -111,8 +110,6 @@ public class Document extends Element {\n         normaliseTextNodes(htmlEl);\n         normaliseTextNodes(this);\n \n-        normaliseStructure(\"head\", htmlEl);\n-        normaliseStructure(\"body\", htmlEl);\n         \n         return this;\n     }\n@@ -137,26 +134,7 @@ public class Document extends Element {\n     }\n \n     // merge multiple <head> or <body> contents into one, delete the remainder, and ensure they are owned by <html>\n-    private void normaliseStructure(String tag, Element htmlEl) {\n-        Elements elements = this.getElementsByTag(tag);\n-        Element master = elements.first(); // will always be available as created above if not existent\n-        if (elements.size() > 1) { // dupes, move contents to master\n-            List<Node> toMove = new ArrayList<Node>();\n-            for (int i = 1; i < elements.size(); i++) {\n-                Node dupe = elements.get(i);\n-                for (Node node : dupe.childNodes)\n-                    toMove.add(node);\n-                dupe.remove();\n-            }\n-\n-            for (Node dupe : toMove)\n-                master.appendChild(dupe);\n-        }\n         // ensure parented by <html>\n-        if (!master.parent().equals(htmlEl)) {\n-            htmlEl.appendChild(master); // includes remove()            \n-        }\n-    }\n \n     // fast method to get first by tag name, used for html, head, body finders\n     private Element findFirstElementByTagName(String tag, Node node) {\n"}
{"identifier": "JacksonDatabind-60", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\nindex 538796def..c7cb812a0 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n@@ -6,7 +6,6 @@ import java.lang.reflect.Type;\n import java.util.LinkedHashSet;\n import java.util.Set;\n \n-import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n@@ -15,7 +14,6 @@ import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n-import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n@@ -225,8 +223,7 @@ public class JsonValueSerializer\n             // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n             //    to use different Object for type id (logical type) and actual serialization\n             //    (delegat type).\n-            TypeSerializerRerouter rr = new TypeSerializerRerouter(typeSer0, bean);\n-            ser.serializeWithType(value, gen, provider, rr);\n+            ser.serializeWithType(value, gen, provider, typeSer0);\n         } catch (IOException ioe) {\n             throw ioe;\n         } catch (Exception e) {\n@@ -363,108 +360,24 @@ public class JsonValueSerializer\n      * override Object to use for type id (logical type) even when asking serialization\n      * of something else (delegate type)\n      */\n-    static class TypeSerializerRerouter\n-        extends TypeSerializer\n-    {\n-        protected final TypeSerializer _typeSerializer;\n-        protected final Object _forObject;\n \n-        public TypeSerializerRerouter(TypeSerializer ts, Object ob) {\n-            _typeSerializer = ts;\n-            _forObject = ob;\n-        }\n \n-        @Override\n-        public TypeSerializer forProperty(BeanProperty prop) { // should never get called\n-            throw new UnsupportedOperationException();\n-        }\n \n-        @Override\n-        public As getTypeInclusion() {\n-            return _typeSerializer.getTypeInclusion();\n-        }\n \n-        @Override\n-        public String getPropertyName() {\n-            return _typeSerializer.getPropertyName();\n-        }\n \n-        @Override\n-        public TypeIdResolver getTypeIdResolver() {\n-            return _typeSerializer.getTypeIdResolver();\n-        }\n \n-        @Override\n-        public void writeTypePrefixForScalar(Object value, JsonGenerator gen) throws IOException {\n-            _typeSerializer.writeTypePrefixForScalar(_forObject, gen);\n-        }\n \n-        @Override\n-        public void writeTypePrefixForObject(Object value, JsonGenerator gen) throws IOException {\n-            _typeSerializer.writeTypePrefixForObject(_forObject, gen);\n-        }\n \n-        @Override\n-        public void writeTypePrefixForArray(Object value, JsonGenerator gen) throws IOException {\n-            _typeSerializer.writeTypePrefixForArray(_forObject, gen);\n-        }\n \n-        @Override\n-        public void writeTypeSuffixForScalar(Object value, JsonGenerator gen) throws IOException {\n-            _typeSerializer.writeTypeSuffixForScalar(_forObject, gen);\n-        }\n \n-        @Override\n-        public void writeTypeSuffixForObject(Object value, JsonGenerator gen) throws IOException {\n-            _typeSerializer.writeTypeSuffixForObject(_forObject, gen);\n-        }\n \n-        @Override\n-        public void writeTypeSuffixForArray(Object value, JsonGenerator gen) throws IOException {\n-            _typeSerializer.writeTypeSuffixForArray(_forObject, gen);\n-        }\n \n-        public void writeTypePrefixForScalar(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n-            _typeSerializer.writeTypePrefixForScalar(_forObject, gen, type);\n-        }\n \n-        public void writeTypePrefixForObject(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n-            _typeSerializer.writeTypePrefixForObject(_forObject, gen, type);\n-        }\n \n-        public void writeTypePrefixForArray(Object value, JsonGenerator gen, Class<?> type) throws IOException {\n-            _typeSerializer.writeTypePrefixForArray(_forObject, gen, type);\n-        }\n         \n-        @Override\n-        public void writeCustomTypePrefixForScalar(Object value, JsonGenerator gen, String typeId)\n-                throws IOException {\n-            _typeSerializer.writeCustomTypePrefixForScalar(_forObject, gen, typeId);\n-        }\n \n-        @Override\n-        public void writeCustomTypePrefixForObject(Object value, JsonGenerator gen, String typeId) throws IOException {\n-            _typeSerializer.writeCustomTypePrefixForObject(_forObject, gen, typeId);\n-        }\n \n-        @Override\n-        public void writeCustomTypePrefixForArray(Object value, JsonGenerator gen, String typeId) throws IOException {\n-            _typeSerializer.writeCustomTypePrefixForArray(_forObject, gen, typeId);\n-        }\n \n-        @Override\n-        public void writeCustomTypeSuffixForScalar(Object value, JsonGenerator gen, String typeId) throws IOException {\n-            _typeSerializer.writeCustomTypeSuffixForScalar(_forObject, gen, typeId);\n-        }\n \n-        @Override\n-        public void writeCustomTypeSuffixForObject(Object value, JsonGenerator gen, String typeId) throws IOException {\n-            _typeSerializer.writeCustomTypeSuffixForObject(_forObject, gen, typeId);\n-        }\n \n-        @Override\n-        public void writeCustomTypeSuffixForArray(Object value, JsonGenerator gen, String typeId) throws IOException {\n-            _typeSerializer.writeCustomTypeSuffixForArray(_forObject, gen, typeId);\n-        }\n-    }\n }\n"}
{"identifier": "Closure-46", "buggy_code": "  @Override\n  public JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }\n", "fixed_code": "", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public JSType getLeastSupertype(JSType that)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nindex b418dbd..7289803 100755\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -137,6 +137,22 @@ class RecordType extends PrototypeObjectType {\n         propertyNode);\n   }\n \n+  @Override\n+  public JSType getLeastSupertype(JSType that) {\n+    if (!that.isRecordType()) {\n+      return super.getLeastSupertype(that);\n+    }\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    for (String property : properties.keySet()) {\n+      if (that.toMaybeRecordType().hasProperty(property) &&\n+          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n+              getPropertyType(property))) {\n+        builder.addProperty(property, getPropertyType(property),\n+            getPropertyNode(property));\n+      }\n+    }\n+    return builder.build();\n+  }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n"}
{"identifier": "Lang-36", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang3/math/NumberUtils.java b/src/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 0d30b22..d3054f3 100644\n--- a/src/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -488,7 +488,7 @@ public class NumberUtils {\n             }\n             dec = null;\n         }\n-        if (!Character.isDigit(lastChar) && lastChar != '.') {\n+        if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n@@ -1385,14 +1385,6 @@ public class NumberUtils {\n                 // can't have an E at the last byte\n                 return false;\n             }\n-            if (chars[i] == '.') {\n-                if (hasDecPoint || hasExp) {\n-                    // two decimal points or dec in exponent\n-                    return false;\n-                }\n-                // single trailing decimal point after non-exponent is ok\n-                return foundDigit;\n-            }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n"}
{"identifier": "Compress-25", "buggy_code": "    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n    }\n", "fixed_code": "    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\nindex 9a3aa37f..38ae9568 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n@@ -181,7 +181,6 @@ public class ZipArchiveInputStream extends ArchiveInputStream {\n         this.allowStoredEntriesWithDataDescriptor =\n             allowStoredEntriesWithDataDescriptor;\n         // haven't read anything so far\n-        buf.limit(0);\n     }\n \n     public ZipArchiveEntry getNextZipEntry() throws IOException {\n"}
{"identifier": "Jsoup-73", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/W3CDom.java b/src/main/java/org/jsoup/helper/W3CDom.java\nindex 81ac932..ac71e59 100644\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n@@ -19,7 +19,6 @@ import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n import java.io.StringWriter;\n import java.util.HashMap;\n-import java.util.Stack;\n \n /**\n  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\n@@ -71,21 +70,19 @@ public class W3CDom {\n         private static final String xmlnsPrefix = \"xmlns:\";\n \n         private final Document doc;\n-        private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn\n+        private final HashMap<String, String> namespaces = new HashMap<>();\n         private Element dest;\n \n         public W3CBuilder(Document doc) {\n             this.doc = doc;\n-            this.namespacesStack.push(new HashMap<String, String>());\n         }\n \n         public void head(org.jsoup.nodes.Node source, int depth) {\n-            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n             if (source instanceof org.jsoup.nodes.Element) {\n                 org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n \n                 String prefix = updateNamespaces(sourceEl);\n-                String namespace = namespacesStack.peek().get(prefix);\n+                String namespace = namespaces.get(prefix);\n \n                 Element el = doc.createElementNS(namespace, sourceEl.tagName());\n                 copyAttributes(sourceEl, el);\n@@ -116,7 +113,6 @@ public class W3CDom {\n             if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                 dest = (Element) dest.getParentNode(); // undescend. cromulent.\n             }\n-            namespacesStack.pop();\n         }\n \n         private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n@@ -145,7 +141,7 @@ public class W3CDom {\n                 } else {\n                     continue;\n                 }\n-                namespacesStack.peek().put(prefix, attr.getValue());\n+                namespaces.put(prefix, attr.getValue());\n             }\n \n             // get the element prefix if any\n"}
{"identifier": "Compress-11", "buggy_code": "    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n", "fixed_code": "    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\nindex c831b60b..a30cd5a8 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n@@ -237,7 +237,6 @@ public class ArchiveStreamFactory {\n                 return new TarArchiveInputStream(in);\n             }\n             // COMPRESS-117 - improve auto-recognition\n-            if (signatureLength >= 512) {\n             try {\n                 TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 tais.getNextEntry();\n@@ -247,7 +246,6 @@ public class ArchiveStreamFactory {\n                 // autodetection, simply not a TAR\n                 // ignored\n             }\n-            }\n         } catch (IOException e) {\n             throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n         }\n"}
{"identifier": "Closure-115", "buggy_code": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n      }\n    }\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n", "fixed_code": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 5b38600..73d6a4b 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -694,6 +694,14 @@ class FunctionInjector {\n \n     Node block = fnNode.getLastChild();\n \n+    boolean hasSideEffects = false;\n+    if (block.hasChildren()) {\n+      Preconditions.checkState(block.hasOneChild());\n+      Node stmt = block.getFirstChild();\n+      if (stmt.isReturn()) {\n+        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n+      }\n+    }\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n \n@@ -719,6 +727,9 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+            return CanInlineResult.NO;\n+          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n"}
{"identifier": "Math-38", "buggy_code": "    /**\n     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n     *     NF and KOPT. The vector X is also changed by PRELIM.\n     *\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n     *       are the same as the corresponding arguments in BOBYQB, the elements\n     *       of SL and SU being set in BOBYQA.\n     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n     *     NF is maintaned as the number of calls of CALFUN so far.\n     *     KOPT will be such that the least calculated value of F so far is at\n     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     */\n    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n\n        // Set XBASE to the initial vector of variables, and set the initial\n        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n\n        // Begin the initialization procedure. NF becomes one more than the number\n        // of function values so far. The coordinates of the displacement of the\n        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n                    throw new PathIsExploredException(); // XXX\n                }\n                final int iptMinus1 = ipt;\n                final int jptMinus1 = jpt;\n                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n            }\n\n            // Calculate the next value of F. The least function value so far and\n            // its index are required.\n\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));\n                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                }\n                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n\n            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n            final double f = isMinimize ? objectiveValue : -objectiveValue;\n            final int numEval = getEvaluations(); // nfm + 1\n            fAtInterpolationPoints.setEntry(nfm, f);\n\n            if (numEval == 1) {\n                fbeg = f;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfm;\n            }\n\n            // Set the nonzero initial elements of BMAT and the quadratic model in the\n            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n            // order that the function value at the first of them contributes to the\n            // off-diagonal second derivative terms of the initial quadratic model.\n\n            if (numEval <= 2 * n + 1) {\n                if (numEval >= 2 &&\n                    numEval <= n + 1) {\n                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                    if (npt < numEval + n) {\n                        final double oneOverStepA = ONE / stepa;\n                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                        throw new PathIsExploredException(); // XXX\n                    }\n                } else if (numEval >= n + 2) {\n                    final int ih = nfx * (nfx + 1) / 2 - 1;\n                    final double tmp = (f - fbeg) / stepb;\n                    final double diff = stepb - stepa;\n                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                    if (stepa * stepb < ZERO) {\n                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                            fAtInterpolationPoints.setEntry(nfm - n, f);\n                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n                                trustRegionCenterInterpolationPointIndex = nfm - n;\n                            }\n                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n                        }\n                    }\n                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                    bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                }\n\n                // Set the off-diagonal second derivatives of the Lagrange functions and\n                // the initial quadratic model.\n\n            } else {\n                zMatrix.setEntry(0, nfxm, recip);\n                zMatrix.setEntry(nfm, nfxm, recip);\n                zMatrix.setEntry(ipt, nfxm, -recip);\n                zMatrix.setEntry(jpt, nfxm, -recip);\n\n                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n                throw new PathIsExploredException(); // XXX\n            }\n        } while (getEvaluations() < npt);\n    } // prelim\n", "fixed_code": "    /**\n     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n     *     NF and KOPT. The vector X is also changed by PRELIM.\n     *\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n     *       are the same as the corresponding arguments in BOBYQB, the elements\n     *       of SL and SU being set in BOBYQA.\n     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n     *     NF is maintaned as the number of calls of CALFUN so far.\n     *     KOPT will be such that the least calculated value of F so far is at\n     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     */\n    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n\n        // Set XBASE to the initial vector of variables, and set the initial\n        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n\n        // Begin the initialization procedure. NF becomes one more than the number\n        // of function values so far. The coordinates of the displacement of the\n        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n//                     throw new PathIsExploredException(); // XXX\n                }\n                final int iptMinus1 = ipt - 1;\n                final int jptMinus1 = jpt - 1;\n                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n            }\n\n            // Calculate the next value of F. The least function value so far and\n            // its index are required.\n\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));\n                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                }\n                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n\n            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n            final double f = isMinimize ? objectiveValue : -objectiveValue;\n            final int numEval = getEvaluations(); // nfm + 1\n            fAtInterpolationPoints.setEntry(nfm, f);\n\n            if (numEval == 1) {\n                fbeg = f;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfm;\n            }\n\n            // Set the nonzero initial elements of BMAT and the quadratic model in the\n            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n            // order that the function value at the first of them contributes to the\n            // off-diagonal second derivative terms of the initial quadratic model.\n\n            if (numEval <= 2 * n + 1) {\n                if (numEval >= 2 &&\n                    numEval <= n + 1) {\n                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                    if (npt < numEval + n) {\n                        final double oneOverStepA = ONE / stepa;\n                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                        throw new PathIsExploredException(); // XXX\n                    }\n                } else if (numEval >= n + 2) {\n                    final int ih = nfx * (nfx + 1) / 2 - 1;\n                    final double tmp = (f - fbeg) / stepb;\n                    final double diff = stepb - stepa;\n                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                    if (stepa * stepb < ZERO) {\n                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                            fAtInterpolationPoints.setEntry(nfm - n, f);\n                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n                                trustRegionCenterInterpolationPointIndex = nfm - n;\n                            }\n                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n                        }\n                    }\n                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                    bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                }\n\n                // Set the off-diagonal second derivatives of the Lagrange functions and\n                // the initial quadratic model.\n\n            } else {\n                zMatrix.setEntry(0, nfxm, recip);\n                zMatrix.setEntry(nfm, nfxm, recip);\n                zMatrix.setEntry(ipt, nfxm, -recip);\n                zMatrix.setEntry(jpt, nfxm, -recip);\n\n                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n//                 throw new PathIsExploredException(); // XXX\n            }\n        } while (getEvaluations() < npt);\n    } // prelim\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n     *     NF and KOPT. The vector X is also changed by PRELIM.\n     *\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n     *       are the same as the corresponding arguments in BOBYQB, the elements\n     *       of SL and SU being set in BOBYQA.\n     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n     *     NF is maintaned as the number of calls of CALFUN so far.\n     *     KOPT will be such that the least calculated value of F so far is at\n     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     */\n    private void prelim(double[] lowerBound,\n                        double[] upperBound)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\nindex ba3fe26..592a2e8 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n@@ -1657,10 +1657,10 @@ public class BOBYQAOptimizer\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\n-//                     throw new PathIsExploredException(); // XXX\n+                    throw new PathIsExploredException(); // XXX\n                 }\n-                final int iptMinus1 = ipt - 1;\n-                final int jptMinus1 = jpt - 1;\n+                final int iptMinus1 = ipt;\n+                final int jptMinus1 = jpt;\n                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }\n@@ -1749,7 +1749,7 @@ public class BOBYQAOptimizer\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-//                 throw new PathIsExploredException(); // XXX\n+                throw new PathIsExploredException(); // XXX\n             }\n         } while (getEvaluations() < npt);\n     } // prelim\n"}
{"identifier": "Math-74", "buggy_code": "  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale;\n          if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n            } else {\n              scale = vecAbsoluteTolerance;\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // rejecting the step would lead to a too small next step, we accept it\n                  loop = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n", "fixed_code": "  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // rejecting the step would lead to a too small next step, we accept it\n                  loop = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 1bbad3e..6f3e883 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -242,15 +242,12 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         if (firstTime) {\n-          final double[] scale = new double[y0.length];\n+          final double[] scale;\n           if (vecAbsoluteTolerance == null) {\n-              for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n-              }\n+              scale = new double[y0.length];\n+              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n             } else {\n-              for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n-              }\n+              scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n"}
{"identifier": "Closure-139", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex 22a51318..26655f17 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -278,9 +278,6 @@ class Normalize implements CompilerPass {\n           }\n           break;\n \n-        case Token.FUNCTION:\n-          normalizeFunctionDeclaration(n);\n-          break;\n       }\n     }\n \n@@ -292,13 +289,6 @@ class Normalize implements CompilerPass {\n      * to:\n      *    var f = function () {};\n      */\n-    private void normalizeFunctionDeclaration(Node n) {\n-      Preconditions.checkState(n.getType() == Token.FUNCTION);\n-      if (!NodeUtil.isFunctionAnonymous(n)\n-          && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n-        rewriteFunctionDeclaration(n);\n-      }\n-    }\n \n     /**\n      * Rewrite the function declaration from:\n@@ -316,23 +306,12 @@ class Normalize implements CompilerPass {\n      *         LP\n      *         BLOCK\n      */\n-    private void rewriteFunctionDeclaration(Node n) {\n       // Prepare a spot for the function.\n-      Node oldNameNode = n.getFirstChild();\n-      Node fnNameNode = oldNameNode.cloneNode();\n-      Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno());\n-      var.copyInformationFrom(n);\n \n       // Prepare the function\n-      oldNameNode.setString(\"\");\n \n       // Move the function\n-      Node parent = n.getParent();\n-      parent.replaceChild(n, var);\n-      fnNameNode.addChildToFront(n);\n \n-      reportCodeChange(\"Function declaration\");\n-    }\n \n     /**\n      * Do normalizations that introduce new siblings or parents.\n@@ -539,18 +518,8 @@ class Normalize implements CompilerPass {\n         Scope s, String name, Node n, Node parent, Node gramps,\n         Node nodeWithLineNumber) {\n       Preconditions.checkState(n.getType() == Token.NAME);\n-      Var v = s.getVar(name);\n+      if (parent.getType() == Token.VAR) {\n       // If name is \"arguments\", Var maybe null.\n-      Preconditions.checkState(\n-          v == null || v.getParentNode().getType() != Token.CATCH);\n-      if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-          s.undeclare(v);\n-          s.declare(name, n, n.getJSType(), v.input);\n-          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n-              v.getParentNode().getParent());\n-        }\n-      } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n \n         replaceVarWithAssignment(n, parent, gramps);\n"}
{"identifier": "Closure-98", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex da4ed3e..f053321 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -358,14 +358,6 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n       }\n \n       // Make sure this assignment is not in a loop.\n-      for (BasicBlock block = ref.getBasicBlock();\n-           block != null; block = block.getParent()) {\n-        if (block.isFunction) {\n-          break;\n-        } else if (block.isLoop) {\n-          return false;\n-        }\n-      }\n \n       return true;\n     }\n@@ -550,12 +542,10 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n     /**\n      * Whether this block denotes a function scope.\n      */\n-    private final boolean isFunction;\n \n     /**\n      * Whether this block denotes a loop.\n      */\n-    private final boolean isLoop;\n \n     /**\n      * Creates a new block.\n@@ -568,16 +558,7 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n       // only named functions may be hoisted.\n       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n \n-      this.isFunction = root.getType() == Token.FUNCTION;\n \n-      if (root.getParent() != null) {\n-        int pType = root.getParent().getType();\n-        this.isLoop = pType == Token.DO ||\n-            pType == Token.WHILE ||\n-            pType == Token.FOR;\n-      } else {\n-        this.isLoop = false;\n-      }\n     }\n \n     BasicBlock getParent() {\n"}
{"identifier": "Chart-20", "buggy_code": "    /**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, paint, stroke, alpha);\n        this.value = value;\n    }\n", "fixed_code": "    /**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n        this.value = value;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 58d5289..075683d 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,7 +92,7 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n+        super(paint, stroke, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n"}
{"identifier": "Mockito-19", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\nindex c17f961..67126af 100644\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n@@ -111,7 +111,7 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {\n     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n             Field field = it.next();\n-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();\n+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n             if (injected != null) {\n                 injectionOccurred |= true;\n                 mocks.remove(injected);\ndiff --git a/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java b/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\nindex aebf6f7..7bd7073 100644\n--- a/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n@@ -10,7 +10,6 @@ import org.mockito.internal.util.reflection.FieldSetter;\n \n import java.lang.reflect.Field;\n import java.util.Collection;\n-import java.util.List;\n \n /**\n  * This node returns an actual injecter which will be either :\n@@ -21,7 +20,7 @@ import java.util.List;\n  * </ul>\n  */\n public class FinalMockCandidateFilter implements MockCandidateFilter {\n-    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {\n+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n         if(mocks.size() == 1) {\n             final Object matchingMock = mocks.iterator().next();\n \ndiff --git a/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java b/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java\nindex 81a168b..7a2c087 100644\n--- a/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java\n@@ -6,14 +6,13 @@ package org.mockito.internal.configuration.injection.filter;\n \n import java.lang.reflect.Field;\n import java.util.Collection;\n-import java.util.List;\n \n public interface MockCandidateFilter {\n \n     OngoingInjecter filterCandidate(\n             Collection<Object> mocks,\n             Field fieldToBeInjected,\n-            List<Field> fields, Object instance\n+            Object fieldInstance\n     );\n \n }\ndiff --git a/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\nindex abc5d67..b95f31a 100644\n--- a/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n@@ -20,7 +20,7 @@ public class NameBasedCandidateFilter implements MockCandidateFilter {\n \t}\n \n \tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n-\t\t\tField field, List<Field> fields, Object fieldInstance) {\n+\t\t\tField field, Object fieldInstance) {\n \t\tList<Object> mockNameMatches = new ArrayList<Object>();\n \t\tif (mocks.size() > 1) {\n \t\t\tfor (Object mock : mocks) {\n@@ -28,7 +28,7 @@ public class NameBasedCandidateFilter implements MockCandidateFilter {\n \t\t\t\t\tmockNameMatches.add(mock);\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn next.filterCandidate(mockNameMatches, field, fields,\n+\t\t\treturn next.filterCandidate(mockNameMatches, field,\n \t\t\t\t\tfieldInstance);\n \t\t\t/*\n \t\t\t * In this case we have to check whether we have conflicting naming\n@@ -39,23 +39,7 @@ public class NameBasedCandidateFilter implements MockCandidateFilter {\n \t\t\t * whenever we find a field that does match its name with the mock\n \t\t\t * name, we should take that field instead.\n \t\t\t */\n-\t\t} else if (mocks.size() == 1) {\n-\t\t\tString mockName = mockUtil.getMockName(mocks.iterator().next())\n-\t\t\t\t\t.toString();\n-\n-\t\t\tfor (Field otherField : fields) {\n-\t\t\t\tif (!otherField.equals(field)\n-\t\t\t\t\t\t&& otherField.getType().equals(field.getType())\n-\t\t\t\t\t\t&& otherField.getName().equals(mockName)) {\n-\n-\t\t\t\t\treturn new OngoingInjecter() {\n-\t\t\t\t\t\tpublic Object thenInject() {\n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t};\n-\t\t\t\t}\n-\t\t\t}\n \t\t}\n-\t\treturn next.filterCandidate(mocks, field, fields, fieldInstance);\n+\t\treturn next.filterCandidate(mocks, field, fieldInstance);\n \t}\n }\ndiff --git a/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java\nindex ce7a349..dd79991 100644\n--- a/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java\n@@ -17,7 +17,7 @@ public class TypeBasedCandidateFilter implements MockCandidateFilter {\n         this.next = next;\n     }\n \n-    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {\n@@ -25,6 +25,6 @@ public class TypeBasedCandidateFilter implements MockCandidateFilter {\n             }\n         }\n \n-        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);\n+        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n     }\n }\n"}
{"identifier": "Math-53", "buggy_code": "    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n", "fixed_code": "    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex ab58c78..e0a8e97 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -150,9 +150,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        if (isNaN || rhs.isNaN) {\n-            return NaN;\n-        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n"}
{"identifier": "JacksonDatabind-36", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\nindex 3dddd771a..c788c62cb 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n@@ -247,15 +247,7 @@ public class StdDateFormat\n      * and not via underlying {@link Calendar} instance like base class\n      * does.\n      */\n-    @Override // since 2.7\n-    public void setLenient(boolean enabled) {\n-        Boolean newValue = enabled;\n-        if (_lenient != newValue) {\n-            _lenient = newValue;\n             // and since leniency settings may have been used:\n-            _clearFormats();\n-        }\n-    }\n \n     @Override // since 2.7\n     public boolean isLenient() {\n@@ -562,9 +554,6 @@ public class StdDateFormat\n                 df.setTimeZone(tz);\n             }\n         }\n-        if (lenient != null) {\n-            df.setLenient(lenient.booleanValue());\n-        }\n         return df;\n     }\n \n"}
{"identifier": "Cli-1", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli/CommandLine.java b/src/java/org/apache/commons/cli/CommandLine.java\nindex 3c82942..af1118d 100644\n--- a/src/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n@@ -16,11 +16,11 @@\n package org.apache.commons.cli;\n \n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n-import java.util.HashSet;\n+import java.util.Map;\n \n /** \n  * <p>Represents list of arguments parsed against\n@@ -43,10 +43,12 @@ public class CommandLine {\n     private List args = new LinkedList();\n \n     /** the processed options */\n-    private Set options = new HashSet();\n+    private Map options = new HashMap();\n+    private Map names = new HashMap();\n \n     /** Map of unique options for ease to get complete list of options */\n //    private Set allOptions = new HashSet();\n+    private Map hashcodeMap = new HashMap();\n \n     /**\n      * Creates a command line.\n@@ -64,7 +66,7 @@ public class CommandLine {\n      */\n     public boolean hasOption(String opt)\n     {\n-        return options.contains( resolveOption(opt));\n+        return options.containsKey(opt);\n     }\n \n     /** \n@@ -88,13 +90,12 @@ public class CommandLine {\n     {\n         String res = getOptionValue(opt);\n \n-        Option option = resolveOption(opt);\n-        if (option == null)\n+        if (!options.containsKey(opt))\n         {\n             return null;\n         }\n \n-        Object type = option.getType();\n+        Object type = ((Option) options.get(opt)).getType();\n \n         return (res == null)        ? null : TypeHandler.createValue(res, type);\n     }\n@@ -145,11 +146,16 @@ public class CommandLine {\n      */\n     public String[] getOptionValues(String opt)\n     {\n-        Option key = resolveOption( opt );\n+        opt = Util.stripLeadingHyphens(opt);\n \n-        if (options.contains(key))\n+        String key = opt;\n+        if (names.containsKey(opt))\n+        {\n+            key = (String) names.get(opt);\n+        }\n+        if (options.containsKey(key))\n         {\n-            return key.getValues();\n+            return ((Option) options.get(key)).getValues();\n         }\n \n         return null;\n@@ -160,24 +166,7 @@ public class CommandLine {\n      * @param opt short or long name of the option\n      * @return Canonicalized option\n      */\n-    private Option resolveOption( String opt )\n-    {\n-        opt = Util.stripLeadingHyphens(opt);\n-        for ( Iterator it = options.iterator(); it.hasNext(); )\n-        {\n-            Option option = (Option) it.next();\n-            if (opt.equals(option.getOpt()))\n-            {\n-                return option;\n-            }\n-            if (opt.equals( option.getLongOpt()))\n-            {\n-                return option;\n-        }\n \n-        }\n-        return null;\n-    }\n \n     /** \n      * Retrieves the array of values, if any, of an option.\n@@ -285,7 +274,17 @@ public class CommandLine {\n      */\n     void addOption(Option opt)\n     {\n-        options.add(opt);\n+        hashcodeMap.put(new Integer(opt.hashCode()), opt);\n+        String key = opt.getKey();\n+        if (key == null)\n+        {\n+            key = opt.getLongOpt();\n+        }\n+        else\n+        {\n+            names.put(opt.getLongOpt(), key);\n+        }\n+        options.put(key, opt);\n     }\n \n     /**\n@@ -296,7 +295,7 @@ public class CommandLine {\n      */\n     public Iterator iterator()\n     {\n-        return options.iterator();\n+        return hashcodeMap.values().iterator();\n     }\n \n     /**\n@@ -306,7 +305,7 @@ public class CommandLine {\n      */\n     public Option[] getOptions()\n     {\n-        Collection processed = options;\n+        Collection processed = options.values();\n \n         // reinitialise array\n         Option[] optionsArray = new Option[processed.size()];\n@@ -314,4 +313,4 @@ public class CommandLine {\n         // return the array\n         return (Option[]) processed.toArray(optionsArray);\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Jsoup-80", "buggy_code": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                    Element el = doc.child(0);\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                    insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n", "fixed_code": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                if (doc.childNodeSize() > 0) {\n                    Element el = doc.child(0);\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                    insert.attributes().addAll(el.attributes());\n                } // else, we couldn't parse it as a decl, so leave as a comment\n            }\n        }\n        insertNode(insert);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid insert(Token.Comment commentToken)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex aec5ba7..75374e4 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -88,11 +88,9 @@ public class XmlTreeBuilder extends TreeBuilder {\n             String data = comment.getData();\n             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                 Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n-                if (doc.childNodeSize() > 0) {\n                     Element el = doc.child(0);\n                     insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                     insert.attributes().addAll(el.attributes());\n-                } // else, we couldn't parse it as a decl, so leave as a comment\n             }\n         }\n         insertNode(insert);\n"}
{"identifier": "Lang-18", "buggy_code": "    /**\n     * <p>Returns a list of Rules given a pattern.</p>\n     *\n     * @return a {@code List} of Rule objects\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': // year (number)\n                if (tokenLen >= 4) {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                } else {\n                    rule = TwoDigitYearField.INSTANCE;\n                }\n                break;\n            case 'M': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n", "fixed_code": "    /**\n     * <p>Returns a list of Rules given a pattern.</p>\n     *\n     * @return a {@code List} of Rule objects\n     * @throws IllegalArgumentException if pattern is invalid\n     */\n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': // year (number)\n                if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                }\n                break;\n            case 'M': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Returns a list of Rules given a pattern.</p>\n     *\n     * @return a\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex 51da48e..e043323 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -492,10 +492,10 @@ public class FastDateFormat extends Format {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen == 2) {\n-                    rule = TwoDigitYearField.INSTANCE;\n+                if (tokenLen >= 4) {\n+                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                 } else {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n+                    rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n"}
{"identifier": "Math-29", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\nindex 294ac57..8214827 100644\n--- a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n@@ -346,9 +346,10 @@ public class OpenMapRealVector extends SparseRealVector\n          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n          * this[i] / v[i] = NaN, and not 0d.\n          */\n-        final int n = getDimension();\n-        for (int i = 0; i < n; i++) {\n-            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n         }\n         return res;\n     }\n@@ -370,18 +371,6 @@ public class OpenMapRealVector extends SparseRealVector\n          *\n          * These special cases are handled below.\n          */\n-        if (v.isNaN() || v.isInfinite()) {\n-            final int n = getDimension();\n-            for (int i = 0; i < n; i++) {\n-                final double y = v.getEntry(i);\n-                if (Double.isNaN(y)) {\n-                    res.setEntry(i, Double.NaN);\n-                } else if (Double.isInfinite(y)) {\n-                    final double x = this.getEntry(i);\n-                    res.setEntry(i, x * y);\n-                }\n-            }\n-        }\n         return res;\n     }\n \n"}
{"identifier": "JacksonDatabind-45", "buggy_code": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n\n            \t// Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n\n                if (format.getShape() == JsonFormat.Shape.STRING) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }\n", "fixed_code": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property != null) {\n            JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n            if (format != null) {\n\n            \t// Simple case first: serialize as numeric timestamp?\n                JsonFormat.Shape shape = format.getShape();\n                if (shape.isNumeric()) {\n                    return withFormat(Boolean.TRUE, null);\n                }\n\n                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                                || format.hasLocale() || format.hasTimeZone()) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    final Locale loc = format.hasLocale()\n                                    ? format.getLocale()\n                                    : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    df.setTimeZone(tz);\n                    return withFormat(Boolean.FALSE, df);\n                }\n            }\n        }\n        return this;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\nindex 68dbf403f..eec386efa 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n@@ -60,8 +60,7 @@ public abstract class DateTimeSerializerBase<T>\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n+                if (format.getShape() == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n"}
{"identifier": "Closure-146", "buggy_code": "  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        return new TypePair(null, null);\n\n      case FALSE:\n      case UNKNOWN:\n        return new TypePair(this, that);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }\n", "fixed_code": "  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        JSType noType = getNativeType(JSTypeNative.NO_TYPE);\n        return new TypePair(noType, noType);\n\n      case FALSE:\n      case UNKNOWN:\n        return new TypePair(this, that);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Computes the subset of\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex 1a7db7b0..aa8c7bc9 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -703,8 +703,7 @@ public abstract class JSType implements Serializable {\n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        JSType noType = getNativeType(JSTypeNative.NO_TYPE);\n-        return new TypePair(noType, noType);\n+        return new TypePair(null, null);\n \n       case FALSE:\n       case UNKNOWN:\n"}
{"identifier": "JacksonXml-3", "buggy_code": "    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n", "fixed_code": "    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = _xmlTokens.getText());\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\nindex c71cd1d..7b163ed 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n@@ -666,8 +666,9 @@ public class FromXmlParser\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n+            _currText = _xmlTokens.getText();\n             _currToken = JsonToken.VALUE_STRING;\n-            return (_currText = _xmlTokens.getText());\n+            break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n"}
{"identifier": "Jsoup-59", "buggy_code": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                    Attribute attribute;\n                    if (hasPendingAttributeValue)\n                        attribute = new Attribute(pendingAttributeName,\n                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                    else if (hasEmptyAttributeValue)\n                        attribute = new Attribute(pendingAttributeName, \"\");\n                    else\n                        attribute = new BooleanAttribute(pendingAttributeName);\n                    attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n", "fixed_code": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.length() > 0) {\n                    Attribute attribute;\n                    if (hasPendingAttributeValue)\n                        attribute = new Attribute(pendingAttributeName,\n                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                    else if (hasEmptyAttributeValue)\n                        attribute = new Attribute(pendingAttributeName, \"\");\n                    else\n                        attribute = new BooleanAttribute(pendingAttributeName);\n                    attributes.put(attribute);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nfinal void newAttribute()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java\nindex af51432..7dcfa2b 100644\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n@@ -104,7 +104,6 @@ abstract class Token {\n             if (pendingAttributeName != null) {\n                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                 pendingAttributeName = pendingAttributeName.trim();\n-                if (pendingAttributeName.length() > 0) {\n                     Attribute attribute;\n                     if (hasPendingAttributeValue)\n                         attribute = new Attribute(pendingAttributeName,\n@@ -114,7 +113,6 @@ abstract class Token {\n                     else\n                         attribute = new BooleanAttribute(pendingAttributeName);\n                     attributes.put(attribute);\n-                }\n             }\n             pendingAttributeName = null;\n             hasEmptyAttributeValue = false;\n"}
{"identifier": "Closure-162", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Scope.java b/src/com/google/javascript/jscomp/Scope.java\nindex 8b6b1a5..b6037cb 100644\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n@@ -565,9 +565,6 @@ public class Scope\n   /**\n    * Return an iterable over all of the variables declared in this scope.\n    */\n-  Iterable<Var> getVarIterable() {\n-    return vars.values();\n-  }\n \n   @Override\n   public Iterable<Var> getReferences(Var var) {\ndiff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex 2b447cc..5acf25a 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -223,7 +223,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n       if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(\n             n.getSourceFileName(), getSourceRegion(n));\n-        findAliases(t);\n       }\n     }\n \n@@ -269,28 +268,8 @@ class ScopedAliases implements HotSwapCompilerPass {\n       hasErrors = true;\n     }\n \n-    private void findAliases(NodeTraversal t) {\n-      Scope scope = t.getScope();\n-      for (Var v : scope.getVarIterable()) {\n-        Node n = v.getNode();\n-        int type = n.getType();\n-        Node parent = n.getParent();\n-        if (parent.getType() == Token.VAR) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-            String name = n.getString();\n-            Var aliasVar = scope.getVar(name);\n-            aliases.put(name, aliasVar);\n \n-            String qualifiedName =\n-                aliasVar.getInitialValue().getQualifiedName();\n-            transformation.addAlias(name, qualifiedName);\n-          } else {\n             // TODO(robbyw): Support using locals for private variables.\n-            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-          }\n-        }\n-      }\n-    }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n@@ -321,33 +300,32 @@ class ScopedAliases implements HotSwapCompilerPass {\n         validateScopeCall(t, n, n.getParent());\n       }\n \n-      if (t.getScopeDepth() < 2) {\n-        return;\n-      }\n \n-      int type = n.getType();\n-      Var aliasVar = null;\n-      if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-          aliasVar = lexicalVar;\n-        }\n-      }\n \n       // Validate the top level of the goog.scope block.\n       if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-          if (aliasVar.getNode() == n) {\n+        int type = n.getType();\n+        if (type == Token.NAME && parent.getType() == Token.VAR) {\n+          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n+            String name = n.getString();\n+            Var aliasVar = t.getScope().getVar(name);\n+            aliases.put(name, aliasVar);\n             aliasDefinitionsInOrder.add(n);\n \n+            String qualifiedName =\n+                aliasVar.getInitialValue().getQualifiedName();\n+            transformation.addAlias(name, qualifiedName);\n             // Return early, to ensure that we don't record a definition\n             // twice.\n             return;\n           } else {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n           }\n         }\n+        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n+            n == parent.getFirstChild()) {\n+            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+        }\n \n         if (type == Token.RETURN) {\n           report(t, n, GOOG_SCOPE_USES_RETURN);\n@@ -361,7 +339,11 @@ class ScopedAliases implements HotSwapCompilerPass {\n       // Validate all descendent scopes of the goog.scope block.\n       if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n-        if (aliasVar != null) {\n+        if (n.getType() == Token.NAME) {\n+          String name = n.getString();\n+          Var aliasVar = aliases.get(name);\n+          if (aliasVar != null &&\n+              t.getScope().getVar(name) == aliasVar) {\n           // Note, to support the transitive case, it's important we don't\n           // clone aliasedNode here.  For example,\n           // var g = goog; var d = g.dom; d.createElement('DIV');\n@@ -370,6 +352,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n           // with <code>g.dom.createElement('DIV')</code>.\n           Node aliasedNode = aliasVar.getInitialValue();\n           aliasUsages.add(new AliasedNode(n, aliasedNode));\n+          }\n         }\n \n         JSDocInfo info = n.getJSDocInfo();\n"}
{"identifier": "Closure-77", "buggy_code": "  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n", "fixed_code": "  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 22df685..8cd3ab9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -963,7 +963,6 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n"}
{"identifier": "Lang-11", "buggy_code": "    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@code Integer.MAX_VALUE}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                \n                }\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if (letters && Character.isLetter(ch)\n                    || numbers && Character.isDigit(ch)\n                    || !letters && !numbers) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n", "fixed_code": "    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@code Integer.MAX_VALUE}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                \n                }\n            }\n        } else {\n            if (end <= start) {\n                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if (letters && Character.isLetter(ch)\n                    || numbers && Character.isDigit(ch)\n                    || !letters && !numbers) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\nindex 9dfee22..a799057 100644\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -242,10 +242,6 @@ public class RandomStringUtils {\n                     start = ' ';                \n                 }\n             }\n-        } else {\n-            if (end <= start) {\n-                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n-            }\n         }\n \n         char[] buffer = new char[count];\n"}
{"identifier": "Closure-74", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 9d2f97a..a61bb6c 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -904,8 +904,8 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           && right.getString().equals(\"undefined\"))\n           || (Token.VOID == right.getType()\n               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n-    int lhType = getNormalizedNodeType(left);\n-    int rhType = getNormalizedNodeType(right);\n+    int lhType = left.getType();\n+    int rhType = right.getType();\n     switch (lhType) {\n       case Token.VOID:\n         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n@@ -1071,19 +1071,6 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n   /**\n    * @return Translate NOT expressions into TRUE or FALSE when possible.\n    */\n-  private int getNormalizedNodeType(Node n) {\n-    int type = n.getType();\n-    if (type == Token.NOT) {\n-      TernaryValue value = NodeUtil.getPureBooleanValue(n);\n-      switch (value) {\n-        case TRUE:\n-          return Token.TRUE;\n-        case FALSE:\n-          return Token.FALSE;\n-      }\n-    }\n-    return type;\n-  }\n \n   /**\n    * The result of the comparison as a Boolean or null if the\n"}
{"identifier": "Closure-105", "buggy_code": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n\n    if (sb.length() > 0) {\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n", "fixed_code": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb != null) {\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n\n    if (sb != null) {\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FoldConstants.java b/src/com/google/javascript/jscomp/FoldConstants.java\nindex 657ee0a..f6d6a27 100644\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n@@ -1474,24 +1474,22 @@ class FoldConstants extends AbstractPostOrderCallback\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = null;\n+    StringBuilder sb = new StringBuilder();\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     // Merges adjacent String nodes.\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb == null) {\n-          sb = new StringBuilder();\n-        } else {\n+        if (sb.length() > 0) {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n-        if (sb != null) {\n+        if (sb.length() > 0) {\n           // + 2 for the quotes.\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = null;\n+          sb = new StringBuilder();\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);\n@@ -1499,7 +1497,7 @@ class FoldConstants extends AbstractPostOrderCallback\n       elem = elem.getNext();\n     }\n \n-    if (sb != null) {\n+    if (sb.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n"}
{"identifier": "Jsoup-17", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/TreeBuilderState.java b/src/main/java/org/jsoup/parser/TreeBuilderState.java\nindex 9fd235c..4ae01e1 100644\n--- a/src/main/java/org/jsoup/parser/TreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilderState.java\n@@ -1448,7 +1448,7 @@ enum TreeBuilderState {\n         }\n     };\n \n-    private static String nullString = String.valueOf('\\u0000');\n+    private static String nullString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n"}
{"identifier": "Closure-138", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\nindex 7bfbae52..720b60b7 100644\n--- a/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n@@ -205,6 +205,7 @@ class ClosureReverseAbstractInterpreter\n       Node param = condition.getLastChild();\n       if (callee.getType() == GETPROP && param.isQualifiedName()) {\n         JSType paramType =  getTypeIfRefinable(param, blindScope);\n+        if (paramType != null) {\n         Node left = callee.getFirstChild();\n         Node right = callee.getLastChild();\n         if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n@@ -214,6 +215,7 @@ class ClosureReverseAbstractInterpreter\n           if (restricter != null) {\n             return restrictParameter(param, paramType, blindScope, restricter,\n                 outcome);\n+            }\n           }\n         }\n       }\ndiff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 749eb6d3..1b3755d2 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -629,29 +629,21 @@ class TypeInference\n       return scope;\n     } else {\n       StaticSlot<JSType> var = scope.getSlot(varName);\n-      if (var != null) {\n+      if (var != null &&\n+          !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\n         // There are two situations where we don't want to use type information\n         // from the scope, even if we have it.\n \n         // 1) The var is escaped in a weird way, e.g.,\n         // function f() { var x = 3; function g() { x = null } (x); }\n-        boolean isInferred = var.isTypeInferred();\n-        boolean unflowable =\n-            isInferred && unflowableVarNames.contains(varName);\n \n         // 2) We're reading type information from another scope for an\n         // inferred variable.\n         // var t = null; function f() { (t); }\n-        boolean nonLocalInferredSlot =\n-            isInferred &&\n-            syntacticScope.getParent() != null &&\n-            var == syntacticScope.getParent().getSlot(varName);\n \n-        if (!unflowable && !nonLocalInferredSlot) {\n           type = var.getType();\n           if (type == null) {\n             type = getNativeType(UNKNOWN_TYPE);\n-          }\n         }\n       }\n     }\n"}
{"identifier": "Closure-158", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\nindex e2e102c..3a7f427 100644\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n@@ -194,11 +194,12 @@ abstract class AbstractCommandLineRunner<A extends Compiler,\n       throws FlagUsageException, IOException {\n     DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n \n-    if (config.warningGuards != null) {\n-      for (WarningGuardSpec.Entry entry : config.warningGuards.entries) {\n-        diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level);\n-      }\n-    }\n+    diagnosticGroups.setWarningLevels(\n+        options, config.jscompError, CheckLevel.ERROR);\n+    diagnosticGroups.setWarningLevels(\n+        options, config.jscompWarning, CheckLevel.WARNING);\n+    diagnosticGroups.setWarningLevels(\n+        options, config.jscompOff, CheckLevel.OFF);\n \n     createDefineOrTweakReplacements(config.define, options, false);\n \n@@ -1493,13 +1494,26 @@ abstract class AbstractCommandLineRunner<A extends Compiler,\n       return this;\n     }\n \n-    private WarningGuardSpec warningGuards = null;\n+    private final List<String> jscompError = Lists.newArrayList();\n \n     /**\n      * Add warning guards.\n      */\n-    CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) {\n-      this.warningGuards = spec;\n+    CommandLineConfig setJscompError(List<String> jscompError) {\n+      this.jscompError.clear();\n+      this.jscompError.addAll(jscompError);\n+      return this;\n+    }\n+    private final List<String> jscompWarning = Lists.newArrayList();\n+    CommandLineConfig setJscompWarning(List<String> jscompWarning) {\n+      this.jscompWarning.clear();\n+      this.jscompWarning.addAll(jscompWarning);\n+      return this;\n+    }\n+    private final List<String> jscompOff = Lists.newArrayList();\n+    CommandLineConfig setJscompOff(List<String> jscompOff) {\n+      this.jscompOff.clear();\n+      this.jscompOff.addAll(jscompOff);\n       return this;\n     }\n \n@@ -1611,26 +1625,9 @@ abstract class AbstractCommandLineRunner<A extends Compiler,\n    * A little helper class to make it easier to collect warning types\n    * from --jscomp_error, --jscomp_warning, and --jscomp_off.\n    */\n-  protected static class WarningGuardSpec {\n-    private static class Entry {\n-      private final CheckLevel level;\n-      private final String groupName;\n-\n-      private Entry(CheckLevel level, String groupName) {\n-        this.level = level;\n-        this.groupName = groupName;\n-      }\n-    }\n+\n \n     // The entries, in the order that they were added.\n-    private final List<Entry> entries = Lists.newArrayList();\n \n-    protected void add(CheckLevel level, String groupName) {\n-      entries.add(new Entry(level, groupName));\n-    }\n \n-    protected void clear() {\n-      entries.clear();\n-    }\n-  }\n }\ndiff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex b1a7472..d9a381b 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -23,7 +23,6 @@ import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n import com.google.common.io.LimitInputStream;\n-import com.google.javascript.jscomp.AbstractCommandLineRunner.WarningGuardSpec;\n \n import org.kohsuke.args4j.CmdLineException;\n import org.kohsuke.args4j.CmdLineParser;\n@@ -92,8 +91,6 @@ public class CommandLineRunner extends\n   // I don't really care about unchecked warnings in this class.\n   @SuppressWarnings(\"unchecked\")\n   private static class Flags {\n-    private static final WarningGuardSpec warningGuardSpec =\n-        new WarningGuardSpec();\n \n     @Option(name = \"--help\",\n         handler = BooleanOptionHandler.class,\n@@ -231,19 +228,16 @@ public class CommandLineRunner extends\n     private String create_source_map = \"\";\n \n     @Option(name = \"--jscomp_error\",\n-        handler = WarningGuardErrorOptionHandler.class,\n         usage = \"Make the named class of warnings an error. Options:\" +\n         DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n     private List<String> jscomp_error = Lists.newArrayList();\n \n     @Option(name = \"--jscomp_warning\",\n-        handler = WarningGuardWarningOptionHandler.class,\n         usage = \"Make the named class of warnings a normal warning. \" +\n         \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n     private List<String> jscomp_warning = Lists.newArrayList();\n \n     @Option(name = \"--jscomp_off\",\n-        handler = WarningGuardOffOptionHandler.class,\n         usage = \"Turn off the named class of warnings. Options:\" +\n         DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n     private List<String> jscomp_off = Lists.newArrayList();\n@@ -392,52 +386,13 @@ public class CommandLineRunner extends\n \n     // Our own parser for warning guards that preserves the original order\n     // of the flags.\n-    public static class WarningGuardErrorOptionHandler\n-        extends StringOptionHandler {\n-      public WarningGuardErrorOptionHandler(\n-          CmdLineParser parser, OptionDef option,\n-          Setter<? super String> setter) {\n-        super(parser, option, new WarningGuardSetter(setter, CheckLevel.ERROR));\n-      }\n-    }\n \n-    public static class WarningGuardWarningOptionHandler\n-        extends StringOptionHandler {\n-      public WarningGuardWarningOptionHandler(\n-          CmdLineParser parser, OptionDef option,\n-          Setter<? super String> setter) {\n-        super(parser, option,\n-            new WarningGuardSetter(setter, CheckLevel.WARNING));\n-      }\n-    }\n \n-    public static class WarningGuardOffOptionHandler\n-        extends StringOptionHandler {\n-      public WarningGuardOffOptionHandler(\n-          CmdLineParser parser, OptionDef option,\n-          Setter<? super String> setter) {\n-        super(parser, option, new WarningGuardSetter(setter, CheckLevel.OFF));\n-      }\n-    }\n \n-    private static class WarningGuardSetter implements Setter {\n-      private final Setter proxy;\n-      private final CheckLevel level;\n \n-      private WarningGuardSetter(Setter proxy, CheckLevel level) {\n-        this.proxy = proxy;\n-        this.level = level;\n-      }\n \n-      @Override public boolean isMultiValued() { return proxy.isMultiValued(); }\n \n-      @Override public Class getType() { return proxy.getType(); }\n \n-      @Override public void addValue(Object value) throws CmdLineException {\n-        proxy.addValue((String) value);\n-        warningGuardSpec.add(level, (String) value);\n-      }\n-    }\n   }\n \n   /**\n@@ -527,7 +482,6 @@ public class CommandLineRunner extends\n     List<String> processedFileArgs\n         = processArgs(argsInFile.toArray(new String[] {}));\n     CmdLineParser parserFileArgs = new CmdLineParser(flags);\n-    Flags.warningGuardSpec.clear();\n     parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\n \n     // Currently we are not supporting this (prevent direct/indirect loops)\n@@ -543,7 +497,6 @@ public class CommandLineRunner extends\n     List<String> processedArgs = processArgs(args);\n \n     CmdLineParser parser = new CmdLineParser(flags);\n-    Flags.warningGuardSpec.clear();\n     isConfigValid = true;\n     try {\n       parser.parseArgument(processedArgs.toArray(new String[] {}));\n@@ -596,7 +549,9 @@ public class CommandLineRunner extends\n           .setModuleWrapper(flags.module_wrapper)\n           .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n           .setCreateSourceMap(flags.create_source_map)\n-          .setWarningGuardSpec(Flags.warningGuardSpec)\n+          .setJscompError(flags.jscomp_error)\n+          .setJscompWarning(flags.jscomp_warning)\n+          .setJscompOff(flags.jscomp_off)\n           .setDefine(flags.define)\n           .setCharset(flags.charset)\n           .setManageClosureDependencies(flags.manage_closure_dependencies)\ndiff --git a/src/com/google/javascript/jscomp/DiagnosticGroups.java b/src/com/google/javascript/jscomp/DiagnosticGroups.java\nindex cf0beda..d2d38c5 100644\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n@@ -182,10 +182,12 @@ public class DiagnosticGroups {\n   /**\n    * Adds warning levels by name.\n    */\n-  void setWarningLevel(CompilerOptions options,\n-      String name, CheckLevel level) {\n+  void setWarningLevels(CompilerOptions options,\n+      java.util.List<String> diagnosticGroups, CheckLevel level) {\n+    for (String name : diagnosticGroups) {\n     DiagnosticGroup group = forName(name);\n     Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n     options.setWarningLevel(group, level);\n+    }\n   }\n }\n"}
{"identifier": "Math-28", "buggy_code": "    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n", "fixed_code": "    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n            if (tableau.getNumArtificialVariables() > 0) {\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n            }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n            if (getIterations() < getMaxIterations() / 2) {\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n            }\n        }\n        return minRatioPositions.get(0);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex dec310b..a84438d 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -116,7 +116,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n-            if (tableau.getNumArtificialVariables() > 0) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n@@ -126,7 +125,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n                         }\n                     }\n                 }\n-            }\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n@@ -137,7 +135,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             // Additional heuristic: if we did not get a solution after half of maxIterations\n             //                       revert to the simple case of just returning the top-most row\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n-            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n@@ -152,7 +149,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n                     }\n                 }\n                 return minRow;\n-            }\n         }\n         return minRatioPositions.get(0);\n     }\n"}
{"identifier": "JxPath-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex 1ad9324..5236867 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -293,11 +293,12 @@ public class DOMNodePointer extends NodePointer {\n                 : current.toUpperCase().startsWith(lang.toUpperCase());\n     }\n \n-    protected static String findEnclosingAttribute(Node n, String attrName) {\n+    protected String getLanguage() {\n+        Node n = node;\n         while (n != null) {\n             if (n.getNodeType() == Node.ELEMENT_NODE) {\n                 Element e = (Element) n;\n-                String attr = e.getAttribute(attrName);\n+                String attr = e.getAttribute(\"xml:lang\");\n                 if (attr != null && !attr.equals(\"\")) {\n                     return attr;\n                 }\n@@ -307,9 +308,6 @@ public class DOMNodePointer extends NodePointer {\n         return null;\n     }\n \n-    protected String getLanguage() {\n-        return findEnclosingAttribute(node, \"xml:lang\");\n-    }\n \n     /**\n      * Sets contents of the node to the specified value. If the value is\n@@ -631,34 +629,35 @@ public class DOMNodePointer extends NodePointer {\n     }\n \n     public Object getValue() {\n-        if (node.getNodeType() == Node.COMMENT_NODE) {\n-            String text = ((Comment) node).getData();\n-            return text == null ? \"\" : text.trim();\n-        }\n         return stringValue(node);\n     }\n \n     private String stringValue(Node node) {\n         int nodeType = node.getNodeType();\n         if (nodeType == Node.COMMENT_NODE) {\n-            return \"\";\n+            String text = ((Comment) node).getData();\n+            return text == null ? \"\" : text.trim();\n         }\n-        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"xml:space\"));\n         if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\n             String text = node.getNodeValue();\n-            return text == null ? \"\" : trim ? text.trim() : text;\n+            return text == null ? \"\" : text.trim();\n         }\n         if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n             String text = ((ProcessingInstruction) node).getData();\n-            return text == null ? \"\" : trim ? text.trim() : text;\n+            return text == null ? \"\" : text.trim();\n         }\n         NodeList list = node.getChildNodes();\n         StringBuffer buf = new StringBuffer(16);\n         for (int i = 0; i < list.getLength(); i++) {\n             Node child = list.item(i);\n+            if (child.getNodeType() == Node.TEXT_NODE) {\n+                buf.append(child.getNodeValue());\n+            }\n+            else {\n             buf.append(stringValue(child));\n+            }\n         }\n-        return buf.toString();\n+        return buf.toString().trim();\n     }\n \n     /**\ndiff --git a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\nindex a26f118..975dbc4 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n@@ -237,14 +237,7 @@ public class JDOMNodePointer extends NodePointer {\n \n     public Object getValue() {\n         if (node instanceof Element) {\n-            StringBuffer buf = new StringBuffer();\n-            for (NodeIterator children = childIterator(null, false, null); children.setPosition(children.getPosition() + 1);) {\n-                NodePointer ptr = children.getNodePointer();\n-                if (ptr.getImmediateNode() instanceof Element || ptr.getImmediateNode() instanceof Text) {\n-                    buf.append(ptr.getValue());\n-                }\n-            }\n-            return buf.toString();\n+            return ((Element) node).getTextTrim();\n         }\n         if (node instanceof Comment) {\n             String text = ((Comment) node).getText();\n@@ -253,15 +246,20 @@ public class JDOMNodePointer extends NodePointer {\n             }\n             return text;\n         }\n-        String result = null;\n         if (node instanceof Text) {\n-            result = ((Text) node).getText();\n+            return ((Text) node).getTextTrim();\n+        }\n+        if (node instanceof CDATA) {\n+            return ((CDATA) node).getTextTrim();\n         }\n         if (node instanceof ProcessingInstruction) {\n-            result = ((ProcessingInstruction) node).getData();\n+            String text = ((ProcessingInstruction) node).getData();\n+            if (text != null) {\n+                text = text.trim();\n+            }\n+            return text;\n         }\n-        boolean trim = !\"preserve\".equals(findEnclosingAttribute(node, \"space\", Namespace.XML_NAMESPACE));\n-        return result != null && trim ? result.trim() : result;\n+        return null;\n     }\n \n     public void setValue(Object value) {\n@@ -435,14 +433,12 @@ public class JDOMNodePointer extends NodePointer {\n     }\n \n     protected String getLanguage() {\n-        return findEnclosingAttribute(node, \"lang\", Namespace.XML_NAMESPACE);\n-    }\n-\n-    protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {\n+        Object n = node;\n         while (n != null) {\n             if (n instanceof Element) {\n                 Element e = (Element) n;\n-                String attr = e.getAttributeValue(attrName, ns);\n+                String attr =\n+                    e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n                 if (attr != null && !attr.equals(\"\")) {\n                     return attr;\n                 }\n@@ -757,4 +753,4 @@ public class JDOMNodePointer extends NodePointer {\n         return factory;\n     }\n \n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Math-44", "buggy_code": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            resetOccurred = false;\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // trigger the event\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                if (currentEvent.reset(eventT, eventY)) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n", "fixed_code": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // trigger the event\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                if (currentEvent.reset(eventT, eventY)) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\nindex 8f315e3..544124f 100644\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n@@ -277,6 +277,7 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n \n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n+            resetOccurred = false;\n \n             // initialize the events states if needed\n             if (! statesInitialized) {\n@@ -330,9 +331,6 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n@@ -342,9 +340,6 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n"}
{"identifier": "Closure-135", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\nindex e7cfc6d9..a42dc347 100644\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n@@ -359,7 +359,6 @@ class DevirtualizePrototypeMethods implements CompilerPass {\n     for (Node child : node.children()) {\n       if (NodeUtil.isThis(child)) {\n         Node newName = Node.newString(Token.NAME, name);\n-        newName.setJSType(child.getJSType());\n         node.replaceChild(child, newName);\n       } else {\n         replaceReferencesToThis(child, name);\ndiff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex b318d8a6..3e8ab079 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -409,10 +409,6 @@ public class FunctionType extends PrototypeObjectType {\n     return super.hasProperty(name) || \"prototype\".equals(name);\n   }\n \n-  @Override\n-  public boolean hasOwnProperty(String name) {\n-    return super.hasOwnProperty(name) || \"prototype\".equals(name);\n-  }\n \n   @Override\n   public JSType getPropertyType(String name) {\n@@ -473,9 +469,6 @@ public class FunctionType extends PrototypeObjectType {\n     if (\"prototype\".equals(name)) {\n       ObjectType objType = type.toObjectType();\n       if (objType != null) {\n-        if (objType.equals(prototype)) {\n-          return true;\n-        }\n         return setPrototype(\n             new FunctionPrototypeType(\n                 registry, this, objType, isNativeObjectType()));\n"}
{"identifier": "Mockito-22", "buggy_code": "    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }\n", "fixed_code": "    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == o2 ) {\n            return true;\n\t} else if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic static boolean areEqual(Object o1, Object o2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/matchers/Equality.java b/src/org/mockito/internal/matchers/Equality.java\nindex 0791441..43e11fc 100644\n--- a/src/org/mockito/internal/matchers/Equality.java\n+++ b/src/org/mockito/internal/matchers/Equality.java\n@@ -10,9 +10,7 @@ import java.lang.reflect.Array;\n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == o2 ) {\n-            return true;\n-\t} else if (o1 == null || o2 == null) {\n+        if (o1 == null || o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n"}
{"identifier": "Compress-45", "buggy_code": "    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        }\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n", "fixed_code": "    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * \n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     * \n     * Uses\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex d132d9d0..39ce5c1a 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -484,9 +484,8 @@ public static int formatLongOctalOrBinaryBytes(\n \n         if (length < 9) {\n             formatLongBinary(value, buf, offset, length, negative);\n-        } else {\n-            formatBigIntegerBinary(value, buf, offset, length, negative);\n         }\n+        formatBigIntegerBinary(value, buf, offset, length, negative);\n \n         buf[offset] = (byte) (negative ? 0xff : 0x80);\n         return offset + length;\n"}
{"identifier": "Lang-45", "buggy_code": "    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n", "fixed_code": "    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        if (lower > str.length()) {\n            lower = str.length();    \n        }\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 91c6615..42bd883 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -613,9 +613,6 @@ public class WordUtils {\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n-        if (lower > str.length()) {\n-            lower = str.length();    \n-        }\n         // if the upper value is -1 (i.e. no limit) or is greater\n         // than the length of the string, set to the length of the string\n         if (upper == -1 || upper > str.length()) {\n"}
{"identifier": "Chart-15", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/chart/plot/PiePlot.java b/source/org/jfree/chart/plot/PiePlot.java\nindex 7c3cd04..f575e72 100644\n--- a/source/org/jfree/chart/plot/PiePlot.java\n+++ b/source/org/jfree/chart/plot/PiePlot.java\n@@ -1375,9 +1375,6 @@ public class PiePlot extends Plot implements Cloneable, Serializable {\n      * @return The percent.\n      */\n     public double getMaximumExplodePercent() {\n-        if (this.dataset == null) {\n-            return 0.0;\n-        }\n         double result = 0.0;\n         Iterator iterator = this.dataset.getKeys().iterator();\n         while (iterator.hasNext()) {\n@@ -2051,10 +2048,8 @@ public class PiePlot extends Plot implements Cloneable, Serializable {\n      \n         PiePlotState state = new PiePlotState(info);\n         state.setPassesRequired(2);\n-        if (this.dataset != null) {\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                     plot.getDataset()));\n-        }\n         state.setLatestAngle(plot.getStartAngle());\n         return state;\n         \n"}
{"identifier": "Math-20", "buggy_code": "        /**\n         * @param x Normalized objective variables.\n         * @return the original objective variables, possibly repaired.\n         */\n        public double[] repairAndDecode(final double[] x) {\n            return\n                decode(x);\n        }\n", "fixed_code": "        /**\n         * @param x Normalized objective variables.\n         * @return the original objective variables, possibly repaired.\n         */\n        public double[] repairAndDecode(final double[] x) {\n            return boundaries != null && isRepairMode ?\n                decode(repair(x)) :\n                decode(x);\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n         * @param x Normalized objective variables.\n         * @return the original objective variables, possibly repaired.\n         */\n        public double[] repairAndDecode(final double[] x)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex b54cb37..4b7dbf6 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -918,8 +918,7 @@ public class CMAESOptimizer\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return boundaries != null && isRepairMode ?\n-                decode(repair(x)) :\n+            return\n                 decode(x);\n         }\n \n"}
{"identifier": "Lang-26", "buggy_code": "    /**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n", "fixed_code": "    /**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date) {\n        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n        c.setTime(date);\n        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Formats a <code>Date</code> object.</p>\n     * \n     * @param date  the date to format\n     * @return the formatted string\n     */\n    public String format(Date date)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex 95925fc..e30da2a 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -817,7 +817,7 @@ public class FastDateFormat extends Format {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n+        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n"}
{"identifier": "Cli-15", "buggy_code": "    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        // augment the list with the default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n                // if there are more default values as specified, add them to\n                // the list.\n                    // copy the list first\n        \n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n", "fixed_code": "    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if (defaultValues == null || defaultValues.isEmpty()) {\n            defaultValues = (List) this.defaultValues.get(option);\n        }\n\n        // augment the list with the default values\n        if (defaultValues != null && !defaultValues.isEmpty()) {\n            if (valueList == null || valueList.isEmpty()) {\n                valueList = defaultValues;\n            } else {\n                // if there are more default values as specified, add them to\n                // the list.\n                if (defaultValues.size() > valueList.size()) {\n                    // copy the list first\n                    valueList = new ArrayList(valueList);\n                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                        valueList.add(defaultValues.get(i));\n                    }\n                }\n            }\n        }\n        \n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic List getValues(final Option option,\n                          List defaultValues)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\nindex 319f8c2..3ca952d 100644\n--- a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n@@ -114,26 +114,17 @@ public class WriteableCommandLineImpl\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if (defaultValues == null || defaultValues.isEmpty()) {\n-            defaultValues = (List) this.defaultValues.get(option);\n+        if ((valueList == null) || valueList.isEmpty()) {\n+            valueList = defaultValues;\n         }\n \n         // augment the list with the default values\n-        if (defaultValues != null && !defaultValues.isEmpty()) {\n-            if (valueList == null || valueList.isEmpty()) {\n-                valueList = defaultValues;\n-            } else {\n+        if ((valueList == null) || valueList.isEmpty()) {\n+            valueList = (List) this.defaultValues.get(option);\n+        }\n                 // if there are more default values as specified, add them to\n                 // the list.\n-                if (defaultValues.size() > valueList.size()) {\n                     // copy the list first\n-                    valueList = new ArrayList(valueList);\n-                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n-                        valueList.add(defaultValues.get(i));\n-                    }\n-                }\n-            }\n-        }\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n     }\n"}
{"identifier": "Lang-64", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/enums/ValuedEnum.java b/src/java/org/apache/commons/lang/enums/ValuedEnum.java\nindex 419a0ea..6aca541 100644\n--- a/src/java/org/apache/commons/lang/enums/ValuedEnum.java\n+++ b/src/java/org/apache/commons/lang/enums/ValuedEnum.java\n@@ -180,16 +180,6 @@ public abstract class ValuedEnum extends Enum {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n-        if (other == this) {\n-            return 0;\n-        }\n-        if (other.getClass() != this.getClass()) {\n-            if (other.getClass().getName().equals(this.getClass().getName())) {\n-                return iValue - getValueInOtherClassLoader(other);\n-            }\n-            throw new ClassCastException(\n-                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n-        }\n         return iValue - ((ValuedEnum) other).iValue;\n     }\n \n@@ -199,20 +189,9 @@ public abstract class ValuedEnum extends Enum {\n      * @param other  the object to determine the value for\n      * @return the value\n      */\n-    private int getValueInOtherClassLoader(Object other) {\n-        try {\n-            Method mth = other.getClass().getMethod(\"getValue\", null);\n-            Integer value = (Integer) mth.invoke(other, null);\n-            return value.intValue();\n-        } catch (NoSuchMethodException e) {\n             // ignore - should never happen\n-        } catch (IllegalAccessException e) {\n             // ignore - should never happen\n-        } catch (InvocationTargetException e) {\n             // ignore - should never happen\n-        }\n-        throw new IllegalStateException(\"This should not happen\");\n-    }\n \n     /**\n      * <p>Human readable description of this <code>Enum</code> item.</p>\n"}
{"identifier": "Mockito-13", "buggy_code": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n                // this means there is an invocation on a different mock. Re-adding verification mode \n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n", "fixed_code": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                // this means there is an invocation on a different mock. Re-adding verification mode \n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic Object handle(Invocation invocation) throws Throwable\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/MockHandler.java b/src/org/mockito/internal/MockHandler.java\nindex 8962ceb..6f2e4bc 100644\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n@@ -74,14 +74,12 @@ public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInte\n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n-            } else {\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-                mockingProgress.verificationStarted(verificationMode);\n             }\n         }\n         \n"}
{"identifier": "Math-81", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..2d0d72f 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -600,7 +600,6 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n         lowerSpectra = Math.min(lowerSpectra, lower);\n         final double upper = dCurrent + eCurrent;\n         work[upperStart + m - 1] = upper;\n-        upperSpectra = Math.max(upperSpectra, upper);\n         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n \n     }\n@@ -903,8 +902,8 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n-                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n+                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             // insert a split\n                             work[i + 2]  = -sigma;\n@@ -1541,7 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 3) {\n+                if (end - start > 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n"}
{"identifier": "Lang-12", "buggy_code": "    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@code Integer.MAX_VALUE}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n\n        if (start == 0 && end == 0) {\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                \n                }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if (letters && Character.isLetter(ch)\n                    || numbers && Character.isDigit(ch)\n                    || !letters && !numbers) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n", "fixed_code": "    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@code Integer.MAX_VALUE}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single \n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at\n     * @param end  the position in set of chars to end before\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if there are not\n     *  {@code (end - start) + 1} characters in the set array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The chars array must not be empty\");\n        }\n\n        if (start == 0 && end == 0) {\n            if (chars != null) {\n                end = chars.length;\n            } else {\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                \n                }\n            }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(gap) + start];\n            }\n            if (letters && Character.isLetter(ch)\n                    || numbers && Character.isDigit(ch)\n                    || !letters && !numbers) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\nindex a799057..b200223 100644\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -227,21 +227,14 @@ public class RandomStringUtils {\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n-        if (chars != null && chars.length == 0) {\n-            throw new IllegalArgumentException(\"The chars array must not be empty\");\n-        }\n \n         if (start == 0 && end == 0) {\n-            if (chars != null) {\n-                end = chars.length;\n-            } else {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n-            }\n         }\n \n         char[] buffer = new char[count];\n"}
{"identifier": "Closure-172", "buggy_code": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          return false;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }\n", "fixed_code": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        String className = qName.substring(0, qName.lastIndexOf(\".prototype\"));\n        Var slot = scope.getSlot(className);\n        JSType classType = slot == null ? null : slot.getType();\n        if (classType != null\n            && (classType.isConstructor() || classType.isInterface())) {\n          return false;\n        }\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4acb363a..d5a59476 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1667,13 +1667,7 @@ final class TypedScopeCreator implements ScopeCreator {\n \n       // Prototypes of constructors and interfaces are always declared.\n       if (qName != null && qName.endsWith(\".prototype\")) {\n-        String className = qName.substring(0, qName.lastIndexOf(\".prototype\"));\n-        Var slot = scope.getSlot(className);\n-        JSType classType = slot == null ? null : slot.getType();\n-        if (classType != null\n-            && (classType.isConstructor() || classType.isInterface())) {\n           return false;\n-        }\n       }\n \n       boolean inferred = true;\n"}
{"identifier": "Mockito-25", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\nindex 918c42a..6fa773f 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n@@ -4,7 +4,6 @@\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import org.mockito.MockSettings;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n@@ -17,8 +16,6 @@ import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n \n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n@@ -53,10 +50,10 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n             return delegate.returnValueFor(rawType);\n         }\n \n-        return getMock(invocation, returnTypeGenericMetadata);\n+        return getMock(invocation);\n     }\n \n-    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n+    private Object getMock(InvocationOnMock invocation) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n@@ -68,7 +65,7 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n \t\t}\n \n         // deep stub\n-        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n+        return recordDeepStubMock(invocation, container);\n     }\n \n     /**\n@@ -77,33 +74,13 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n      * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n      * @return The mock\n      */\n-    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n-        return mock(\n-                returnTypeGenericMetadata.rawType(),\n-                withSettingsUsing(returnTypeGenericMetadata)\n-        );\n-    }\n \n-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n-        MockSettings mockSettings =\n-                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n-                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n-                : withSettings();\n \n-        return mockSettings\n-                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n-    }\n \n-    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n-        return new ReturnsDeepStubs() {\n-            @Override\n-            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n-                return returnTypeGenericMetadata;\n-            }\n-        };\n-    }\n \n-    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n+    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n+        Class<?> clz = invocation.getMethod().getReturnType();\n+        final Object mock = org.mockito.Mockito.mock(clz, this);\n \n         container.addAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n"}
{"identifier": "JacksonDatabind-78", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex afe24aa1f..4a9d8631e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -45,28 +45,14 @@ public class BeanDeserializerFactory\n      *\n      * @since 2.8.9\n      */\n-    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n-    static {\n-        Set<String> s = new HashSet<>();\n         // Courtesy of [https://github.com/kantega/notsoserial]:\n         // (and wrt [databind#1599]\n-        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n-        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n-        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n-        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n-        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n-        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n-        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n-        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n-        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n-    }\n \n     /**\n      * Set of class names of types that are never to be deserialized.\n      *\n      * @since 2.8.9\n      */\n-    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n \n     /*\n     /**********************************************************\n@@ -167,7 +153,6 @@ public class BeanDeserializerFactory\n             return null;\n         }\n         // For checks like [databind#1599]\n-        checkIllegalTypes(ctxt, type, beanDesc);\n         // Use generic bean introspection to build deserializer\n         return buildBeanDeserializer(ctxt, type, beanDesc);\n     }\n@@ -890,17 +875,7 @@ beanDesc.getBeanClass().getName(), name, ((AnnotatedParameter) m).getIndex());\n     /**\n      * @since 2.8.9\n      */\n-    protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type,\n-            BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n         // There are certain nasty classes that could cause problems, mostly\n         // via default typing -- catch them here.\n-        String full = type.getRawClass().getName();\n \n-        if (_cfgIllegalClassNames.contains(full)) {\n-            ctxt.reportBadTypeDefinition(beanDesc,\n-                    \"Illegal type (%s) to deserialize: prevented for security reasons\", full);\n-        }\n-    }\n }\n"}
{"identifier": "Closure-144", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\nindex 01fa8bad..8ac4f113 100644\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n@@ -71,7 +71,6 @@ final class FunctionTypeBuilder {\n   private final Scope scope;\n \n   private JSType returnType = null;\n-  private boolean returnTypeInferred = false;\n   private List<ObjectType> implementedInterfaces = null;\n   private ObjectType baseType = null;\n   private ObjectType thisType = null;\n@@ -198,9 +197,9 @@ final class FunctionTypeBuilder {\n    */\n   FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n     returnType = info != null && info.hasReturnType() ?\n-        info.getReturnType().evaluate(scope, typeRegistry) : null;\n+        info.getReturnType().evaluate(scope, typeRegistry) :\n+        typeRegistry.getNativeType(UNKNOWN_TYPE);\n     if (templateTypeName != null &&\n-        returnType != null &&\n         returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n@@ -211,37 +210,7 @@ final class FunctionTypeBuilder {\n    * If we haven't found a return value yet, try to look at the \"return\"\n    * statements in the function.\n    */\n-  FunctionTypeBuilder inferReturnStatements(@Nullable Node functionBlock) {\n-    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {\n-      return this;\n-    }\n-    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);\n-    if (returnType == null) {\n-      boolean hasNonEmptyReturns = false;\n-      List<Node> worklist = Lists.newArrayList(functionBlock);\n-      while (!worklist.isEmpty()) {\n-        Node current = worklist.remove(worklist.size() - 1);\n-        int cType = current.getType();\n-        if (cType == Token.RETURN && current.getFirstChild() != null ||\n-            cType == Token.THROW) {\n-          hasNonEmptyReturns = true;\n-          break;\n-        } else if (NodeUtil.isStatementBlock(current) ||\n-            NodeUtil.isControlStructure(current)) {\n-          for (Node child = current.getFirstChild();\n-               child != null; child = child.getNext()) {\n-            worklist.add(child);\n-          }\n-        }\n-      }\n \n-      if (!hasNonEmptyReturns) {\n-        returnType = typeRegistry.getNativeType(VOID_TYPE);\n-        returnTypeInferred = true;\n-      }\n-    }\n-    return this;\n-  }\n \n   /**\n    * Infer the role of the function (whether it's a constructor or interface)\n@@ -524,7 +493,7 @@ final class FunctionTypeBuilder {\n           .withName(fnName)\n           .withSourceNode(sourceNode)\n           .withParamsNode(parametersNode)\n-          .withReturnType(returnType, returnTypeInferred)\n+          .withReturnType(returnType)\n           .withTypeOfThis(thisType)\n           .withTemplateName(templateTypeName)\n           .build();\ndiff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4be3b8d3..8bf22fc0 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -574,7 +574,6 @@ final class TypedScopeCreator implements ScopeCreator {\n       Node fnRoot = isFnLiteral ? rValue : null;\n       Node parametersNode = isFnLiteral ?\n           rValue.getFirstChild().getNext() : null;\n-      Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n \n       if (functionType == null && info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n@@ -615,7 +614,6 @@ final class TypedScopeCreator implements ScopeCreator {\n                     .setSourceNode(fnRoot)\n                     .inferFromOverriddenFunction(propType, parametersNode)\n                     .inferThisType(info, owner)\n-                    .inferReturnStatements(fnBlock)\n                     .buildAndRegister();\n               }\n             }\n@@ -633,7 +631,6 @@ final class TypedScopeCreator implements ScopeCreator {\n             .inferInheritance(info)\n             .inferThisType(info, owner)\n             .inferParameterTypes(parametersNode, info)\n-            .inferReturnStatements(fnBlock)\n             .buildAndRegister();\n       }\n \ndiff --git a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\nindex 902f2e6d..4a6596e3 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n@@ -98,11 +98,6 @@ public final class FunctionBuilder {\n   }\n \n   /** Set the return type and whether it's inferred. */\n-  public FunctionBuilder withReturnType(JSType returnType, boolean inferred) {\n-    this.returnType = returnType;\n-    this.inferredReturnType = inferred;\n-    return this;\n-  }\n \n   /** Sets an inferred return type. */\n   public FunctionBuilder withInferredReturnType(JSType returnType) {\ndiff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex 6a4d2f46..0cae0e3a 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -514,7 +514,7 @@ public class FunctionType extends PrototypeObjectType {\n \n   FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n     return new FunctionType(\n-        registry, null, source,\n+        registry, null, null,\n         new ArrowType(\n             registry, call.parameters, newReturnType, inferred),\n         typeOfThis, null, false, false);\n"}
{"identifier": "JacksonDatabind-11", "buggy_code": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            return _unknownType();\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n", "fixed_code": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            context = new TypeBindings(this, (Class<?>) null);\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name, false);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\nindex e0eb63960..a8bd24061 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n@@ -892,14 +892,14 @@ public final class TypeFactory\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            context = new TypeBindings(this, (Class<?>) null);\n+            return _unknownType();\n         } else {\n             // Ok: here's where context might come in handy!\n             /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n              *   unresolved type variables to handle some cases where bounds\n              *   are enough. Let's hope it does not hide real fail cases.\n              */\n-            JavaType actualType = context.findType(name, false);\n+            JavaType actualType = context.findType(name);\n             if (actualType != null) {\n                 return actualType;\n             }\n"}
{"identifier": "Chart-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java b/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java\nindex bde3922..2efdfcb 100644\n--- a/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java\n+++ b/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java\n@@ -204,8 +204,8 @@ public class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n \n             }\n             else {\n-                this.seriesKeys = new Comparable[0];\n-                this.categoryKeys = new Comparable[0];\n+                this.seriesKeys = null;\n+                this.categoryKeys = null;\n             }\n         }\n \n@@ -335,7 +335,7 @@ public class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n         if (categoryKeys == null) {\n             throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n         }\n-        if (categoryKeys.length != getCategoryCount()) {\n+        if (categoryKeys.length != this.startData[0].length) {\n             throw new IllegalArgumentException(\n                     \"The number of categories does not match the data.\");\n         }\n"}
{"identifier": "Jsoup-47", "buggy_code": "    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n", "fixed_code": "    // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        final EscapeMode escapeMode = out.escapeMode();\n        final CharsetEncoder encoder = out.encoder();\n        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n        final Map<Character, String> map = escapeMode.getMap();\n        final int length = string.length();\n\n        int codePoint;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                    accum.append(c);\n                else\n                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex aa1f946..08cf311 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -119,7 +119,7 @@ public class Entities {\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n+                        if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n"}
{"identifier": "Time-11", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\nindex 64da5ea..6efe071 100644\n--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n@@ -65,11 +65,10 @@ public class ZoneInfoCompiler {\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n+    static {\n+        cVerbose.set(Boolean.FALSE);\n+    }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n"}
{"identifier": "Lang-27", "buggy_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex f1f36a8..fd03ab8 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -476,7 +476,7 @@ public class NumberUtils {\n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos || expPos > str.length()) {\n+                if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n@@ -486,9 +486,6 @@ public class NumberUtils {\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                if (expPos > str.length()) {\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n-                }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n"}
{"identifier": "Jsoup-78", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex 3037d61..82c17c9 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -1,6 +1,5 @@\n package org.jsoup.helper;\n \n-import org.jsoup.UncheckedIOException;\n import org.jsoup.internal.ConstrainableInputStream;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n@@ -149,12 +148,8 @@ public final class DataUtil {\n             if (charsetName == null)\n                 charsetName = defaultCharset;\n             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-            try {\n                 doc = parser.parseInput(reader, baseUri);\n-            } catch (UncheckedIOException e) {\n                 // io exception when parsing (not seen before because reading the stream as we go)\n-                throw e.ioException();\n-            }\n             doc.outputSettings().charset(charsetName);\n         }\n         input.close();\n"}
{"identifier": "Math-96", "buggy_code": "    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));\n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n", "fixed_code": "    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java\nindex 8b622cb..3571567 100644\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -255,7 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n+                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n"}
{"identifier": "Closure-87", "buggy_code": "  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n\n          return NodeUtil.isExpressionNode(maybeExpr);\n      }\n    }\n\n    return false;\n  }\n", "fixed_code": "  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            if (calledFn.getType() == Token.GETELEM) {\n              return false;\n            } else if (calledFn.getType() == Token.GETPROP &&\n                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n        return false;\n      }\n    }\n\n    return false;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 6c4ee4a..9498fa6 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -520,29 +520,17 @@ public class PeepholeSubstituteAlternateSyntax\n     if (n.getType() == Token.BLOCK) {\n       if (n.hasOneChild()) {\n         Node maybeExpr = n.getFirstChild();\n-        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n           // IE has a bug where event handlers behave differently when\n           // their return value is used vs. when their return value is in\n           // an EXPR_RESULT. It's pretty freaking weird. See:\n           // http://code.google.com/p/closure-compiler/issues/detail?id=291\n           // We try to detect this case, and not fold EXPR_RESULTs\n           // into other expressions.\n-          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n-            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            if (calledFn.getType() == Token.GETELEM) {\n-              return false;\n-            } else if (calledFn.getType() == Token.GETPROP &&\n-                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n-              return false;\n-            }\n-          }\n \n-          return true;\n-        }\n-        return false;\n+          return NodeUtil.isExpressionNode(maybeExpr);\n       }\n     }\n \n"}
{"identifier": "Compress-21", "buggy_code": "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            --shift;\n            if (shift == 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (length > 0 && shift > 0) {\n            header.write(cache);\n        }\n    }\n", "fixed_code": "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            if (--shift < 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (shift != 7) {\n            header.write(cache);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\nindex 317d7781..05912b9f 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n@@ -636,13 +636,14 @@ public class SevenZOutputFile {\n         int shift = 7;\n         for (int i = 0; i < length; i++) {\n             cache |= ((bits.get(i) ? 1 : 0) << shift);\n-            if (--shift < 0) {\n+            --shift;\n+            if (shift == 0) {\n                 header.write(cache);\n                 shift = 7;\n                 cache = 0;\n             }\n         }\n-        if (shift != 7) {\n+        if (length > 0 && shift > 0) {\n             header.write(cache);\n         }\n     }\n"}
{"identifier": "Cli-10", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex 16d0795..cf53a90 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.commons.cli;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Enumeration;\n import java.util.Iterator;\n@@ -44,7 +43,7 @@ public abstract class Parser implements CommandLineParser {\n \n     protected void setOptions(final Options options) {\n         this.options = options;\n-        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n+        this.requiredOptions = options.getRequiredOptions();\n     }\n \n     protected Options getOptions() {\n"}
{"identifier": "JacksonDatabind-79", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\nindex f2bc1cad7..d74a2e99f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n@@ -576,13 +576,10 @@ public class JacksonAnnotationIntrospector\n     @Override\n     public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n         JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-        if (ref == null) {\n-            return objectIdInfo;\n+        if (ref != null) {\n+            objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n         }\n-        if (objectIdInfo == null) {\n-            objectIdInfo = ObjectIdInfo.empty();\n-        }\n-        return objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+        return objectIdInfo;\n     }\n \n     /*\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java b/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\nindex 049ab3530..93c3dd51c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n@@ -22,7 +22,6 @@ public class ObjectIdInfo\n     /**\n      * @since 2.8.9\n      */\n-    private final static ObjectIdInfo EMPTY = new ObjectIdInfo(PropertyName.NO_NAME, Object.class, null, false, null);\n \n     public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n             Class<? extends ObjectIdResolver> resolver)\n@@ -61,9 +60,6 @@ public class ObjectIdInfo\n         _resolver = resolver;\n     }\n \n-    public static ObjectIdInfo empty() {\n-        return EMPTY;\n-    }\n \n     public ObjectIdInfo withAlwaysAsId(boolean state) {\n         if (_alwaysAsId == state) {\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\nindex 3b838cc8b..1f1d2e3e2 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n@@ -429,10 +429,9 @@ public abstract class BeanSerializerBase\n             if (objectIdInfo == null) {\n                 // no ObjectId override, but maybe ObjectIdRef?\n                 if (oiw != null) {\n-                    objectIdInfo = intr.findObjectReferenceInfo(accessor, null);\n-                    if (objectIdInfo != null) {\n+                    objectIdInfo = intr.findObjectReferenceInfo(accessor,\n+                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                         oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n-                    }\n                 }\n             } else {\n                 // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n"}
{"identifier": "Closure-97", "buggy_code": "  /**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      // check ranges.  We do not do anything that would clip the double to\n      // a 32-bit range, since the user likely does not intend that.\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return n;\n      }\n\n      // only the lower 5 bits are used when shifting, so don't do anything\n      // if the shift amount is outside [0,32)\n      if (!(rval >= 0 && rval < 32)) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      }\n\n      // Convert the numbers to ints\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        error(FRACTIONAL_BITWISE_OPERAND, left);\n        return n;\n      }\n\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        error(FRACTIONAL_BITWISE_OPERAND, right);\n        return n;\n      }\n\n      switch (n.getType()) {\n        case Token.LSH:\n          result = lvalInt << rvalInt;\n          break;\n        case Token.RSH:\n          result = lvalInt >> rvalInt;\n          break;\n        case Token.URSH:\n          // JavaScript handles zero shifts on signed numbers differently than\n          // Java as an Java int can not represent the unsigned 32-bit number\n          // where JavaScript can so use a long here.\n          result = lvalInt >>> rvalInt;\n          break;\n        default:\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n      }\n\n      Node newNumber = Node.newNumber(result);\n      n.getParent().replaceChild(n, newNumber);\n      reportCodeChange();\n\n      return newNumber;\n    }\n\n    return n;\n  }\n", "fixed_code": "  /**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      // check ranges.  We do not do anything that would clip the double to\n      // a 32-bit range, since the user likely does not intend that.\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return n;\n      }\n\n      // only the lower 5 bits are used when shifting, so don't do anything\n      // if the shift amount is outside [0,32)\n      if (!(rval >= 0 && rval < 32)) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      }\n\n      // Convert the numbers to ints\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        error(FRACTIONAL_BITWISE_OPERAND, left);\n        return n;\n      }\n\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        error(FRACTIONAL_BITWISE_OPERAND, right);\n        return n;\n      }\n\n      switch (n.getType()) {\n        case Token.LSH:\n          result = lvalInt << rvalInt;\n          break;\n        case Token.RSH:\n          result = lvalInt >> rvalInt;\n          break;\n        case Token.URSH:\n          // JavaScript handles zero shifts on signed numbers differently than\n          // Java as an Java int can not represent the unsigned 32-bit number\n          // where JavaScript can so use a long here.\n          long lvalLong = lvalInt & 0xffffffffL;\n          result = lvalLong >>> rvalInt;\n          break;\n        default:\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n      }\n\n      Node newNumber = Node.newNumber(result);\n      n.getParent().replaceChild(n, newNumber);\n      reportCodeChange();\n\n      return newNumber;\n    }\n\n    return n;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex c998d1e..d6c194a 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -695,8 +695,7 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          long lvalLong = lvalInt & 0xffffffffL;\n-          result = lvalLong >>> rvalInt;\n+          result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n"}
{"identifier": "Closure-10", "buggy_code": "  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }\n", "fixed_code": "  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nstatic boolean mayBeString(Node n, boolean recurse)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex eeb12d4..eef2792 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n"}
{"identifier": "Closure-45", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex c93a073..be72a58 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -729,7 +729,6 @@ class RemoveUnusedVars\n             assignedToUnknownValue = true;\n           }\n \n-          boolean maybeEscaped = false;\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;\n@@ -737,12 +736,9 @@ class RemoveUnusedVars\n                 assign.assignNode.getLastChild(), true)) {\n               assignedToUnknownValue = true;\n             }\n-            if (assign.maybeAliased) {\n-              maybeEscaped = true;\n-            }\n           }\n \n-          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n+          if (assignedToUnknownValue && hasPropertyAssign) {\n             changes = markReferencedVar(var) || changes;\n             maybeUnreferenced.remove(current);\n             current--;\n@@ -905,7 +901,7 @@ class RemoveUnusedVars\n       this.nameNode = nameNode;\n       this.isPropertyAssign = isPropertyAssign;\n \n-      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n+      this.maybeAliased = !assignNode.getParent().isExprResult();\n       this.mayHaveSecondarySideEffects =\n           maybeAliased ||\n           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n"}
{"identifier": "Closure-145", "buggy_code": "  /**\n   * @return Whether the Node is a DO or FUNCTION (with or without\n   * labels).\n   */\n  private boolean isOneExactlyFunctionOrDo(Node n) {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n        // are skipped. \n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n  }\n", "fixed_code": "  /**\n   * @return Whether the Node is a DO or FUNCTION (with or without\n   * labels).\n   */\n  private boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n      Node labeledStatement = n.getLastChild();\n      if (labeledStatement.getType() != Token.BLOCK) {\n        return isOneExactlyFunctionOrDo(labeledStatement);\n      } else {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n        // are skipped. \n        if (getNonEmptyChildCount(n, 2) == 1) { \n          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n        } else {\n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n          return false;\n        }\n      }\n    } else {\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * @return Whether the Node is a DO or FUNCTION (with or without\n   * labels).\n   */\n  private boolean isOneExactlyFunctionOrDo(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex cce82f48..42c9ab38 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -706,25 +706,12 @@ class CodeGenerator {\n    * labels).\n    */\n   private boolean isOneExactlyFunctionOrDo(Node n) {\n-    if (n.getType() == Token.LABEL) {\n-      Node labeledStatement = n.getLastChild();\n-      if (labeledStatement.getType() != Token.BLOCK) {\n-        return isOneExactlyFunctionOrDo(labeledStatement);\n-      } else {\n         // For labels with block children, we need to ensure that a\n         // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n         // are skipped. \n-        if (getNonEmptyChildCount(n, 2) == 1) { \n-          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n-        } else {\n           // Either a empty statement or an block with more than one child,\n           // way it isn't a FUNCTION or DO.\n-          return false;\n-        }\n-      }\n-    } else {\n       return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n-    }\n   }\n \n   /**\n"}
{"identifier": "Compress-20", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\nindex 664d0e6d..934eb0aa 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n@@ -328,7 +328,7 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n \n         ret.setInode(readAsciiLong(8, 16));\n         long mode = readAsciiLong(8, 16);\n-        if (CpioUtil.fileType(mode) != 0){ // mode is initialised to 0\n+        if (mode != 0){\n             ret.setMode(mode);\n         }\n         ret.setUID(readAsciiLong(8, 16));\n@@ -344,7 +344,7 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n         ret.setChksum(readAsciiLong(8, 16));\n         String name = readCString((int) namesize);\n         ret.setName(name);\n-        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n+        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n         }\n         skip(ret.getHeaderPadCount());\n@@ -358,7 +358,7 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n         ret.setDevice(readAsciiLong(6, 8));\n         ret.setInode(readAsciiLong(6, 8));\n         final long mode = readAsciiLong(6, 8);\n-        if (CpioUtil.fileType(mode) != 0) {\n+        if (mode != 0) {\n             ret.setMode(mode);\n         }\n         ret.setUID(readAsciiLong(6, 8));\n@@ -370,7 +370,7 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n         ret.setSize(readAsciiLong(11, 8));\n         final String name = readCString((int) namesize);\n         ret.setName(name);\n-        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n+        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n         }\n \n@@ -384,7 +384,7 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n         ret.setDevice(readBinaryLong(2, swapHalfWord));\n         ret.setInode(readBinaryLong(2, swapHalfWord));\n         final long mode = readBinaryLong(2, swapHalfWord);\n-        if (CpioUtil.fileType(mode) != 0){\n+        if (mode != 0){\n             ret.setMode(mode);\n         }\n         ret.setUID(readBinaryLong(2, swapHalfWord));\n@@ -396,7 +396,7 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n         ret.setSize(readBinaryLong(4, swapHalfWord));\n         final String name = readCString((int) namesize);\n         ret.setName(name);\n-        if (CpioUtil.fileType(mode) == 0 && !name.equals(CPIO_TRAILER)){\n+        if (mode == 0 && !name.equals(CPIO_TRAILER)){\n             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n         }\n         skip(ret.getHeaderPadCount());\n"}
{"identifier": "JacksonDatabind-94", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\nindex 777637a75..9865b1a20 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\n@@ -20,7 +20,6 @@ public class SubTypeValidator\n {\n     protected final static String PREFIX_SPRING = \"org.springframework.\";\n \n-    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n \n     /**\n      * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n@@ -96,16 +95,12 @@ public class SubTypeValidator\n                             || \"AbstractApplicationContext\".equals(name)) {\n                         break main_check;\n                     }\n-                }\n-            } else if (full.startsWith(PREFIX_C3P0)) {\n                 // [databind#1737]; more 3rd party\n                 // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                 // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                 // [databind#1931]; more 3rd party\n                 // com.mchange.v2.c3p0.ComboPooledDataSource\n                 // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n-                if (full.endsWith(\"DataSource\")) {\n-                    break main_check;\n                 }\n             }\n             return;\n"}
{"identifier": "Jsoup-82", "buggy_code": "    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n        }\n        input.close();\n        return doc;\n    }\n", "fixed_code": "    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(Charset.forName(defaultCharset));\n            }\n        }\n        input.close();\n        return doc;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex f4012fc..dc12cb3 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -168,10 +168,7 @@ public final class DataUtil {\n             }\n             Charset charset = Charset.forName(charsetName);\n             doc.outputSettings().charset(charset);\n-            if (!charset.canEncode()) {\n                 // some charsets can read but not encode; switch to an encodable charset and update the meta el\n-                doc.charset(Charset.forName(defaultCharset));\n-            }\n         }\n         input.close();\n         return doc;\n"}
{"identifier": "Math-88", "buggy_code": "    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[i] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n", "fixed_code": "    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        Set<Integer> basicRows = new HashSet<Integer>();\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            if (basicRows.contains(basicRow)) {\n                // if multiple variables can take a given value \n                // then we choose the first and set the rest equal to 0\n                coefficients[i] = 0;\n            } else {\n                basicRows.add(basicRow);\n                coefficients[i] =\n                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                    (restrictToNonNegative ? 0 : mostNegative);\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Get the current solution.\n     * <p>\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex a6d7419..3bcb17f 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -326,18 +326,19 @@ class SimplexTableau implements Serializable {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n-        Set<Integer> basicRows = new HashSet<Integer>();\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n-            if (basicRows.contains(basicRow)) {\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n-                coefficients[i] = 0;\n-            } else {\n-                basicRows.add(basicRow);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n+            if (basicRow != null) {\n+                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n+                    if (tableau.getEntry(basicRow, j) == 1) {\n+                         coefficients[i] = 0;\n+                    }\n+                }\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n"}
{"identifier": "Math-71", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex e03be9e..0840ac1 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -297,10 +297,6 @@ public abstract class EmbeddedRungeKuttaIntegrator\n                   // it is so small (much probably exactly 0 due to limited accuracy)\n                   // that the code above would fail handling it.\n                   // So we set up an artificial 0 size step by copying states\n-                  interpolator.storeTime(stepStart);\n-                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                  hNew     = 0;\n-                  stepSize = 0;\n                   loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex b61b0b1..255b1f4 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -177,9 +177,6 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n                 // So we set up an artificial 0 size step by copying states\n-                interpolator.storeTime(stepStart);\n-                System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                stepSize = 0;\n                 loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n"}
{"identifier": "Cli-20", "buggy_code": "    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n", "fixed_code": "    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt) && stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(opt);\n                    if (pos != -1) {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>An implementation of\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex a93b73f..7998f07 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -111,19 +111,14 @@ public class PosixParser extends Parser {\n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                int pos = token.indexOf('=');\n-                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n-\n-                if (!options.hasOption(opt) && stopAtNonOption)\n+                if (token.indexOf('=') != -1)\n                 {\n-                    process(token);\n+                    tokens.add(token.substring(0, token.indexOf('=')));\n+                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                 }\n                 else\n                 {\n-                    tokens.add(opt);\n-                    if (pos != -1) {\n-                        tokens.add(token.substring(pos + 1));\n-                    }\n+                    tokens.add(token);\n                 }\n             }\n \n"}
{"identifier": "JacksonDatabind-101", "buggy_code": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n        \n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                        p.nextToken();\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                    //    problems if we maintain invariants\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        ctxt.reportInputMismatch(creatorProp,\n                                \"Cannot create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName,\n                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n", "fixed_code": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n        \n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                    //    problems if we maintain invariants\n                    if (t != JsonToken.END_OBJECT) {\n                        ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \n                                \"Attempted to unwrap '%s' value\",\n                                handledType().getName());\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        ctxt.reportInputMismatch(creatorProp,\n                                \"Cannot create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName,\n                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\nindex 88051e75d..e1f54c234 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n@@ -768,16 +768,12 @@ public class BeanDeserializer\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n+                        p.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n-                    if (t != JsonToken.END_OBJECT) {\n-                        ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \n-                                \"Attempted to unwrap '%s' value\",\n-                                handledType().getName());\n-                    }\n                     tokens.writeEndObject();\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         // !!! 08-Jul-2011, tatu: Could probably support; but for now\n"}
{"identifier": "Cli-5", "buggy_code": "    /**\n     * <p>Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.</p>\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n    {\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n", "fixed_code": "    /**\n     * <p>Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.</p>\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n    {\n        if (str == null) {\n            return null;\n        }\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.</p>\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/Util.java b/src/java/org/apache/commons/cli/Util.java\nindex 94e97e3..2d88c30 100644\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n@@ -33,9 +33,6 @@ class Util {\n      */\n     static String stripLeadingHyphens(String str)\n     {\n-        if (str == null) {\n-            return null;\n-        }\n         if (str.startsWith(\"--\"))\n         {\n             return str.substring(2, str.length());\n"}
{"identifier": "Mockito-5", "buggy_code": "    /**\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }\n", "fixed_code": "    /**\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g. {@link AtMost}).\n     *\n     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n     *\n     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n     */\n    public void verify(VerificationData data) {\n        AssertionError error = null;\n\n        timer.start();\n        while (timer.isCounting()) {\n            try {\n                delegate.verify(data);\n\n                if (returnOnSuccess) {\n                    return;\n                } else {\n                    error = null;\n                }\n            } catch (MockitoAssertionError e) {\n                error = handleVerifyException(e);\n            }\n            catch (AssertionError e) {\n                error = handleVerifyException(e);\n            }\n        }\n\n        if (error != null) {\n            throw error;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n     * before the full duration has passed.\n     *\n     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n     * to never recover from this situation (e.g.\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\nindex 4ea2463..c5a66c5 100644\n--- a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n@@ -88,7 +88,7 @@ public class VerificationOverTimeImpl implements VerificationMode {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (AssertionError e) {\n+            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n"}
{"identifier": "JacksonDatabind-17", "buggy_code": "        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n", "fixed_code": "        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\nindex 643984b73..321994469 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n@@ -177,7 +177,7 @@ public class ObjectMapper\n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n+                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n"}
{"identifier": "Cli-23", "buggy_code": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            int lastPos = pos;\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            } else\n            if (pos == lastPos)\n            {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "fixed_code": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 56f9901..9fa8ebf 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -821,6 +821,7 @@ public class HelpFormatter\n \n         while (true)\n         {\n+            int lastPos = pos;\n             text = padding + text.substring(pos).trim();\n             pos = findWrapPos(text, width, 0);\n \n@@ -829,12 +830,10 @@ public class HelpFormatter\n                 sb.append(text);\n \n                 return sb;\n-            }\n-            \n-            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) {\n-                sb.append(text);\n-\n-                return sb;\n+            } else\n+            if (pos == lastPos)\n+            {\n+                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n"}
{"identifier": "Closure-120", "buggy_code": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n", "fixed_code": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          if (ref.getSymbol().getScope() != ref.scope) {\n            return false;\n          }\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex 0af61d0..cdacc5f 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,9 +428,6 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n-          if (ref.getSymbol().getScope() != ref.scope) {\n-            return false;\n-          }\n           break;\n         } else if (block.isLoop) {\n           return false;\n"}
{"identifier": "Closure-156", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex abe01595..01295cd8 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -452,8 +452,8 @@ class CollapseProperties implements CompilerPass {\n     boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\n \n     // Handle this name first so that nested object literals get unrolled.\n-    if (n.canCollapse()) {\n-      updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);\n+    if (n.canCollapse() && canCollapseChildNames) {\n+      updateObjLitOrFunctionDeclaration(n, alias);\n     }\n \n     if (n.props != null) {\n@@ -571,8 +571,7 @@ class CollapseProperties implements CompilerPass {\n    *     this name. (This is mostly passed for convenience; it's equivalent to\n    *     n.canCollapseChildNames()).\n    */\n-  private void updateObjLitOrFunctionDeclaration(\n-      Name n, String alias, boolean canCollapseChildNames) {\n+  private void updateObjLitOrFunctionDeclaration(Name n, String alias) {\n     if (n.declaration == null) {\n       // Some names do not have declarations, because they\n       // are only defined in local scopes.\n@@ -587,14 +586,13 @@ class CollapseProperties implements CompilerPass {\n \n     switch (n.declaration.node.getParent().getType()) {\n       case Token.ASSIGN:\n-        updateObjLitOrFunctionDeclarationAtAssignNode(\n-            n, alias, canCollapseChildNames);\n+        updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);\n         break;\n       case Token.VAR:\n-        updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames);\n+        updateObjLitOrFunctionDeclarationAtVarNode(n);\n         break;\n       case Token.FUNCTION:\n-        updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);\n+        updateFunctionDeclarationAtFunctionNode(n);\n         break;\n     }\n   }\n@@ -608,7 +606,7 @@ class CollapseProperties implements CompilerPass {\n    * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n    */\n   private void updateObjLitOrFunctionDeclarationAtAssignNode(\n-      Name n, String alias, boolean canCollapseChildNames) {\n+      Name n, String alias) {\n     // NOTE: It's important that we don't add additional nodes\n     // (e.g. a var node before the exprstmt) because the exprstmt might be\n     // the child of an if statement that's not inside a block).\n@@ -652,15 +650,13 @@ class CollapseProperties implements CompilerPass {\n       insertedVarNode = true;\n     }\n \n-    if (canCollapseChildNames) {\n-      if (isObjLit) {\n+    if (isObjLit) {\n         declareVarsForObjLitValues(\n             n, alias, rvalue,\n             varNode, varParent.getChildBefore(varNode), varParent);\n-      }\n \n-      addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n     }\n+      addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n \n     if (insertedVarNode) {\n       if (!varNode.hasChildren()) {\n@@ -700,11 +696,7 @@ class CollapseProperties implements CompilerPass {\n    *\n    * @param n An object representing a global name (e.g. \"a\")\n    */\n-  private void updateObjLitOrFunctionDeclarationAtVarNode(\n-      Name n, boolean canCollapseChildNames) {\n-    if (!canCollapseChildNames) {\n-      return;\n-    }\n+  private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {\n \n     Ref ref = n.declaration;\n     String name = ref.node.getString();\n@@ -747,11 +739,7 @@ class CollapseProperties implements CompilerPass {\n    *\n    * @param n An object representing a global name (e.g. \"a\")\n    */\n-  private void updateFunctionDeclarationAtFunctionNode(\n-      Name n, boolean canCollapseChildNames) {\n-    if (!canCollapseChildNames) {\n-      return;\n-    }\n+  private void updateFunctionDeclarationAtFunctionNode(Name n) {\n \n     Ref ref = n.declaration;\n     String fnName = ref.node.getString();\n"}
{"identifier": "JacksonCore-12", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex c2c413f0..60919c88 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -619,6 +619,7 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n         if (_parsingContext.expectComma()) {\n             i = _skipComma(i);\n         }\n+        _updateLocation();\n \n         /* And should we now have a name? Always true for Object contexts, since\n          * the intermediate 'expect-value' state is never retained.\n@@ -626,13 +627,11 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n         boolean inObject = _parsingContext.inObject();\n         if (inObject) {\n             // First, field name itself:\n-            _updateNameLocation();\n             String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n             _parsingContext.setCurrentName(name);\n             _currToken = JsonToken.FIELD_NAME;\n             i = _skipColon();\n         }\n-        _updateLocation();\n \n         // Ok: we must have a value... what is it?\n \n@@ -771,14 +770,13 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n         if (_parsingContext.expectComma()) {\n             i = _skipComma(i);\n         }\n+        _updateLocation();\n \n         if (!_parsingContext.inObject()) {\n-            _updateLocation();\n             _nextTokenNotInObject(i);\n             return false;\n         }\n \n-        _updateNameLocation();\n         if (i == INT_QUOTE) {\n             // when doing literal match, must consider escaping:\n             char[] nameChars = sstr.asQuotedChars();\n@@ -850,19 +848,17 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n         if (_parsingContext.expectComma()) {\n             i = _skipComma(i);\n         }\n+        _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _updateLocation();\n             _nextTokenNotInObject(i);\n             return null;\n         }\n \n-        _updateNameLocation();\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n \n-        _updateLocation();\n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n@@ -918,7 +914,6 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n     private final void _isNextTokenNameYes(int i) throws IOException\n     {\n         _currToken = JsonToken.FIELD_NAME;\n-        _updateLocation();\n \n         switch (i) {\n         case '\"':\n@@ -969,7 +964,6 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n-        _updateLocation();\n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n@@ -2674,12 +2668,9 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n     public JsonLocation getTokenLocation()\n     {\n         final Object src = _ioContext.getSourceReference();\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return new JsonLocation(src,\n-                    -1L, _nameInputTotal, _nameInputRow, _tokenInputCol);\n-        }\n         return new JsonLocation(src,\n-                -1L, _tokenInputTotal, _tokenInputRow,\n+                -1L, getTokenCharacterOffset(),\n+                getTokenLineNr(),\n                 getTokenColumnNr());\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\nindex b0c007b7..589a34c4 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n@@ -3619,7 +3619,7 @@ public class UTF8StreamJsonParser\n                     _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n         }\n         return new JsonLocation(src,\n-                _tokenInputTotal, -1L, _tokenInputRow,\n+                getTokenCharacterOffset(), -1L, getTokenLineNr(),\n                 getTokenColumnNr());\n     }\n \n"}
{"identifier": "Closure-56", "buggy_code": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }\n", "fixed_code": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n      if (pos >= js.length()) {\n        return null;\n      } else {\n        return js.substring(pos, js.length());\n      }\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/SourceFile.java b/src/com/google/javascript/jscomp/SourceFile.java\nindex 22414f6..fc0cf3f 100644\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n@@ -239,11 +239,7 @@ public class SourceFile implements StaticSourceFile, Serializable {\n       // If next new line cannot be found, there are two cases\n       // 1. pos already reaches the end of file, then null should be returned\n       // 2. otherwise, return the contents between pos and the end of file.\n-      if (pos >= js.length()) {\n         return null;\n-      } else {\n-        return js.substring(pos, js.length());\n-      }\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }\n"}
{"identifier": "Closure-128", "buggy_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0 && s.charAt(0) != '0';\n  }\n", "fixed_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    if (len == 0) {\n      return false;\n    }\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len == 1 || s.charAt(0) != '0';\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nstatic boolean isSimpleNumber(String s)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 1dc33b7..2270c17 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -782,16 +782,13 @@ class CodeGenerator {\n \n   static boolean isSimpleNumber(String s) {\n     int len = s.length();\n-    if (len == 0) {\n-      return false;\n-    }\n     for (int index = 0; index < len; index++) {\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len == 1 || s.charAt(0) != '0';\n+    return len > 0 && s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {\n"}
{"identifier": "Time-16", "buggy_code": "    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant as the default.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n", "fixed_code": "    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant as the default.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex baa276a..a4b1612 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -706,7 +706,7 @@ public class DateTimeFormatter {\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n+            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n"}
{"identifier": "Closure-173", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex d9ac0199..35a93af9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -127,7 +127,12 @@ class CodeGenerator {\n       // the IN_FOR_INIT_CLAUSE one.\n       Context rhsContext = getContextForNoInOperator(context);\n \n-      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n+      if (last.getType() == type &&\n+          NodeUtil.isAssociative(type)) {\n+        addExpr(first, p, context);\n+        cc.addOp(opstr, true);\n+        addExpr(last, p, rhsContext);\n+      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n         // Assignments are the only right-associative binary operators\n         addExpr(first, p, context);\n         cc.addOp(opstr, true);\ndiff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 2015f050..2c137245 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -99,40 +99,12 @@ class PeepholeSubstituteAlternateSyntax\n       case Token.ARRAYLIT:\n         return tryMinimizeArrayLiteral(node);\n \n-      case Token.MUL:\n-      case Token.AND:\n-      case Token.OR:\n-      case Token.BITOR:\n-      case Token.BITXOR:\n-      case Token.BITAND:\n-        return tryRotateAssociativeOperator(node);\n \n       default:\n         return node; //Nothing changed\n     }\n   }\n \n-  private Node tryRotateAssociativeOperator(Node n) {\n-    if (!late) {\n-      return n;\n-    }\n-    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));\n-    Node rhs = n.getLastChild();\n-    if (n.getType() == rhs.getType()) {\n-      Node parent = n.getParent();\n-      Node first = n.getFirstChild().detachFromParent();\n-      Node second = rhs.getFirstChild().detachFromParent();\n-      Node third = rhs.getLastChild().detachFromParent();\n-      Node newLhs = new Node(n.getType(), first, second)\n-          .copyInformationFrom(n);\n-      Node newRoot = new Node(rhs.getType(), newLhs, third)\n-          .copyInformationFrom(rhs);\n-      parent.replaceChild(n, newRoot);\n-      reportCodeChange();\n-      return newRoot;\n-    }\n-    return n;\n-  }\n \n   private Node tryFoldSimpleFunctionCall(Node n) {\n     Preconditions.checkState(n.isCall());\n"}
{"identifier": "JacksonDatabind-39", "buggy_code": "    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n        //    special unfortunately\n            p.skipChildren();\n        return null;\n    }\n", "fixed_code": "    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n        //    special unfortunately\n        if (p.hasToken(JsonToken.FIELD_NAME)) {\n            while (true) {\n                JsonToken t = p.nextToken();\n                if ((t == null) || (t == JsonToken.END_OBJECT)) {\n                    break;\n                }\n                p.skipChildren();\n            }\n        } else {\n            p.skipChildren();\n        }\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java\nindex 04535951d..5bc789fc0 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java\n@@ -32,17 +32,7 @@ public class NullifyingDeserializer\n     {\n         // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n         //    special unfortunately\n-        if (p.hasToken(JsonToken.FIELD_NAME)) {\n-            while (true) {\n-                JsonToken t = p.nextToken();\n-                if ((t == null) || (t == JsonToken.END_OBJECT)) {\n-                    break;\n-                }\n-                p.skipChildren();\n-            }\n-        } else {\n             p.skipChildren();\n-        }\n         return null;\n     }\n \n"}
{"identifier": "Lang-39", "buggy_code": "    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n     *  (example of how it repeats)\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n     * </pre>\n     * \n     * @param text\n     *            text to search and replace in, no-op if null\n     * @param searchList\n     *            the Strings to search for, no-op if null\n     * @param replacementList\n     *            the Strings to replace them with, no-op if null\n     * @param repeat if true, then replace repeatedly \n     *       until there are no more possible replacements or timeToLive < 0\n     * @param timeToLive\n     *            if less than 0 then there is a circular reference and endless\n     *            loop\n     * @return the text with any replacements processed, <code>null</code> if\n     *         null String input\n     * @throws IllegalArgumentException\n     *             if the search is repeating and there is an endless loop due\n     *             to outputs of one being inputs to another\n     * @throws IndexOutOfBoundsException\n     *             if the lengths of the arrays are not the same (null is ok,\n     *             and/or size 0)\n     * @since 2.4\n     */\n    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.length() == 0 || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        int searchLength = searchList.length;\n        int replacementLength = replacementList.length;\n\n        // make sure lengths are ok, these need to be equal\n        if (searchLength != replacementLength) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchLength\n                + \" vs \"\n                + replacementLength);\n        }\n\n        // keep track of which still have matches\n        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n        // index on index that the match was found\n        int textIndex = -1;\n        int replaceIndex = -1;\n        int tempIndex = -1;\n\n        // index of replace array that will replace the search string found\n        // NOTE: logic duplicated below START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i]);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic mostly below END\n\n        // no search strings found, we are done\n        if (textIndex == -1) {\n            return text;\n        }\n\n        int start = 0;\n\n        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n        int increase = 0;\n\n        // count the replacement text elements that are larger than their corresponding text being replaced\n        for (int i = 0; i < searchList.length; i++) {\n            if (searchList[i] == null || replacementList[i] == null) {\n                continue;\n            }\n            int greater = replacementList[i].length() - searchList[i].length();\n            if (greater > 0) {\n                increase += 3 * greater; // assume 3 matches\n            }\n        }\n        // have upper-bound at 20% increase, then let Java take over\n        increase = Math.min(increase, text.length() / 5);\n\n        StringBuilder buf = new StringBuilder(text.length() + increase);\n\n        while (textIndex != -1) {\n\n            for (int i = start; i < textIndex; i++) {\n                buf.append(text.charAt(i));\n            }\n            buf.append(replacementList[replaceIndex]);\n\n            start = textIndex + searchList[replaceIndex].length();\n\n            textIndex = -1;\n            replaceIndex = -1;\n            tempIndex = -1;\n            // find the next earliest match\n            // NOTE: logic mostly duplicated above START\n            for (int i = 0; i < searchLength; i++) {\n                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                    searchList[i].length() == 0 || replacementList[i] == null) \n                {\n                    continue;\n                }\n                tempIndex = text.indexOf(searchList[i], start);\n\n                // see if we need to keep searching for this\n                if (tempIndex == -1) {\n                    noMoreMatchesForReplIndex[i] = true;\n                } else {\n                    if (textIndex == -1 || tempIndex < textIndex) {\n                        textIndex = tempIndex;\n                        replaceIndex = i;\n                    }\n                }\n            }\n            // NOTE: logic duplicated above END\n\n        }\n        int textLength = text.length();\n        for (int i = start; i < textLength; i++) {\n            buf.append(text.charAt(i));\n        }\n        String result = buf.toString();\n        if (!repeat) {\n            return result;\n        }\n\n        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Replaces all occurrences of Strings within another String.\n     * </p>\n     * \n     * <p>\n     * A <code>null</code> reference passed to this method is a no-op, or if\n     * any \"search string\" or \"string to replace\" is null, that replace will be\n     * ignored. \n     * </p>\n     * \n     * <pre>\n     *  StringUtils.replaceEach(null, *, *, *) = null\n     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n     *  StringUtils.replaceEach(\"aba\", new String[]\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex f6cabee..14563aa 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3673,9 +3673,6 @@ public class StringUtils {\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n-            if (searchList[i] == null || replacementList[i] == null) {\n-                continue;\n-            }\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n"}
{"identifier": "Jsoup-32", "buggy_code": "    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames();\n        return clone;\n    }\n", "fixed_code": "    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n        return clone;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public Element clone()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex 95cde5f..9f2ef5c 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1135,7 +1135,7 @@ public class Element extends Node {\n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n+        clone.classNames();\n         return clone;\n     }\n }\n"}
{"identifier": "Closure-111", "buggy_code": "        @Override\n        protected JSType caseTopType(JSType topType) {\n          return topType;\n        }\n", "fixed_code": "        @Override\n        protected JSType caseTopType(JSType topType) {\n          return topType.isAllType() ?\n              getNativeType(ARRAY_TYPE) : topType;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n        protected JSType caseTopType(JSType topType)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\nindex e3c599d..1706e34 100644\n--- a/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\n@@ -51,8 +51,7 @@ public class ClosureReverseAbstractInterpreter\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType.isAllType() ?\n-              getNativeType(ARRAY_TYPE) : topType;\n+          return topType;\n         }\n \n         @Override\n"}
{"identifier": "JacksonCore-22", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\nindex 4459e7fa..4dc7c9ac 100644\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n@@ -414,7 +414,7 @@ public class FilteringParserDelegate extends JsonParserDelegate\n                 }\n                 _itemFilter = f;\n                 if (f == TokenFilter.INCLUDE_ALL) {\n-                    if (_verifyAllowedMatches() && _includePath) {\n+                    if (_includePath) {\n                         return (_currToken = t);\n                     }\n                 }\n@@ -437,9 +437,7 @@ public class FilteringParserDelegate extends JsonParserDelegate\n                 f = _headContext.checkValue(f);\n                 if ((f == TokenFilter.INCLUDE_ALL)\n                         || ((f != null) && f.includeValue(delegate))) {\n-                    if (_verifyAllowedMatches()) {\n                         return (_currToken = t);\n-                    }\n                 }\n             }\n             // Otherwise not included (leaves must be explicitly included)\n@@ -574,7 +572,7 @@ public class FilteringParserDelegate extends JsonParserDelegate\n                     }\n                     _itemFilter = f;\n                     if (f == TokenFilter.INCLUDE_ALL) {\n-                        if (_verifyAllowedMatches() && _includePath) {\n+                        if (_includePath) {\n                             return (_currToken = t);\n                         }\n //                        if (_includeImmediateParent) { ...\n@@ -599,9 +597,7 @@ public class FilteringParserDelegate extends JsonParserDelegate\n                     f = _headContext.checkValue(f);\n                     if ((f == TokenFilter.INCLUDE_ALL)\n                             || ((f != null) && f.includeValue(delegate))) {\n-                        if (_verifyAllowedMatches()) {\n                             return (_currToken = t);\n-                        }\n                     }\n                 }\n                 // Otherwise not included (leaves must be explicitly included)\n@@ -718,7 +714,7 @@ public class FilteringParserDelegate extends JsonParserDelegate\n                         continue main_loop;\n                     }\n                     _itemFilter = f;\n-                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n                         return _nextBuffered(buffRoot);\n                     }\n                 }\n@@ -733,9 +729,7 @@ public class FilteringParserDelegate extends JsonParserDelegate\n                     f = _headContext.checkValue(f);\n                     if ((f == TokenFilter.INCLUDE_ALL)\n                             || ((f != null) && f.includeValue(delegate))) {\n-                        if (_verifyAllowedMatches()) {\n                             return _nextBuffered(buffRoot);\n-                        }\n                     }\n                 }\n                 // Otherwise not included (leaves must be explicitly included)\n@@ -774,13 +768,6 @@ public class FilteringParserDelegate extends JsonParserDelegate\n         }\n     }\n \n-    private final boolean _verifyAllowedMatches() throws IOException {\n-        if (_matchCount == 0 || _allowMultipleMatches) {\n-            ++_matchCount;\n-            return true;\n-        }\n-        return false;\n-    }\n \n     @Override\n     public JsonToken nextValue() throws IOException {\n"}
{"identifier": "Math-103", "buggy_code": "    /**\n     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n     * @param x the value at which the CDF is evaluated.\n     * @return CDF evaluted at <code>x</code>. \n     * @throws MathException if the algorithm fails to converge; unless\n     * x is more than 20 standard deviations from the mean, in which case the\n     * convergence exception is caught and 0 or 1 is returned.\n     */\n    public double cumulativeProbability(double x) throws MathException {\n            return 0.5 * (1.0 + Erf.erf((x - mean) /\n                    (standardDeviation * Math.sqrt(2.0))));\n    }\n", "fixed_code": "    /**\n     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n     * @param x the value at which the CDF is evaluated.\n     * @return CDF evaluted at <code>x</code>. \n     * @throws MathException if the algorithm fails to converge; unless\n     * x is more than 20 standard deviations from the mean, in which case the\n     * convergence exception is caught and 0 or 1 is returned.\n     */\n    public double cumulativeProbability(double x) throws MathException {\n        try {\n            return 0.5 * (1.0 + Erf.erf((x - mean) /\n                    (standardDeviation * Math.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\n            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n                return 0.0d;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1.0d;\n            } else {\n                throw ex;\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n     * @param x the value at which the CDF is evaluated.\n     * @return CDF evaluted at <code>x</code>. \n     * @throws MathException if the algorithm fails to converge; unless\n     * x is more than 20 standard deviations from the mean, in which case the\n     * convergence exception is caught and 0 or 1 is returned.\n     */\n    public double cumulativeProbability(double x) throws MathException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex a08eac5..02810e1 100644\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -106,18 +106,8 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n-        try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0.0d;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1.0d;\n-            } else {\n-                throw ex;\n-            }\n-        }\n     }\n     \n     /**\n"}
{"identifier": "Math-72", "buggy_code": "    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n", "fixed_code": "    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 7fc090e..e0cb427 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -112,7 +112,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(min, 0);\n+            setResult(yMin, 0);\n             return result;\n         }\n \n@@ -124,7 +124,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(max, 0);\n+            setResult(yMax, 0);\n             return result;\n         }\n \n"}
{"identifier": "Codec-5", "buggy_code": "    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            \n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     * \n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 19a69594..2618e5d5 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -583,9 +583,6 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n         if (eof && modulus != 0) {\n-            if (buffer == null || buffer.length - pos < decodeSize) {\n-                resizeBuffer();\n-            }\n             \n             x = x << 6;\n             switch (modulus) {\n"}
{"identifier": "Jsoup-79", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/LeafNode.java b/src/main/java/org/jsoup/nodes/LeafNode.java\nindex ea3605d..0e068b5 100644\n--- a/src/main/java/org/jsoup/nodes/LeafNode.java\n+++ b/src/main/java/org/jsoup/nodes/LeafNode.java\n@@ -2,11 +2,9 @@ package org.jsoup.nodes;\n \n import org.jsoup.helper.Validate;\n \n-import java.util.Collections;\n import java.util.List;\n \n abstract class LeafNode extends Node {\n-    private static final List<Node> EmptyNodes = Collections.emptyList();\n \n     Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)\n \n@@ -93,6 +91,6 @@ abstract class LeafNode extends Node {\n \n     @Override\n     protected List<Node> ensureChildNodes() {\n-        return EmptyNodes;\n+        throw new UnsupportedOperationException(\"Leaf Nodes do not have child nodes.\");\n     }\n }\n"}
{"identifier": "JacksonDatabind-108", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\nindex 71d11c83f..ae5f43175 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n@@ -1166,7 +1166,7 @@ public class ObjectReader\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n-        return (T) _bindAsTreeOrNull(p);\n+        return (T) _bindAsTree(p);\n     }\n \n     @Override\n@@ -1704,36 +1704,6 @@ public class ObjectReader\n      * Same as {@link #_bindAsTree} except end-of-input is reported by returning\n      * {@code null}, not \"missing node\"\n      */\n-    protected final JsonNode _bindAsTreeOrNull(JsonParser p) throws IOException\n-    {\n-        _config.initialize(p);\n-        if (_schema != null) {\n-            p.setSchema(_schema);\n-        }\n-        JsonToken t = p.getCurrentToken();\n-        if (t == null) {\n-            t = p.nextToken();\n-            if (t == null) {\n-                return null;\n-            }\n-        }\n-        final JsonNode resultNode;\n-        if (t == JsonToken.VALUE_NULL) {\n-            resultNode = _config.getNodeFactory().nullNode();\n-        } else {\n-            final DeserializationContext ctxt = createDeserializationContext(p);\n-            final JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n-            if (_unwrapRoot) {\n-                resultNode = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);\n-            } else {\n-                resultNode = (JsonNode) deser.deserialize(p, ctxt);\n-                if (_config.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {\n-                    _verifyNoTrailingTokens(p, ctxt, JSON_NODE_TYPE);\n-                }\n-            }\n-        }\n-        return resultNode;\n-    }\n     \n     /**\n      * @since 2.1\n"}
{"identifier": "JxPath-20", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\nindex 2e68f5a..65ed1ed 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n@@ -85,7 +85,7 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n             return containsMatch((Iterator) left, right);\n         }\n         if (right instanceof Iterator) {\n-            return containsMatch(left, (Iterator) right);\n+            return containsMatch((Iterator) right, left);\n         }\n         double ld = InfoSetUtil.doubleValue(left);\n         if (Double.isNaN(ld)) {\n@@ -135,15 +135,6 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n      * @param value to look for\n      * @return whether a match was found\n      */\n-    private boolean containsMatch(Object value, Iterator it) {\n-        while (it.hasNext()) {\n-            Object element = it.next();\n-            if (compute(value, element)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n \n     /**\n      * Learn whether there is an intersection between two Iterators.\n"}
{"identifier": "JacksonCore-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\nindex fbca28ed..37c6503c 100644\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n@@ -389,9 +389,6 @@ public abstract class ParserMinimalBase extends JsonParser\n         if (_currToken == JsonToken.VALUE_STRING) {\n             return getText();\n         }\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return getCurrentName();\n-        }\n         return getValueAsString(null);\n     }\n     \n@@ -400,9 +397,6 @@ public abstract class ParserMinimalBase extends JsonParser\n         if (_currToken == JsonToken.VALUE_STRING) {\n             return getText();\n         }\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return getCurrentName();\n-        }\n         if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n             return defaultValue;\n         }\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex 4f0f753f..b5b0051c 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -250,9 +250,6 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n             }\n             return _textBuffer.contentsAsString();\n         }\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return getCurrentName();\n-        }\n         return super.getValueAsString(null);\n     }\n     \n@@ -266,9 +263,6 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n             }\n             return _textBuffer.contentsAsString();\n         }\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return getCurrentName();\n-        }\n         return super.getValueAsString(defValue);\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\nindex 2b83d188..2fe36835 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n@@ -302,9 +302,6 @@ public class UTF8StreamJsonParser\n             }\n             return _textBuffer.contentsAsString();\n         }\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return getCurrentName();\n-        }\n         return super.getValueAsString(null);\n     }\n     \n@@ -319,9 +316,6 @@ public class UTF8StreamJsonParser\n             }\n             return _textBuffer.contentsAsString();\n         }\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return getCurrentName();\n-        }\n         return super.getValueAsString(defValue);\n     }\n \n"}
{"identifier": "Closure-159", "buggy_code": "  /**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    // For each referenced function, add a new reference\n    if (node.getType() == Token.CALL) {\n      Node child = node.getFirstChild();\n      if (child.getType() == Token.NAME) {\n        changed.add(child.getString());\n      }\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      findCalledFunctions(c, changed);\n    }\n  }\n", "fixed_code": "  /**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    // For each referenced function, add a new reference\n    if (node.getType() == Token.NAME) {\n      if (isCandidateUsage(node)) {\n        changed.add(node.getString());\n      }\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      findCalledFunctions(c, changed);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineFunctions.java b/src/com/google/javascript/jscomp/InlineFunctions.java\nindex 27caaf23..814a07f4 100644\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n@@ -774,9 +774,10 @@ class InlineFunctions implements SpecializationAwareCompilerPass {\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.NAME) {\n-      if (isCandidateUsage(node)) {\n-        changed.add(node.getString());\n+    if (node.getType() == Token.CALL) {\n+      Node child = node.getFirstChild();\n+      if (child.getType() == Token.NAME) {\n+        changed.add(child.getString());\n       }\n     }\n \n"}
{"identifier": "Jsoup-45", "buggy_code": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n", "fixed_code": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid resetInsertionMode()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 4ac8870..4a58fdf 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -391,7 +391,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n+            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n"}
{"identifier": "Codec-7", "buggy_code": "    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n", "fixed_code": "    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex a5c44ab3..19a69594 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -667,7 +667,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n     }\n     \n     /**\n"}
{"identifier": "Codec-6", "buggy_code": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            return base64.readResults(b, offset, len);\n        }\n    }\n", "fixed_code": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\nindex 479638bc..583a5847 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n@@ -145,7 +145,6 @@ public class Base64InputStream extends FilterInputStream {\n         } else if (len == 0) {\n             return 0;\n         } else {\n-            int readLen = 0;\n             /*\n              Rationale for while-loop on (readLen == 0):\n              -----\n@@ -162,7 +161,6 @@ public class Base64InputStream extends FilterInputStream {\n              -----\n              This is a fix for CODEC-101\n             */\n-            while (readLen == 0) {\n                 if (!base64.hasData()) {\n                     byte[] buf = new byte[doEncode ? 4096 : 8192];\n                     int c = in.read(buf);\n@@ -177,9 +175,7 @@ public class Base64InputStream extends FilterInputStream {\n                         base64.decode(buf, 0, c);\n                     }\n                 }\n-                readLen = base64.readResults(b, offset, len);\n-            }\n-            return readLen;\n+            return base64.readResults(b, offset, len);\n         }\n     }\n \n"}
{"identifier": "Closure-81", "buggy_code": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n", "fixed_code": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    Node processFunctionNode(FunctionNode functionNode)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 07761aa..4a733cd 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,13 +514,6 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n-        int functionType = functionNode.getFunctionType();\n-        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n-          errorReporter.error(\n-            \"unnamed function statement\",\n-            sourceName,\n-            functionNode.getLineno(), \"\", 0);\n-        }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n"}
{"identifier": "Closure-82", "buggy_code": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType();\n  }\n", "fixed_code": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic final boolean isEmptyType()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex 51f2ce2..32a0b25 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -160,9 +160,7 @@ public abstract class JSType implements Serializable {\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n-        (registry.getNativeFunctionType(\n-             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n+    return isNoType() || isNoObjectType() || isNoResolvedType();\n   }\n \n   public boolean isNumberObjectType() {\n"}
{"identifier": "Closure-14", "buggy_code": "  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n", "fixed_code": "  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 980deff..5c6927f 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n+              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n"}
{"identifier": "Math-59", "buggy_code": "    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n    }\n", "fixed_code": "    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 4f7d447..8cba4d4 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n"}
{"identifier": "Closure-117", "buggy_code": "  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n\n    // The best type name is the actual type name.\n\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n", "fixed_code": "  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    // The best type name is the actual type name.\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java\nindex f57ae14..bcd024a 100644\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -722,20 +722,8 @@ class TypeValidator {\n    *     to an Object type, if possible.\n    */\n   String getReadableJSTypeName(Node n, boolean dereference) {\n-    JSType type = getJSType(n);\n-    if (dereference) {\n-      ObjectType dereferenced = type.dereference();\n-      if (dereferenced != null) {\n-        type = dereferenced;\n-      }\n-    }\n \n     // The best type name is the actual type name.\n-    if (type.isFunctionPrototypeType() ||\n-        (type.toObjectType() != null &&\n-         type.toObjectType().getConstructor() != null)) {\n-      return type.toString();\n-    }\n \n     // If we're analyzing a GETPROP, the property may be inherited by the\n     // prototype chain. So climb the prototype chain and find out where\n@@ -765,6 +753,18 @@ class TypeValidator {\n       }\n     }\n \n+    JSType type = getJSType(n);\n+    if (dereference) {\n+      ObjectType dereferenced = type.dereference();\n+      if (dereferenced != null) {\n+        type = dereferenced;\n+      }\n+    }\n+    if (type.isFunctionPrototypeType() ||\n+        (type.toObjectType() != null &&\n+         type.toObjectType().getConstructor() != null)) {\n+      return type.toString();\n+    }\n     String qualifiedName = n.getQualifiedName();\n     if (qualifiedName != null) {\n       return qualifiedName;\n"}
{"identifier": "JacksonCore-23", "buggy_code": "    @Override\n    public DefaultPrettyPrinter createInstance() {\n        return new DefaultPrettyPrinter(this);\n    }\n", "fixed_code": "    @Override\n    public DefaultPrettyPrinter createInstance() {\n        if (getClass() != DefaultPrettyPrinter.class) { // since 2.10\n            throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName()\n                    +\" does not override method; it has to\");\n        }\n        return new DefaultPrettyPrinter(this);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public DefaultPrettyPrinter createInstance()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\nindex 7e8250ef..6515e2fa 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n@@ -252,10 +252,6 @@ public class DefaultPrettyPrinter\n \n     @Override\n     public DefaultPrettyPrinter createInstance() {\n-        if (getClass() != DefaultPrettyPrinter.class) { // since 2.10\n-            throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName()\n-                    +\" does not override method; it has to\");\n-        }\n         return new DefaultPrettyPrinter(this);\n     }\n \n"}
{"identifier": "Closure-165", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\nindex edce9bfd0..6c6fcd45e 100644\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n@@ -695,10 +695,6 @@ public class JSTypeRegistry implements Serializable {\n         if (!greatestSubtype.isEmptyType()) {\n           // We've found a type with this property. Now we just have to make\n           // sure it's not a type used for internal bookkeeping.\n-          RecordType maybeRecordType = greatestSubtype.toMaybeRecordType();\n-          if (maybeRecordType != null && maybeRecordType.isSynthetic()) {\n-            continue;\n-          }\n \n           return true;\n         }\ndiff --git a/src/com/google/javascript/rhino/jstype/ObjectType.java b/src/com/google/javascript/rhino/jstype/ObjectType.java\nindex 37bd48701..82d229de5 100644\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n@@ -287,10 +287,6 @@ public abstract class ObjectType extends JSType implements StaticScope<JSType> {\n    * don't actually exist in the user's program. They're just used for\n    * bookkeeping in the type system.\n    */\n-  public final boolean defineSynthesizedProperty(String propertyName,\n-      JSType type, Node propertyNode) {\n-    return defineProperty(propertyName, type, false, propertyNode);\n-  }\n \n   /**\n    * Defines a property whose type is inferred.\ndiff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nindex 8ff279cbd..7cc48901c 100755\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -65,12 +65,8 @@ class RecordType extends PrototypeObjectType {\n   private static final long serialVersionUID = 1L;\n \n   private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n-  private final boolean declared;\n   private boolean isFrozen = false;\n \n-  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n-    this(registry, properties, true);\n-  }\n \n   /**\n    * Creates a record type.\n@@ -84,11 +80,9 @@ class RecordType extends PrototypeObjectType {\n    * @throws IllegalStateException if the {@code RecordProperty} associated\n    *         with a property is null.\n    */\n-  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties,\n-      boolean declared) {\n+  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n     super(registry, null, null);\n     setPrettyPrint(true);\n-    this.declared = declared;\n \n     for (String property : properties.keySet()) {\n       RecordProperty prop = properties.get(property);\n@@ -96,13 +90,8 @@ class RecordType extends PrototypeObjectType {\n         throw new IllegalStateException(\n             \"RecordProperty associated with a property should not be null!\");\n       }\n-      if (declared) {\n         defineDeclaredProperty(\n             property, prop.getType(), prop.getPropertyNode());\n-      } else {\n-        defineSynthesizedProperty(\n-            property, prop.getType(), prop.getPropertyNode());\n-      }\n     }\n \n     // Freeze the record type.\n@@ -110,9 +99,6 @@ class RecordType extends PrototypeObjectType {\n   }\n \n   /** @return Is this synthesized for internal bookkeeping? */\n-  boolean isSynthetic() {\n-    return !declared;\n-  }\n \n   @Override\n   public boolean isEquivalentTo(JSType other) {\n@@ -163,7 +149,6 @@ class RecordType extends PrototypeObjectType {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-      builder.setSynthesized(true);\n \n       // The greatest subtype consists of those *unique* properties of both\n       // record types. If any property conflicts, then the NO_TYPE type\ndiff --git a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\nindex 60d1e103d..345795b55 100755\n--- a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n@@ -51,7 +51,6 @@ import java.util.HashMap;\n  */\n public class RecordTypeBuilder {\n   private boolean isEmpty = true;\n-  private boolean isDeclared = true;\n   private final JSTypeRegistry registry;\n   private final HashMap<String, RecordProperty> properties = Maps.newHashMap();\n \n@@ -60,9 +59,6 @@ public class RecordTypeBuilder {\n   }\n \n   /** See the comments on RecordType about synthetic types. */\n-  void setSynthesized(boolean synthesized) {\n-    isDeclared = !synthesized;\n-  }\n \n   /**\n    * Adds a property with the given name and type to the record type.\n@@ -93,7 +89,7 @@ public class RecordTypeBuilder {\n     }\n \n     return new RecordType(\n-        registry, Collections.unmodifiableMap(properties), isDeclared);\n+        registry, Collections.unmodifiableMap(properties));\n   }\n \n   static class RecordProperty {\n"}
{"identifier": "JacksonCore-13", "buggy_code": "", "fixed_code": "    @Override\n    public JsonGenerator disable(Feature f) {\n        super.disable(f);\n        if (f == Feature.QUOTE_FIELD_NAMES) {\n            _cfgUnqNames = true;\n        }\n        return this;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\nindex 1270eae4..fb8f21cd 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n@@ -124,14 +124,6 @@ public abstract class JsonGeneratorImpl extends GeneratorBase\n         return this;\n     }\n \n-    @Override\n-    public JsonGenerator disable(Feature f) {\n-        super.disable(f);\n-        if (f == Feature.QUOTE_FIELD_NAMES) {\n-            _cfgUnqNames = true;\n-        }\n-        return this;\n-    }\n \n     @Override\n     protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n"}
{"identifier": "Mockito-29", "buggy_code": "    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }\n", "fixed_code": "    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted == null ? \"null\" : wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic void describeTo(Description description)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/matchers/Same.java b/src/org/mockito/internal/matchers/Same.java\nindex b8267b9..6c172fe 100644\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n@@ -26,7 +26,7 @@ public class Same extends ArgumentMatcher<Object> implements Serializable {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted == null ? \"null\" : wanted.toString());\n+        description.appendText(wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n"}
{"identifier": "Closure-89", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ddccf0d..16d533d 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -481,9 +481,6 @@ class CollapseProperties implements CompilerPass {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n \n-    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n-      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n-    }\n \n     // Create the new alias node.\n     Node nameNode = NodeUtil.newName(\ndiff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 8268339..311e343 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -917,7 +917,7 @@ class GlobalNamespace {\n       }\n \n       // If this is aliased, then its properties can't be collapsed either.\n-      if (aliasingGets > 0) {\n+      if (type != Type.FUNCTION && aliasingGets > 0) {\n         return false;\n       }\n \n"}
{"identifier": "Math-26", "buggy_code": "    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((p2 > overflow) || (q2 > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n", "fixed_code": "    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex 08d3b95..f81ff0a 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -178,7 +178,7 @@ public class Fraction\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n-        if (FastMath.abs(a0) > overflow) {\n+        if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n@@ -206,7 +206,7 @@ public class Fraction\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n-            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n+            if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n"}
{"identifier": "Closure-171", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 4a03b1e3..9367b32f 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -728,7 +728,12 @@ class TypeInference\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n     // Ignore these types of literals.\n     ObjectType objectType = ObjectType.cast(type);\n-    if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {\n+    if (objectType == null) {\n+      return scope;\n+    }\n+    boolean hasLendsName = n.getJSDocInfo() != null &&\n+        n.getJSDocInfo().getLendsName() != null;\n+    if (objectType.hasReferenceName() && !hasLendsName) {\n       return scope;\n     }\n \ndiff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex ef02b9c1..e9e8486f 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1666,9 +1666,6 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n \n       // Prototype sets are always declared.\n-      if (qName != null && qName.endsWith(\".prototype\")) {\n-        return false;\n-      }\n \n       boolean inferred = true;\n       if (info != null) {\n"}
{"identifier": "Math-35", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex 829c97d..67b368d 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -48,7 +48,7 @@ public class ElitisticListPopulation extends ListPopulation {\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        setElitismRate(elitismRate);\n+        this.elitismRate = elitismRate;\n     }\n \n     /**\n@@ -62,7 +62,7 @@ public class ElitisticListPopulation extends ListPopulation {\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        setElitismRate(elitismRate);\n+        this.elitismRate = elitismRate;\n     }\n \n     /**\n"}
{"identifier": "Time-13", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\nindex 29b0872..6c8e9c6 100644\n--- a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n@@ -1095,7 +1095,7 @@ public class PeriodFormatterBuilder {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 // valueLong contains the seconds and millis fields\n                 // the minimum output is 0.000, which is 4 or 5 digits with a negative\n-                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));\n+                sum = Math.max(sum, 4);\n                 // plus one for the decimal point\n                 sum++;\n                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n@@ -1130,7 +1130,6 @@ public class PeriodFormatterBuilder {\n             if (iPrefix != null) {\n                 iPrefix.printTo(buf, value);\n             }\n-            int bufLen = buf.length();\n             int minDigits = iMinPrintedDigits;\n             if (minDigits <= 1) {\n                 FormatUtils.appendUnpaddedInteger(buf, value);\n@@ -1140,9 +1139,6 @@ public class PeriodFormatterBuilder {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n-                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {\n-                        buf.insert(bufLen, '-');\n-                    }\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }\n"}
{"identifier": "Jsoup-72", "buggy_code": "    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n", "fixed_code": "    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex 8269e79..9ed4163 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -424,8 +424,6 @@ public final class CharacterReader {\n         // limit (no cache):\n         if (count > maxStringCacheLen)\n             return new String(charBuf, start, count);\n-        if (count < 1)\n-            return \"\";\n \n         // calculate hash:\n         int hash = 0;\n"}
{"identifier": "Mockito-18", "buggy_code": "    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            //new instances are used instead of Collections.emptyList(), etc.\n            //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        //Let's not care about the rest of collections.\n        return null;\n    }\n", "fixed_code": "    Object returnValueFor(Class<?> type) {\n        if (Primitives.isPrimitiveOrWrapper(type)) {\n            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n            //new instances are used instead of Collections.emptyList(), etc.\n            //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Iterable.class) {\n            return new ArrayList<Object>(0);\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }\n        //Let's not care about the rest of collections.\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nObject returnValueFor(Class<?> type)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\nindex 11304af..06697e5 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n@@ -84,8 +84,6 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n             //new instances are used instead of Collections.emptyList(), etc.\n             //to avoid UnsupportedOperationException if code under test modifies returned collection\n-        } else if (type == Iterable.class) {\n-            return new ArrayList<Object>(0);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {\n"}
{"identifier": "Jsoup-28", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex a60fab8..cc72b7d 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -1,6 +1,5 @@\n package org.jsoup.nodes;\n \n-import org.jsoup.parser.Parser;\n \n import java.io.IOException;\n import java.io.InputStream;\n@@ -59,9 +58,6 @@ public class Entities {\n      * @return true if a known named entity in the base set\n      * @see #isNamedEntity(String)\n      */\n-    public static boolean isBaseNamedEntity(String name) {\n-        return base.containsKey(name);\n-    }\n \n     /**\n      * Get the Character value of the named entity\n@@ -104,7 +100,33 @@ public class Entities {\n      * @return\n      */\n     static String unescape(String string, boolean strict) {\n-        return Parser.unescapeEntities(string, strict);\n+        if (!string.contains(\"&\"))\n+            return string;\n+        Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);\n+        StringBuffer accum = new StringBuffer(string.length());\n+        while (m.find()) {\n+            int charval = -1;\n+            String num = m.group(3);\n+            if (num != null) {\n+                try {\n+                    int base = m.group(2) != null ? 16 : 10;\n+                    charval = Integer.valueOf(num, base);\n+                } catch (NumberFormatException e) {\n+                }\n+            } else {\n+                String name = m.group(1);\n+                if (full.containsKey(name))\n+                    charval = full.get(name);\n+            }\n+            if (charval != -1 || charval > 0xFFFF) {\n+                String c = Character.toString((char) charval);\n+                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n+            } else {\n+                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n+            }\n+        }\n+        m.appendTail(accum);\n+        return accum.toString();\n     }\n \n     // xhtml has restricted entities\ndiff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java\nindex eebce38..ed700d9 100644\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n@@ -130,10 +130,6 @@ public class Parser {\n      * @param inAttribute if the string is to be escaped in strict mode (as attributes are)\n      * @return an unescaped string\n      */\n-    public static String unescapeEntities(String string, boolean inAttribute) {\n-        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());\n-        return tokeniser.unescapeEntities(inAttribute);\n-    }\n \n     /**\n      * @param bodyHtml HTML to parse\ndiff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java\nindex 3445855..cc9f470 100644\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n@@ -133,14 +133,23 @@ class Tokeniser {\n         } else { // named\n             // get as many letters as possible, and look for matching entities.\n             String nameRef = reader.consumeLetterThenDigitSequence();\n+            String origNameRef = new String(nameRef);\n             boolean looksLegit = reader.matches(';');\n             // found if a base named entity without a ;, or an extended entity with the ;.\n-            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n+            boolean found = false;\n+            while (nameRef.length() > 0 && !found) {\n+                if (Entities.isNamedEntity(nameRef))\n+                    found = true;\n+                else {\n+                    nameRef = nameRef.substring(0, nameRef.length()-1);\n+                    reader.unconsume();\n+                }\n+            }\n \n             if (!found) {\n                 reader.rewindToMark();\n                 if (looksLegit) // named with semicolon\n-                    characterReferenceError(String.format(\"invalid named referenece '%s'\", nameRef));\n+                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                 return null;\n             }\n             if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n@@ -226,19 +235,4 @@ class Tokeniser {\n      * @param inAttribute\n      * @return unescaped string from reader\n      */\n-    String unescapeEntities(boolean inAttribute) {\n-        StringBuilder builder = new StringBuilder();\n-        while (!reader.isEmpty()) {\n-            builder.append(reader.consumeTo('&'));\n-            if (reader.matches('&')) {\n-                reader.consume();\n-                Character c = consumeCharacterReference(null, inAttribute);\n-                if (c == null)\n-                    builder.append('&');\n-                else\n-                    builder.append(c);\n-            }\n-        }\n-        return builder.toString();\n-    }\n }\n"}
{"identifier": "Closure-107", "buggy_code": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.processJqueryPrimitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n    CompilationLevel level = flags.compilationLevel;\n    level.setOptionsForCompilationLevel(options);\n\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if (flags.useTypesForOptimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n\n    if (flags.generateExports) {\n      options.setGenerateExports(flags.generateExports);\n    }\n\n    WarningLevel wLevel = flags.warningLevel;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.processClosurePrimitives;\n\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n        flags.processJqueryPrimitives;\n\n    options.angularPass = flags.angularPass;\n\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n      // translations file, they might reasonably try to write their own\n      // implementation of goog.getMsg that makes the substitution at\n      // run-time.\n      //\n      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n      // so we might as well inline it. But shut off the i18n warnings,\n      // because the user didn't really ask for i18n.\n      options.messageBundle = new EmptyMessageBundle();\n    }\n\n    return options;\n  }\n", "fixed_code": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.processJqueryPrimitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n    CompilationLevel level = flags.compilationLevel;\n    level.setOptionsForCompilationLevel(options);\n\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if (flags.useTypesForOptimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n\n    if (flags.generateExports) {\n      options.setGenerateExports(flags.generateExports);\n    }\n\n    WarningLevel wLevel = flags.warningLevel;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.processClosurePrimitives;\n\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n        flags.processJqueryPrimitives;\n\n    options.angularPass = flags.angularPass;\n\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n      // translations file, they might reasonably try to write their own\n      // implementation of goog.getMsg that makes the substitution at\n      // run-time.\n      //\n      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n      // so we might as well inline it. But shut off the i18n warnings,\n      // because the user didn't really ask for i18n.\n      options.messageBundle = new EmptyMessageBundle();\n      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n    }\n\n    return options;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  protected CompilerOptions createOptions()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 3aae2e7..93b3547 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -859,7 +859,6 @@ public class CommandLineRunner extends\n       // so we might as well inline it. But shut off the i18n warnings,\n       // because the user didn't really ask for i18n.\n       options.messageBundle = new EmptyMessageBundle();\n-      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n     }\n \n     return options;\n"}
{"identifier": "Closure-84", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex d2a4e5d..cca8d9b 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -338,13 +338,6 @@ public class IRFactory {\n     @Override\n     Node processAssignment(Assignment assignmentNode) {\n       Node assign = processInfixExpression(assignmentNode);\n-      Node target = assign.getFirstChild();\n-      if (!validAssignmentTarget(target)) {\n-        errorReporter.error(\n-          \"invalid assignment target\",\n-          sourceName,\n-          target.getLineno(), \"\", 0);\n-      }\n       return assign;\n     }\n \n@@ -801,17 +794,6 @@ public class IRFactory {\n         operand.setDouble(-operand.getDouble());\n         return operand;\n       } else {\n-        if (type == Token.INC || type == Token.DEC) {\n-          if (!validAssignmentTarget(operand)) {\n-            String msg = (type == Token.INC)\n-                ? \"invalid increment target\"\n-                : \"invalid decrement target\";\n-            errorReporter.error(\n-              msg,\n-              sourceName,\n-              operand.getLineno(), \"\", 0);\n-          }\n-        }\n \n         Node node = newNode(type, operand);\n         if (exprNode.isPostfix()) {\n@@ -821,15 +803,6 @@ public class IRFactory {\n       }\n     }\n \n-    private boolean validAssignmentTarget(Node target) {\n-      switch (target.getType()) {\n-        case Token.NAME:\n-        case Token.GETPROP:\n-        case Token.GETELEM:\n-          return true;\n-      }\n-      return false;\n-    }\n \n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {\n"}
{"identifier": "Closure-102", "buggy_code": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }\n", "fixed_code": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public void process(Node externs, Node root)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex 1db94e2..4aa4555 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -86,12 +86,12 @@ class Normalize implements CompilerPass, Callback {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n"}
{"identifier": "JacksonCore-7", "buggy_code": "    public int writeValue() {\n        // Most likely, object:\n        if (_type == TYPE_OBJECT) {\n            _gotName = false;\n            ++_index;\n            return STATUS_OK_AFTER_COLON;\n        }\n\n        // Ok, array?\n        if (_type == TYPE_ARRAY) {\n            int ix = _index;\n            ++_index;\n            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n        }\n        \n        // Nope, root context\n        // No commas within root context, but need space\n        ++_index;\n        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n    }\n", "fixed_code": "    public int writeValue() {\n        // Most likely, object:\n        if (_type == TYPE_OBJECT) {\n            if (!_gotName) {\n                return STATUS_EXPECT_NAME;\n            }\n            _gotName = false;\n            ++_index;\n            return STATUS_OK_AFTER_COLON;\n        }\n\n        // Ok, array?\n        if (_type == TYPE_ARRAY) {\n            int ix = _index;\n            ++_index;\n            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n        }\n        \n        // Nope, root context\n        // No commas within root context, but need space\n        ++_index;\n        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic int writeValue()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\nindex a5706c8d..4ff12d70 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n@@ -166,9 +166,6 @@ public class JsonWriteContext extends JsonStreamContext\n     public int writeValue() {\n         // Most likely, object:\n         if (_type == TYPE_OBJECT) {\n-            if (!_gotName) {\n-                return STATUS_EXPECT_NAME;\n-            }\n             _gotName = false;\n             ++_index;\n             return STATUS_OK_AFTER_COLON;\n"}
{"identifier": "Closure-155", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 7d99778c8..18c9fbe2c 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -196,8 +196,6 @@ class InlineVariables implements CompilerPass {\n     private void doInlinesForScope(NodeTraversal t,\n         Map<Var, ReferenceCollection> referenceMap) {\n \n-      boolean maybeModifiedArguments =\n-          maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);\n       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n         Var v = it.next();\n \n@@ -219,44 +217,17 @@ class InlineVariables implements CompilerPass {\n           // inlining heuristics. See InlineConstantsTest.\n           continue;\n         } else {\n-          inlineNonConstants(v, referenceInfo, maybeModifiedArguments);\n+          inlineNonConstants(v, referenceInfo);\n         }\n       }\n     }\n \n-    private boolean maybeEscapedOrModifiedArguments(\n-        Scope scope, Map<Var, ReferenceCollection> referenceMap) {\n-      if (scope.isLocal()) {\n-        Var arguments = scope.getArgumentsVar();\n-        ReferenceCollection refs = referenceMap.get(arguments);\n-        if (refs != null && !refs.references.isEmpty()) {\n-          for (Reference ref : refs.references) {\n-            Node refNode = ref.getNameNode();\n-            Node refParent = ref.getParent();\n             // Any reference that is not a read of the arguments property\n             // consider a escape of the arguments object.\n-            if (!(NodeUtil.isGet(refParent)\n-                && refNode == ref.getParent().getFirstChild()\n-                && !isLValue(refParent))) {\n-              return true;\n-            }\n-          }\n-        }\n-      }\n-      return false;\n-    }\n \n-    private boolean isLValue(Node n) {\n-      Node parent = n.getParent();\n-      return (parent.getType() == Token.INC\n-          || parent.getType() == Token.DEC\n-          || (NodeUtil.isAssignmentOp(parent)\n-          && parent.getFirstChild() == n));\n-    }\n \n     private void inlineNonConstants(\n-        Var v, ReferenceCollection referenceInfo,\n-        boolean maybeModifiedArguments) {\n+        Var v, ReferenceCollection referenceInfo) {\n       int refCount = referenceInfo.references.size();\n       Reference declaration = referenceInfo.references.get(0);\n       Reference init = referenceInfo.getInitializingReference();\n@@ -301,7 +272,7 @@ class InlineVariables implements CompilerPass {\n       // inline an alias of it. (If the variable was inlined, then the\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n-      if (!maybeModifiedArguments &&\n+      if (\n           !staleVars.contains(v) && referenceInfo.isWellDefined() &&\n           referenceInfo.isAssignedOnceInLifetime()) {\n         List<Reference> refs = referenceInfo.references;\ndiff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex 4c00d60e6..e3edbb4d6 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -120,12 +120,7 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n    */\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.NAME) {\n-      Var v;\n-      if (n.getString().equals(\"arguments\")) {\n-        v = t.getScope().getArgumentsVar();\n-      } else {\n-        v = t.getScope().getVar(n.getString());\n-      }\n+      Var v = t.getScope().getVar(n.getString());\n       if (v != null && varFilter.apply(v)) {\n         addReference(t, v,\n             new Reference(n, parent, t, blockStack.peek()));\ndiff --git a/src/com/google/javascript/jscomp/Scope.java b/src/com/google/javascript/jscomp/Scope.java\nindex 19ac9d2bc..806ca2742 100644\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n@@ -60,7 +60,6 @@ public class Scope implements StaticScope<JSType> {\n   /** Whether this is a bottom scope for the purposes of type inference. */\n   private final boolean isBottom;\n \n-  private Var arguments;\n \n   /** Stores info about a variable */\n   public static class Var implements StaticSlot<JSType> {\n@@ -288,35 +287,10 @@ public class Scope implements StaticScope<JSType> {\n    * scope.\n    */\n   // TODO(johnlenz): Include this the list of Vars for the scope.\n-  public static class Arguments extends Var {\n-    Arguments(Scope scope) {\n-      super(\n-        false, // no inferred\n-        \"arguments\", // always arguments\n-        null,  // no declaration node\n         // TODO(johnlenz): provide the type of \"Arguments\".\n-        null,  // no type info\n-        scope,\n-        -1,    // no variable index\n-        null,  // input,\n-        false, // not a define\n-        null   // no jsdoc\n-        );\n-    }\n \n-    @Override public boolean equals(Object other) {\n-      if (!(other instanceof Arguments)) {\n-        return false;\n-      }\n \n-      Arguments otherVar = (Arguments) other;\n-      return otherVar.scope.getRootNode() == scope.getRootNode();\n-    }\n \n-    @Override public int hashCode() {\n-      return System.identityHashCode(this);\n-    }\n-  }\n \n   /**\n    * Creates a Scope given the parent Scope and the root node of the scope.\n@@ -482,12 +456,6 @@ public class Scope implements StaticScope<JSType> {\n   /**\n    * Get a unique VAR object to represents \"arguments\" within this scope\n    */\n-  public Var getArgumentsVar() {\n-    if (arguments == null) {\n-      arguments = new Arguments(this);\n-    }\n-    return arguments;\n-  }\n \n   /**\n    * Returns true if a variable is declared.\n"}
{"identifier": "Math-31", "buggy_code": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double p0 = 1.0;\n        double q1 = 1.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            double cN = a * hPrev + b * p0;\n            double q2 = a * q1 + b * dPrev;\n            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n                }\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                    } else if (b != 0) {\n                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                    }\n                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                        break;\n                    }\n                }\n            }\n\n            final double deltaN = cN / q2 / cPrev;\n            hN = cPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            double dN = a + b * dPrev;\n            if (Precision.equals(dN, 0.0, small)) {\n                dN = small;\n            }\n            double cN = a + b / cPrev;\n            if (Precision.equals(cN, 0.0, small)) {\n                cN = small;\n            }\n\n            dN = 1 / dN;\n            final double deltaN = cN * dN;\n            hN = hPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            dPrev = dN;\n            cPrev = cN;\n            hPrev = hN;\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\nindex 253f3c5..b881bb2 100644\n--- a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n@@ -131,6 +131,8 @@ public abstract class ContinuedFraction {\n \n         int n = 1;\n         double dPrev = 0.0;\n+        double p0 = 1.0;\n+        double q1 = 1.0;\n         double cPrev = hPrev;\n         double hN = hPrev;\n \n@@ -138,18 +140,34 @@ public abstract class ContinuedFraction {\n             final double a = getA(n, x);\n             final double b = getB(n, x);\n \n-            double dN = a + b * dPrev;\n-            if (Precision.equals(dN, 0.0, small)) {\n-                dN = small;\n-            }\n-            double cN = a + b / cPrev;\n-            if (Precision.equals(cN, 0.0, small)) {\n-                cN = small;\n+            double cN = a * hPrev + b * p0;\n+            double q2 = a * q1 + b * dPrev;\n+            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n+                double scaleFactor = 1d;\n+                double lastScaleFactor = 1d;\n+                final int maxPower = 5;\n+                final double scale = FastMath.max(a,b);\n+                if (scale <= 0) {  // Can't scale\n+                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n+                }\n+                for (int i = 0; i < maxPower; i++) {\n+                    lastScaleFactor = scaleFactor;\n+                    scaleFactor *= scale;\n+                    if (a != 0.0 && a > b) {\n+                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n+                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n+                    } else if (b != 0) {\n+                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n+                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n+                    }\n+                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n+                        break;\n+                    }\n+                }\n             }\n \n-            dN = 1 / dN;\n-            final double deltaN = cN * dN;\n-            hN = hPrev * deltaN;\n+            final double deltaN = cN / q2 / cPrev;\n+            hN = cPrev * deltaN;\n \n             if (Double.isInfinite(hN)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n@@ -164,9 +182,11 @@ public abstract class ContinuedFraction {\n                 break;\n             }\n \n-            dPrev = dN;\n-            cPrev = cN;\n-            hPrev = hN;\n+            dPrev = q1;\n+            cPrev = cN / q2;\n+            p0 = hPrev;\n+            hPrev = cN;\n+            q1 = q2;\n             n++;\n         }\n \n"}
{"identifier": "Math-95", "buggy_code": "    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }\n", "fixed_code": "    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret = 1.0;\n        double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n            // use mean\n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex 59aeb07..e19e97a 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -141,12 +141,10 @@ public class FDistributionImpl\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret = 1.0;\n+        double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-        if (d > 2.0) {\n             // use mean\n             ret = d / (d - 2.0);\n-        }\n         return ret;\n     }\n     \n"}
{"identifier": "Math-80", "buggy_code": "    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n", "fixed_code": "    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * (n - 1);\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 9d1b797..3fc328d 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * (n - 1);\n+            int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n"}
{"identifier": "Jsoup-85", "buggy_code": "    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        this.key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.val = val;\n        this.parent = parent;\n    }\n", "fixed_code": "    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, String val, Attributes parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex e321b6a..612fdeb 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -41,9 +41,8 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      * @see #createFromEncoded*/\n     public Attribute(String key, String val, Attributes parent) {\n         Validate.notNull(key);\n-        key = key.trim();\n+        this.key = key.trim();\n         Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n-        this.key = key;\n         this.val = val;\n         this.parent = parent;\n     }\n"}
{"identifier": "JacksonDatabind-105", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\nindex 7743deae2..c4c0ed93f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n@@ -19,8 +19,7 @@ public class JdkDeserializers\n                 UUID.class,\n                 AtomicBoolean.class,\n                 StackTraceElement.class,\n-                ByteBuffer.class,\n-                Void.class\n+                ByteBuffer.class\n         };\n         for (Class<?> cls : types) { _classNames.add(cls.getName()); }\n         for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }\n@@ -46,9 +45,6 @@ public class JdkDeserializers\n             if (rawType == ByteBuffer.class) {\n                 return new ByteBufferDeserializer();\n             }\n-            if (rawType == Void.class) {\n-                return NullifyingDeserializer.instance;\n-            }\n         }\n         return null;\n     }\n"}
{"identifier": "Lang-35", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/ArrayUtils.java b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\nindex 3a543ce..ac22f8f 100644\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -3292,7 +3292,7 @@ public class ArrayUtils {\n         } else if (element != null) {\n             type = element.getClass();\n         } else {\n-            throw new IllegalArgumentException(\"Arguments cannot both be null\");            \n+            type = Object.class;\n         }\n         @SuppressWarnings(\"unchecked\") // type must be T\n         T[] newArray = (T[]) copyArrayGrow1(array, type);\n@@ -3571,7 +3571,7 @@ public class ArrayUtils {\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n-            throw new IllegalArgumentException(\"Array and element cannot both be null\");            \n+            return (T[]) new Object[] { null };\n         }\n         @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n         final T[] newArray = (T[]) add(array, index, element, clss);\n"}
{"identifier": "Closure-114", "buggy_code": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }\n", "fixed_code": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void recordAssignment(NodeTraversal t, Node n, Node recordNode)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex a7b95b0..0fc5ae8 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -575,7 +575,7 @@ final class NameAnalyzer implements CompilerPass {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n+        } else {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n"}
{"identifier": "JacksonCore-5", "buggy_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n", "fixed_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate final static int _parseIndex(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\nindex a8022391..d353b392 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n@@ -190,7 +190,7 @@ public class JsonPointer\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+            char c = str.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n"}
{"identifier": "Math-41", "buggy_code": "    /**\n     * Returns the weighted variance of the entries in the specified portion of\n     * the input array, using the precomputed weighted mean value.  Returns\n     * <code>Double.NaN</code> if the designated subarray is empty.\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n", "fixed_code": "    /**\n     * Returns the weighted variance of the entries in the specified portion of\n     * the input array, using the precomputed weighted mean value.  Returns\n     * <code>Double.NaN</code> if the designated subarray is empty.\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = begin; i < begin + length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the weighted variance of the entries in the specified portion of\n     * the input array, using the precomputed weighted mean value.  Returns\n     * <code>Double.NaN</code> if the designated subarray is empty.\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex 1de139f..e5518e3 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,7 +517,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n-                for (int i = begin; i < begin + length; i++) {\n+                for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n"}
{"identifier": "Closure-68", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex 167e2cb..26a56a7 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -865,9 +865,9 @@ public final class JsDocInfoParser {\n                         }\n                         break;\n                     }\n-                  }\n \n                   token = eatTokensUntilEOL();\n+                  }\n                   continue retry;\n               }\n             }\n@@ -1706,7 +1706,6 @@ public final class JsDocInfoParser {\n       }\n     }\n \n-    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }\n \n@@ -1759,7 +1758,6 @@ public final class JsDocInfoParser {\n     // NOTE(nicksantos): We're not implementing generics at the moment, so\n     // just throw out TypeParameters.\n     if (token != JsDocToken.LP) {\n-      restoreLookAhead(token);\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }\n \n"}
{"identifier": "Math-7", "buggy_code": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n", "fixed_code": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                    isLastStep = isLastStep || state.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                boolean needReset = false;\n                for (final EventState state : eventsStates) {\n                    needReset =  needReset || state.reset(eventT, eventY);\n                }\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex 6e0237f..f24f87c 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -343,10 +343,8 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                for (final EventState state : eventsStates) {\n-                    state.stepAccepted(eventT, eventY);\n-                    isLastStep = isLastStep || state.stop();\n-                }\n+                currentEvent.stepAccepted(eventT, eventY);\n+                isLastStep = currentEvent.stop();\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n@@ -356,19 +354,22 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n-                boolean needReset = false;\n-                for (final EventState state : eventsStates) {\n-                    needReset =  needReset || state.reset(eventT, eventY);\n-                }\n+                boolean needReset = currentEvent.reset(eventT, eventY);\n                 if (needReset) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n"}
{"identifier": "Math-39", "buggy_code": "  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // iterate over step size, ensuring local normalized error is smaller than 1\n      double error = 10;\n      while (error >= 1.0) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // local error is small enough: accept the step, trigger events and step handlers\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n      System.arraycopy(y, 0, yTmp, 0, y.length);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          if (fsal) {\n              // save the last evaluation for the next step\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          // stepsize control for next step\n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }\n", "fixed_code": "  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // iterate over step size, ensuring local normalized error is smaller than 1\n      double error = 10;\n      while (error >= 1.0) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n        if (forward) {\n            if (stepStart + stepSize >= t) {\n                stepSize = t - stepStart;\n            }\n        } else {\n            if (stepStart + stepSize <= t) {\n                stepSize = t - stepStart;\n            }\n        }\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // local error is small enough: accept the step, trigger events and step handlers\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n      System.arraycopy(y, 0, yTmp, 0, y.length);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          if (fsal) {\n              // save the last evaluation for the next step\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          // stepsize control for next step\n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex d2bbf67..13ced27 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,15 +247,6 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n-        if (forward) {\n-            if (stepStart + stepSize >= t) {\n-                stepSize = t - stepStart;\n-            }\n-        } else {\n-            if (stepStart + stepSize <= t) {\n-                stepSize = t - stepStart;\n-            }\n-        }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {\n"}
{"identifier": "Math-61", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\nindex 0a81233..148daad 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n@@ -19,7 +19,7 @@ package org.apache.commons.math.distribution;\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.MathUtils;\n@@ -91,7 +91,7 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n"}
{"identifier": "Time-20", "buggy_code": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }\n", "fixed_code": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            String best = null;\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                \tif (best == null || id.length() > best.length()) {\n                \t\tbest = id;\n                \t}\n                }\n            }\n            if (best != null) {\n                bucket.setZone(DateTimeZone.forID(best));\n                return position + best.length();\n            }\n            return ~position;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic int parseInto(DateTimeParserBucket bucket, String text, int position)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\nindex ebb4b08..558a586 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n@@ -2539,18 +2539,12 @@ public class DateTimeFormatterBuilder {\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n-            String best = null;\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                \tif (best == null || id.length() > best.length()) {\n-                \t\tbest = id;\n-                \t}\n+                    bucket.setZone(DateTimeZone.forID(id));\n+                    return position + id.length();\n                 }\n             }\n-            if (best != null) {\n-                bucket.setZone(DateTimeZone.forID(best));\n-                return position + best.length();\n-            }\n             return ~position;\n         }\n     }\n"}
{"identifier": "Cli-8", "buggy_code": "    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, nextLineTabStop);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 40873f5..639b9d5 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -809,7 +809,7 @@ public class HelpFormatter {\n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n+            pos = findWrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n"}
{"identifier": "Math-8", "buggy_code": "    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n        for (int i = 0; i < sampleSize; i++) {\n            out[i] = sample();\n        }\n\n        return out;\n\n    }\n", "fixed_code": "    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final Object[] out = new Object[sampleSize];\n\n        for (int i = 0; i < sampleSize; i++) {\n            out[i] = sample();\n        }\n\n        return out;\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 879eb2a..5cb0e43 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -178,13 +178,13 @@ public class DiscreteDistribution<T> {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n+    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n \n-        final Object[] out = new Object[sampleSize];\n+        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n"}
{"identifier": "Closure-164", "buggy_code": "  @Override\n  public boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n      return false;\n    }\n\n    ArrowType that = (ArrowType) other;\n\n    // This is described in Draft 2 of the ES4 spec,\n    // Section 3.4.7: Subtyping Function Types.\n\n    // this.returnType <: that.returnType (covariant)\n    if (!this.returnType.isSubtype(that.returnType)) {\n      return false;\n    }\n\n    // that.paramType[i] <: this.paramType[i] (contravariant)\n    //\n    // If this.paramType[i] is required,\n    // then that.paramType[i] is required.\n    //\n    // In theory, the \"required-ness\" should work in the other direction as\n    // well. In other words, if we have\n    //\n    // function f(number, number) {}\n    // function g(number) {}\n    //\n    // Then f *should* not be a subtype of g, and g *should* not be\n    // a subtype of f. But in practice, we do not implement it this way.\n    // We want to support the use case where you can pass g where f is\n    // expected, and pretend that g ignores the second argument.\n    // That way, you can have a single \"no-op\" function, and you don't have\n    // to create a new no-op function for every possible type signature.\n    //\n    // So, in this case, g < f, but f !< g\n    Node thisParam = parameters.getFirstChild();\n    Node thatParam = that.parameters.getFirstChild();\n    while (thisParam != null && thatParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType thatParamType = thatParam.getJSType();\n      if (thisParamType != null) {\n        if (thatParamType == null ||\n            !thatParamType.isSubtype(thisParamType)) {\n          return false;\n        }\n      }\n\n      boolean thisIsVarArgs = thisParam.isVarArgs();\n      boolean thatIsVarArgs = thatParam.isVarArgs();\n\n      // \"that\" can't be a supertype, because it's missing a required argument.\n        // NOTE(nicksantos): In our type system, we use {function(...?)} and\n        // {function(...NoType)} to to indicate that arity should not be\n        // checked. Strictly speaking, this is not a correct formulation,\n        // because now a sub-function can required arguments that are var_args\n        // in the super-function. So we special-case this.\n\n      // don't advance if we have variable arguments\n      if (!thisIsVarArgs) {\n        thisParam = thisParam.getNext();\n      }\n      if (!thatIsVarArgs) {\n        thatParam = thatParam.getNext();\n      }\n\n      // both var_args indicates the end\n      if (thisIsVarArgs && thatIsVarArgs) {\n        thisParam = null;\n        thatParam = null;\n      }\n    }\n\n    // \"that\" can't be a supertype, because it's missing a required arguement.\n\n    return true;\n  }\n", "fixed_code": "  @Override\n  public boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n      return false;\n    }\n\n    ArrowType that = (ArrowType) other;\n\n    // This is described in Draft 2 of the ES4 spec,\n    // Section 3.4.7: Subtyping Function Types.\n\n    // this.returnType <: that.returnType (covariant)\n    if (!this.returnType.isSubtype(that.returnType)) {\n      return false;\n    }\n\n    // that.paramType[i] <: this.paramType[i] (contravariant)\n    //\n    // If this.paramType[i] is required,\n    // then that.paramType[i] is required.\n    //\n    // In theory, the \"required-ness\" should work in the other direction as\n    // well. In other words, if we have\n    //\n    // function f(number, number) {}\n    // function g(number) {}\n    //\n    // Then f *should* not be a subtype of g, and g *should* not be\n    // a subtype of f. But in practice, we do not implement it this way.\n    // We want to support the use case where you can pass g where f is\n    // expected, and pretend that g ignores the second argument.\n    // That way, you can have a single \"no-op\" function, and you don't have\n    // to create a new no-op function for every possible type signature.\n    //\n    // So, in this case, g < f, but f !< g\n    Node thisParam = parameters.getFirstChild();\n    Node thatParam = that.parameters.getFirstChild();\n    while (thisParam != null && thatParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType thatParamType = thatParam.getJSType();\n      if (thisParamType != null) {\n        if (thatParamType == null ||\n            !thatParamType.isSubtype(thisParamType)) {\n          return false;\n        }\n      }\n\n      boolean thisIsVarArgs = thisParam.isVarArgs();\n      boolean thatIsVarArgs = thatParam.isVarArgs();\n      boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();\n      boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();\n\n      // \"that\" can't be a supertype, because it's missing a required argument.\n      if (!thisIsOptional && thatIsOptional) {\n        // NOTE(nicksantos): In our type system, we use {function(...?)} and\n        // {function(...NoType)} to to indicate that arity should not be\n        // checked. Strictly speaking, this is not a correct formulation,\n        // because now a sub-function can required arguments that are var_args\n        // in the super-function. So we special-case this.\n        boolean isTopFunction =\n            thatIsVarArgs &&\n            (thatParamType == null ||\n             thatParamType.isUnknownType() ||\n             thatParamType.isNoType());\n        if (!isTopFunction) {\n          return false;\n        }\n      }\n\n      // don't advance if we have variable arguments\n      if (!thisIsVarArgs) {\n        thisParam = thisParam.getNext();\n      }\n      if (!thatIsVarArgs) {\n        thatParam = thatParam.getNext();\n      }\n\n      // both var_args indicates the end\n      if (thisIsVarArgs && thatIsVarArgs) {\n        thisParam = null;\n        thatParam = null;\n      }\n    }\n\n    // \"that\" can't be a supertype, because it's missing a required arguement.\n    if (thisParam != null\n        && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n        && thatParam == null) {\n      return false;\n    }\n\n    return true;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public boolean isSubtype(JSType other)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/ArrowType.java b/src/com/google/javascript/rhino/jstype/ArrowType.java\nindex 4b9583778..1c900acd9 100644\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n@@ -125,25 +125,13 @@ final class ArrowType extends JSType {\n \n       boolean thisIsVarArgs = thisParam.isVarArgs();\n       boolean thatIsVarArgs = thatParam.isVarArgs();\n-      boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();\n-      boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();\n \n       // \"that\" can't be a supertype, because it's missing a required argument.\n-      if (!thisIsOptional && thatIsOptional) {\n         // NOTE(nicksantos): In our type system, we use {function(...?)} and\n         // {function(...NoType)} to to indicate that arity should not be\n         // checked. Strictly speaking, this is not a correct formulation,\n         // because now a sub-function can required arguments that are var_args\n         // in the super-function. So we special-case this.\n-        boolean isTopFunction =\n-            thatIsVarArgs &&\n-            (thatParamType == null ||\n-             thatParamType.isUnknownType() ||\n-             thatParamType.isNoType());\n-        if (!isTopFunction) {\n-          return false;\n-        }\n-      }\n \n       // don't advance if we have variable arguments\n       if (!thisIsVarArgs) {\n@@ -161,11 +149,6 @@ final class ArrowType extends JSType {\n     }\n \n     // \"that\" can't be a supertype, because it's missing a required arguement.\n-    if (thisParam != null\n-        && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n-        && thatParam == null) {\n-      return false;\n-    }\n \n     return true;\n   }\n"}
{"identifier": "Math-89", "buggy_code": "    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not Comparable, \n     *         or is not comparable with previous entries\n     * @deprecated use {@link #addValue(Comparable)} instead\n     */\n    @Deprecated\n    public void addValue(Object v) {\n            addValue((Comparable<?>) v);            \n    }\n", "fixed_code": "    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not Comparable, \n     *         or is not comparable with previous entries\n     * @deprecated use {@link #addValue(Comparable)} instead\n     */\n    @Deprecated\n    public void addValue(Object v) {\n        if (v instanceof Comparable<?>){\n            addValue((Comparable<?>) v);            \n        } else {\n            throw new IllegalArgumentException(\"Object must implement Comparable\");\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not Comparable, \n     *         or is not comparable with previous entries\n     * @deprecated use\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex 70d622d..c8deca3 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,11 +107,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n-        } else {\n-            throw new IllegalArgumentException(\"Object must implement Comparable\");\n-        }\n     }\n     \n     /**\n"}
{"identifier": "Csv-2", "buggy_code": "    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or {@code null} if the column name is not found\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if the record is inconsistent\n     * @see #isConsistent()\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n            return index != null ? values[index.intValue()] : null;\n    }\n", "fixed_code": "    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or {@code null} if the column name is not found\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if the record is inconsistent\n     * @see #isConsistent()\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        try {\n            return index != null ? values[index.intValue()] : null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\n                            \"Index for header '%s' is %d but CSVRecord only has %d values!\",\n                            name, index.intValue(), values.length));\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex fd633c2..dc52017 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -82,14 +82,7 @@ public class CSVRecord implements Serializable, Iterable<String> {\n                     \"No header mapping was specified, the record values can't be accessed by name\");\n         }\n         final Integer index = mapping.get(name);\n-        try {\n             return index != null ? values[index.intValue()] : null;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\n-                    String.format(\n-                            \"Index for header '%s' is %d but CSVRecord only has %d values!\",\n-                            name, index.intValue(), values.length));\n-        }\n     }\n \n     /**\n"}
{"identifier": "Closure-121", "buggy_code": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (refCount == firstRefAfterInit) {\n        // The variable likely only read once, try some more\n        // complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(\n            firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only reference is the initialization, remove the assignment and\n          // the variable declaration.\n          Node value = init.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(v, value, referenceInfo.references);\n          staleVars.add(v);\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) &&\n          referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n          // Inlining the variable based solely on well-defined and assigned\n          // once is *NOT* correct. We relax the correctness requirement if\n          // the variable is declared constant.\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias)) {\n              Reference aliasInit;\n              aliasInit = candidate.refInfo.getInitializingReference();\n              Node value = aliasInit.getAssignedValue();\n              Preconditions.checkNotNull(value);\n              inlineWellDefinedVariable(candidate.alias,\n                  value,\n                  candidate.refInfo.references);\n              staleVars.add(candidate.alias);\n            }\n          }\n        }\n      }\n    }\n", "fixed_code": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (refCount == firstRefAfterInit) {\n        // The variable likely only read once, try some more\n        // complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(\n            firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only reference is the initialization, remove the assignment and\n          // the variable declaration.\n          Node value = init.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(v, value, referenceInfo.references);\n          staleVars.add(v);\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) &&\n          referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime() &&\n          // Inlining the variable based solely on well-defined and assigned\n          // once is *NOT* correct. We relax the correctness requirement if\n          // the variable is declared constant.\n          (isInlineableDeclaredConstant(v, referenceInfo) ||\n           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias)) {\n              Reference aliasInit;\n              aliasInit = candidate.refInfo.getInitializingReference();\n              Node value = aliasInit.getAssignedValue();\n              Preconditions.checkNotNull(value);\n              inlineWellDefinedVariable(candidate.alias,\n                  value,\n                  candidate.refInfo.references);\n              staleVars.add(candidate.alias);\n            }\n          }\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 5c9df61..376abd4 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -301,12 +301,10 @@ class InlineVariables implements CompilerPass {\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime() &&\n+          referenceInfo.isAssignedOnceInLifetime()) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n-          (isInlineableDeclaredConstant(v, referenceInfo) ||\n-           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNode();\n"}
{"identifier": "Cli-14", "buggy_code": "    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n            if (validate) {\n                option.validate(commandLine);\n            }\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n", "fixed_code": "    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n                validate = true;\n            }\n\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic void validate(final WriteableCommandLine commandLine)\n        throws OptionException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli2/option/GroupImpl.java b/src/java/org/apache/commons/cli2/option/GroupImpl.java\nindex e3b69f8..781d0b6 100644\n--- a/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n@@ -247,6 +247,9 @@ public class GroupImpl\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n+            if (validate) {\n+                option.validate(commandLine);\n+            }\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n@@ -255,10 +258,7 @@ public class GroupImpl\n \n                     break;\n                 }\n-                validate = true;\n-            }\n \n-            if (validate) {\n                 option.validate(commandLine);\n             }\n         }\n"}
{"identifier": "Jsoup-65", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 041dcbd..6ada343 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -357,11 +357,11 @@ public class HtmlTreeBuilder extends TreeBuilder {\n     }\n \n     void clearStackToTableBodyContext() {\n-        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n+        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n     }\n \n     void clearStackToTableRowContext() {\n-        clearStackToContext(\"tr\", \"template\");\n+        clearStackToContext(\"tr\");\n     }\n \n     private void clearStackToContext(String... nodeNames) {\ndiff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex c4924e4..aaf6041 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -1033,9 +1033,7 @@ enum HtmlTreeBuilderState {\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n                     String name = startTag.normalName();\n-                    if (name.equals(\"template\")) {\n-                        tb.insert(startTag);\n-                    } else if (name.equals(\"tr\")) {\n+                    if (name.equals(\"tr\")) {\n                         tb.clearStackToTableBodyContext();\n                         tb.insert(startTag);\n                         tb.transition(InRow);\n@@ -1095,9 +1093,7 @@ enum HtmlTreeBuilderState {\n                 Token.StartTag startTag = t.asStartTag();\n                 String name = startTag.normalName();\n \n-                if (name.equals(\"template\")) {\n-                    tb.insert(startTag);\n-                } else if (StringUtil.in(name, \"th\", \"td\")) {\n+                if (StringUtil.in(name, \"th\", \"td\")) {\n                     tb.clearStackToTableRowContext();\n                     tb.insert(startTag);\n                     tb.transition(InCell);\n"}
{"identifier": "Lang-59", "buggy_code": "    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n", "fixed_code": "    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 4c14509..886d424 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, width, buffer, size);\n+                str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n"}
{"identifier": "Codec-3", "buggy_code": "    /**\n     * Handles 'G' cases\n     */\n    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") && \n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 4, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n", "fixed_code": "    /**\n     * Handles 'G' cases\n     */\n    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic) {\n        if (charAt(value, index + 1) == 'H') {\n            index = handleGH(value, result, index);\n        } else if (charAt(value, index + 1) == 'N') {\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n                result.append(\"KN\", \"N\");\n            } else if (!contains(value, index + 2, 2, \"EY\") && \n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n                result.append(\"N\", \"KN\");\n            } else {\n                result.append(\"KN\");\n            }\n            index = index + 2;\n        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n            result.append(\"KL\", \"L\");\n            index += 2;\n        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Handles 'G' cases\n     */\n    private int handleG(String value, \n                        DoubleMetaphoneResult result, \n                        int index, \n                        boolean slavoGermanic)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\nindex f7122d41..e2b8e110 100644\n--- a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n@@ -452,7 +452,7 @@ public class DoubleMetaphone implements StringEncoder {\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 3, \"IER\")) {\n+            } else if (contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n"}
{"identifier": "Math-101", "buggy_code": "    /**\n     * Parses a string to produce a {@link Complex} object.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Complex} object.\n     */\n    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n", "fixed_code": "    /**\n     * Parses a string to produce a {@link Complex} object.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Complex} object.\n     */\n    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if ((startIndex >= source.length()) ||\n            (endIndex > source.length()) ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parses a string to produce a\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/complex/ComplexFormat.java b/src/java/org/apache/commons/math/complex/ComplexFormat.java\nindex 0757d9b..b404bc4 100644\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -374,8 +374,7 @@ public class ComplexFormat extends Format implements Serializable {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if ((startIndex >= source.length()) ||\n-            (endIndex > source.length()) ||\n+        if (\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n"}
{"identifier": "Chart-12", "buggy_code": "    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        this.dataset = dataset;\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n", "fixed_code": "    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        setDataset(dataset);\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/plot/MultiplePiePlot.java b/source/org/jfree/chart/plot/MultiplePiePlot.java\nindex 5fe04cb..fedc205 100644\n--- a/source/org/jfree/chart/plot/MultiplePiePlot.java\n+++ b/source/org/jfree/chart/plot/MultiplePiePlot.java\n@@ -142,7 +142,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        setDataset(dataset);\n+        this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n"}
{"identifier": "Lang-3", "buggy_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n    * <code>BigDecimal</code>.</p>\n    * \n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigDecimal as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals = 0; // Check required precision (LANG-693)\n        if (decPos > -1) { // there is a decimal point\n\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }\n", "fixed_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n    * <code>BigDecimal</code>.</p>\n    * \n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigDecimal as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals = 0; // Check required precision (LANG-693)\n        if (decPos > -1) { // there is a decimal point\n\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 1e6ccdc..c584021 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -590,22 +590,18 @@ public class NumberUtils {\n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n-            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n-            }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n-            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n-            }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n"}
{"identifier": "Math-97", "buggy_code": "    /**\n     * Find a zero in the given interval.\n     * <p>\n     * Requires that the values of the function at the endpoints have opposite\n     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n     * the case.</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function \n     * @throws IllegalArgumentException if min is not less than max or the\n     * signs of the values of the function at the endpoints are not opposites\n     */\n    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign >= 0) {\n            // check if either value is close to a zero\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        } else {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        }\n\n        return ret;\n    }\n", "fixed_code": "    /**\n     * Find a zero in the given interval.\n     * <p>\n     * Requires that the values of the function at the endpoints have opposite\n     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n     * the case.</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function \n     * @throws IllegalArgumentException if min is not less than max or the\n     * signs of the values of the function at the endpoints are not opposites\n     */\n    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign > 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        } else if (sign < 0){\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n        } else {\n            // either min or max is a root\n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n\n        return ret;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Find a zero in the given interval.\n     * <p>\n     * Requires that the values of the function at the endpoints have opposite\n     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n     * the case.</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function \n     * @throws IllegalArgumentException if min is not less than max or the\n     * signs of the values of the function at the endpoints are not opposites\n     */\n    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 57f64a9..766d87e 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -135,31 +135,17 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign > 0) {\n+        if (sign >= 0) {\n             // check if either value is close to a zero\n-            if (Math.abs(yMin) <= functionValueAccuracy) {\n-                setResult(min, 0);\n-                ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n-            } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +\n                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-            }\n-        } else if (sign < 0){\n+        } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n-        } else {\n             // either min or max is a root\n-            if (yMin == 0.0) {\n-                ret = min;\n-            } else {\n-                ret = max;\n-            }\n         }\n \n         return ret;\n"}
{"identifier": "Closure-125", "buggy_code": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n", "fixed_code": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null && fnType.hasInstanceType()) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex de14c04..4e05325 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1658,7 +1658,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null && fnType.hasInstanceType()) {\n+      if (fnType != null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n"}
{"identifier": "JacksonDatabind-16", "buggy_code": "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous != null) && previous.equals(ann);\n    }\n", "fixed_code": "    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous == null) || !previous.equals(ann);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected final boolean _add(Annotation ann)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\nindex 513a83d90..f9cc5cb19 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n@@ -109,7 +109,7 @@ public final class AnnotationMap implements Annotations\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous == null) || !previous.equals(ann);\n+        return (previous != null) && previous.equals(ann);\n     }\n }\n \n"}
{"identifier": "Chart-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/data/DefaultKeyedValues.java b/source/org/jfree/data/DefaultKeyedValues.java\nindex 5569198..707eb0a 100644\n--- a/source/org/jfree/data/DefaultKeyedValues.java\n+++ b/source/org/jfree/data/DefaultKeyedValues.java\n@@ -315,7 +315,9 @@ public class DefaultKeyedValues implements KeyedValues,\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n+        if (index < this.keys.size()) {\n         rebuildIndex();\n+        }\n     }\n \n     /**\n@@ -330,8 +332,7 @@ public class DefaultKeyedValues implements KeyedValues,\n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n-            throw new UnknownKeyException(\"The key (\" + key \n-                    + \") is not recognised.\");\n+\t\t\treturn;\n         }\n         removeValue(index);\n     }\ndiff --git a/source/org/jfree/data/DefaultKeyedValues2D.java b/source/org/jfree/data/DefaultKeyedValues2D.java\nindex cb81694..798d5d0 100644\n--- a/source/org/jfree/data/DefaultKeyedValues2D.java\n+++ b/source/org/jfree/data/DefaultKeyedValues2D.java\n@@ -452,19 +452,10 @@ public class DefaultKeyedValues2D implements KeyedValues2D,\n      * @see #removeRow(Comparable)\n      */\n     public void removeColumn(Comparable columnKey) {\n-    \tif (columnKey == null) {\n-    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\n-    \t}\n-    \tif (!this.columnKeys.contains(columnKey)) {\n-    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\n-    \t}\n         Iterator iterator = this.rows.iterator();\n         while (iterator.hasNext()) {\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n-            int index = rowData.getIndex(columnKey);\n-            if (index >= 0) {\n                 rowData.removeValue(columnKey);\n-            }\n         }\n         this.columnKeys.remove(columnKey);\n     }\n"}
{"identifier": "Jsoup-81", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex 3aaa0ed..0d52d38 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -2,7 +2,6 @@ package org.jsoup.helper;\n \n import org.jsoup.UncheckedIOException;\n import org.jsoup.internal.ConstrainableInputStream;\n-import org.jsoup.nodes.Comment;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n@@ -134,11 +133,6 @@ public final class DataUtil {\n                 XmlDeclaration decl = null;\n                 if (first instanceof XmlDeclaration)\n                     decl = (XmlDeclaration) first;\n-                else if (first instanceof Comment) {\n-                    Comment comment = (Comment) first;\n-                    if (comment.isXmlDeclaration())\n-                        decl = comment.asXmlDeclaration();\n-                }\n                 if (decl != null) {\n                     if (decl.name().equalsIgnoreCase(\"xml\"))\n                         foundCharset = decl.attr(\"encoding\");\n"}
{"identifier": "Closure-49", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\nindex 0fcb778..627271f 100644\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n@@ -88,6 +88,14 @@ class MakeDeclaredNamesUnique\n       renamer = nameStack.peek().forChildScope();\n     }\n \n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+        String name = c.getString();\n+        renamer.addDeclaredName(name);\n+      }\n+      Node functionBody = declarationRoot.getLastChild();\n+      findDeclaredNames(functionBody, null, renamer);\n+    }  else \n     if (declarationRoot.getType() != Token.FUNCTION) {\n       // Add the block declarations\n       findDeclaredNames(declarationRoot, null, renamer);\n@@ -119,22 +127,11 @@ class MakeDeclaredNamesUnique\n             renamer.addDeclaredName(name);\n           }\n \n-          nameStack.push(renamer);\n-        }\n-        break;\n \n-      case Token.LP: {\n-          Renamer renamer = nameStack.peek().forChildScope();\n \n           // Add the function parameters\n-          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n-          }\n \n           // Add the function body declarations\n-          Node functionBody = n.getNext();\n-          findDeclaredNames(functionBody, null, renamer);\n \n           nameStack.push(renamer);\n         }\n@@ -173,16 +170,13 @@ class MakeDeclaredNamesUnique\n \n       case Token.FUNCTION:\n         // Remove the function body scope\n-        nameStack.pop();\n         // Remove function recursive name (if any).\n         nameStack.pop();\n         break;\n \n-      case Token.LP:\n         // Note: The parameters and function body variables live in the\n         // same scope, we introduce the scope when in the \"shouldTraverse\"\n         // visit of LP, but remove it when when we exit the function above.\n-        break;\n \n       case Token.CATCH:\n         // Remove catch except name from the stack of names.\n"}
{"identifier": "JacksonDatabind-19", "buggy_code": "    private JavaType _mapType(Class<?> rawClass)\n    {\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n", "fixed_code": "    private JavaType _mapType(Class<?> rawClass)\n    {\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]\n        if (rawClass == Properties.class) {\n            return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING);\n        }\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate JavaType _mapType(Class<?> rawClass)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\nindex 4fa88cd22..8ebffc886 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n@@ -1018,9 +1018,6 @@ public final class TypeFactory\n     private JavaType _mapType(Class<?> rawClass)\n     {\n         // 28-May-2015, tatu: Properties are special, as per [databind#810]\n-        if (rawClass == Properties.class) {\n-            return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING);\n-        }\n         JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n         // ok to have no types (\"raw\")\n         if (typeParams == null) {\n"}
{"identifier": "JacksonCore-8", "buggy_code": "    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n", "fixed_code": "    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic char[] getTextBuffer()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex c67f3257..e6f1cbc5 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -304,7 +304,7 @@ public final class TextBuffer\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n+        if (!_hasSegments)  return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n"}
{"identifier": "Compress-34", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\nindex e325b564..89816fd5 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java\n@@ -55,7 +55,6 @@ import static org.apache.commons.compress.archivers.zip.ZipUtil.unsignedIntToSig\n  */\n public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable {\n     private static final ZipShort HEADER_ID = new ZipShort(0x7875);\n-    private static final ZipShort ZERO = new ZipShort(0);\n     private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\n     private static final long serialVersionUID = 1L;\n \n@@ -144,7 +143,7 @@ public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable {\n      * @return a <code>ZipShort</code> for the length of the data of this extra field\n      */\n     public ZipShort getCentralDirectoryLength() {\n-        return ZERO;\n+        return getLocalFileDataLength();\n     }\n \n     /**\n"}
{"identifier": "Jsoup-91", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/UncheckedIOException.java b/src/main/java/org/jsoup/UncheckedIOException.java\nindex e7a9cc3..4cab9f4 100644\n--- a/src/main/java/org/jsoup/UncheckedIOException.java\n+++ b/src/main/java/org/jsoup/UncheckedIOException.java\n@@ -7,9 +7,6 @@ public class UncheckedIOException extends RuntimeException {\n         super(cause);\n     }\n \n-    public UncheckedIOException(String message) {\n-        super(new IOException(message));\n-    }\n \n     public IOException ioException() {\n         return (IOException) getCause();\ndiff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex 7f163dd..187f9e9 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -34,9 +34,6 @@ public final class CharacterReader {\n         charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n         bufferUp();\n \n-        if (isBinary()) {\n-            throw new UncheckedIOException(\"Input is binary and unsupported\");\n-        }\n     }\n \n     public CharacterReader(Reader input) {\n@@ -452,22 +449,13 @@ public final class CharacterReader {\n         return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n     }\n \n-    private static final int numNullsConsideredBinary = 10; // conservative\n \n     /**\n      *  Heuristic to determine if the current buffer looks like binary content. Reader will already hopefully be\n      *  decoded correctly, so a bunch of NULLs indicates a binary file\n      */\n-    boolean isBinary() {\n-        int nullsSeen = 0;\n \n-        for (int i = bufPos; i < bufLength; i++) {\n-            if (charBuf[i] == '\\0')\n-                nullsSeen++;\n-        }\n \n-        return nullsSeen >= numNullsConsideredBinary;\n-    }\n \n     @Override\n     public String toString() {\n"}
{"identifier": "JacksonDatabind-102", "buggy_code": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // Note! Should not skip if `property` null since that'd skip check\n        // for config overrides, in case of root value\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n            serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n", "fixed_code": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // Note! Should not skip if `property` null since that'd skip check\n        // for config overrides, in case of root value\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n            serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\nindex 572d23eb6..492cd98e8 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n@@ -64,6 +64,9 @@ public abstract class DateTimeSerializerBase<T>\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n+        if (property == null) {\n+            return this;\n+        }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n"}
{"identifier": "Cli-19", "buggy_code": "    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n            tokens.add(token);\n        }\n    }\n", "fixed_code": "    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n        tokens.add(token);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>If an\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex fe01ceb..08a9280 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -229,13 +229,13 @@ public class PosixParser extends Parser {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n+            tokens.add(token);\n         }\n         else if (stopAtNonOption)\n         {\n             eatTheRest = true;\n+            tokens.add(token);\n         }\n-\n-        tokens.add(token);\n     }\n \n     /**\n"}
{"identifier": "Cli-26", "buggy_code": "    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n            // create the option\n        Option option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n\n        // return the Option instance\n        return option;\n    }\n", "fixed_code": "    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/OptionBuilder.java b/src/java/org/apache/commons/cli/OptionBuilder.java\nindex 60b4967..4d21b8b 100644\n--- a/src/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/OptionBuilder.java\n@@ -345,10 +345,8 @@ public final class OptionBuilder\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n-        Option option = null;\n-        try {\n             // create the option\n-            option = new Option(opt, description);\n+        Option option = new Option(opt, description);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n@@ -358,10 +356,8 @@ public final class OptionBuilder\n             option.setType(type);\n             option.setValueSeparator(valuesep);\n             option.setArgName(argName);\n-        } finally {\n             // reset the OptionBuilder properties\n             OptionBuilder.reset();\n-        }\n \n         // return the Option instance\n         return option;\n"}
{"identifier": "JacksonCore-1", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java b/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\nindex eb463b99..01c18d94 100644\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n@@ -292,11 +292,7 @@ public final class NumberInput\n \n     public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n     {\n-        try {\n             return new BigDecimal(numStr);\n-        } catch (NumberFormatException e) {\n-            throw _badBigDecimal(numStr);\n-        }\n     }\n \n     public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {\n@@ -306,14 +302,7 @@ public final class NumberInput\n     public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n             throws NumberFormatException\n     {\n-        try {\n             return new BigDecimal(buffer, offset, len);\n-        } catch (NumberFormatException e) {\n-            throw _badBigDecimal(new String(buffer, offset, len));\n-        }\n     }\n \n-    private static NumberFormatException _badBigDecimal(String str) {\n-        return new NumberFormatException(\"Value \\\"\"+str+\"\\\" can not be represented as BigDecimal\");\n-    }\n }\ndiff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex bab80e0a..a05410d6 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -387,11 +387,11 @@ public final class TextBuffer\n             return NumberInput.parseBigDecimal(_resultArray);\n         }\n         // Or a shared buffer?\n-        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n+        if (_inputStart >= 0) {\n             return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n         }\n         // Or if not, just a single buffer (the usual case)\n-        if ((_segmentSize == 0) && (_currentSegment != null)) {\n+        if (_segmentSize == 0) {\n             return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n         }\n         // If not, let's just get it aggregated...\n"}
{"identifier": "JacksonDatabind-7", "buggy_code": "    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n            copyCurrentStructure(jp);\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        return this;\n    }\n", "fixed_code": "    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n            copyCurrentStructure(jp);\n            return this;\n        }\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t;\n        writeStartObject();\n        do {\n            copyCurrentStructure(jp);\n        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n        if (t != JsonToken.END_OBJECT) {\n            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n        }\n        writeEndObject();\n        return this;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\nindex 58d3e086f..21a6b287b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n@@ -402,23 +402,11 @@ public class TokenBuffer\n      */\n     public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n-        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n             copyCurrentStructure(jp);\n-            return this;\n-        }\n         /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n          *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n          *    to assume one did exist.\n          */\n-        JsonToken t;\n-        writeStartObject();\n-        do {\n-            copyCurrentStructure(jp);\n-        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n-        if (t != JsonToken.END_OBJECT) {\n-            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n-        }\n-        writeEndObject();\n         return this;\n     }\n     \n"}
{"identifier": "Closure-112", "buggy_code": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types\n    Map<TemplateType, JSType> inferred =\n        inferTemplateTypesFromParameters(fnType, n);\n\n\n    // Replace all template types. If we couldn't find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferred);\n    Node callTarget = n.getFirstChild();\n\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    return replacer.madeChanges;\n  }\n", "fixed_code": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types\n    Map<TemplateType, JSType> inferred = Maps.filterKeys(\n        inferTemplateTypesFromParameters(fnType, n),\n        new Predicate<TemplateType>() {\n\n          @Override\n          public boolean apply(TemplateType key) {\n            return keys.contains(key);\n          }}\n        );\n\n    // Replace all template types. If we couldn't find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferred);\n    Node callTarget = n.getFirstChild();\n\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    return replacer.madeChanges;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 4b30d57..4c24e2f 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1189,15 +1189,9 @@ class TypeInference\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = Maps.filterKeys(\n-        inferTemplateTypesFromParameters(fnType, n),\n-        new Predicate<TemplateType>() {\n-\n-          @Override\n-          public boolean apply(TemplateType key) {\n-            return keys.contains(key);\n-          }}\n-        );\n+    Map<TemplateType, JSType> inferred = \n+        inferTemplateTypesFromParameters(fnType, n);\n+\n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n"}
{"identifier": "Jsoup-83", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex 6993524..80dffcd 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -251,7 +251,7 @@ public final class CharacterReader {\n \n         while (bufPos < remaining) {\n             final char c = val[bufPos];\n-            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n+            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                 break;\n             bufPos++;\n         }\ndiff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex 95b326c..4980f15 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -158,9 +158,6 @@ enum TokeniserState {\n                 case '/':\n                     t.transition(SelfClosingStartTag);\n                     break;\n-                case '<': // NOTE: out of spec, but clear author intent\n-                    t.error(this);\n-                    r.unconsume();\n                     // intended fall through to next >\n                 case '>':\n                     t.emitTagPending();\n@@ -564,9 +561,6 @@ enum TokeniserState {\n                 case '/':\n                     t.transition(SelfClosingStartTag);\n                     break;\n-                case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name)\n-                    t.error(this);\n-                    r.unconsume();\n                     // intended fall through as if >\n                 case '>':\n                     t.emitTagPending();\n@@ -584,6 +578,7 @@ enum TokeniserState {\n                     break;\n                 case '\"':\n                 case '\\'':\n+                case '<':\n                 case '=':\n                     t.error(this);\n                     t.tagPending.newAttribute();\n"}
{"identifier": "Lang-40", "buggy_code": "    /**\n     * <p>Checks if String contains a search String irrespective of case,\n     * handling <code>null</code>. Case-insensitivity is defined as by\n     * {@link String#equalsIgnoreCase(String)}.\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *) = false\n     * StringUtils.contains(*, null) = false\n     * StringUtils.contains(\"\", \"\") = true\n     * StringUtils.contains(\"abc\", \"\") = true\n     * StringUtils.contains(\"abc\", \"a\") = true\n     * StringUtils.contains(\"abc\", \"z\") = false\n     * StringUtils.contains(\"abc\", \"A\") = true\n     * StringUtils.contains(\"abc\", \"Z\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return true if the String contains the search String irrespective of\n     * case or false if not or <code>null</code> string input\n     */\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        return contains(str.toUpperCase(), searchStr.toUpperCase());\n    }\n", "fixed_code": "    /**\n     * <p>Checks if String contains a search String irrespective of case,\n     * handling <code>null</code>. Case-insensitivity is defined as by\n     * {@link String#equalsIgnoreCase(String)}.\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *) = false\n     * StringUtils.contains(*, null) = false\n     * StringUtils.contains(\"\", \"\") = true\n     * StringUtils.contains(\"abc\", \"\") = true\n     * StringUtils.contains(\"abc\", \"a\") = true\n     * StringUtils.contains(\"abc\", \"z\") = false\n     * StringUtils.contains(\"abc\", \"A\") = true\n     * StringUtils.contains(\"abc\", \"Z\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return true if the String contains the search String irrespective of\n     * case or false if not or <code>null</code> string input\n     */\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Checks if String contains a search String irrespective of case,\n     * handling <code>null</code>. Case-insensitivity is defined as by\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/StringUtils.java b/src/java/org/apache/commons/lang/StringUtils.java\nindex 8351b3e..72b4a49 100644\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n@@ -1045,14 +1045,7 @@ public class StringUtils {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        int len = searchStr.length();\n-        int max = str.length() - len;\n-        for (int i = 0; i <= max; i++) {\n-            if (str.regionMatches(true, i, searchStr, 0, len)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        return contains(str.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n"}
{"identifier": "JxPath-7", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\nindex 4d8c2c4..3a053d4 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n@@ -28,8 +28,10 @@ public class CoreOperationGreaterThan extends CoreOperationRelationalExpression\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    protected boolean evaluateCompare(int compare) {\n-        return compare > 0;\n+    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n+        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n+        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n+        return l > r ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     public String getSymbol() {\ndiff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\nindex c3d5720..b9f156c 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n@@ -29,8 +29,10 @@ public class CoreOperationGreaterThanOrEqual extends\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    protected boolean evaluateCompare(int compare) {\n-        return compare >= 0;\n+    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n+        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n+        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n+        return l >= r ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     public String getSymbol() {\ndiff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\nindex 4c0d9ce..374f772 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n@@ -28,8 +28,10 @@ public class CoreOperationLessThan extends CoreOperationRelationalExpression {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    protected boolean evaluateCompare(int compare) {\n-        return compare < 0;\n+    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n+        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n+        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n+        return l < r ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     public String getSymbol() {\ndiff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\nindex 7940ecb..db562d8 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n@@ -29,8 +29,10 @@ public class CoreOperationLessThanOrEqual extends\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    protected boolean evaluateCompare(int compare) {\n-        return compare <= 0;\n+    public Object computeValue(org.apache.commons.jxpath.ri.EvalContext context) {\n+        double l = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[0].computeValue(context));\n+        double r = org.apache.commons.jxpath.ri.InfoSetUtil.doubleValue(args[1].computeValue(context));\n+        return l <= r ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     public String getSymbol() {\ndiff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\nindex bbb070d..4893dd6 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n@@ -16,14 +16,7 @@\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n \n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.InfoSetUtil;\n-import org.apache.commons.jxpath.ri.axes.InitialContext;\n-import org.apache.commons.jxpath.ri.axes.SelfContext;\n \n /**\n  * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n@@ -37,10 +30,6 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n         super(args);\n     }\n \n-    public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1]\n-                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n-    }\n \n     protected final int getPrecedence() {\n         return 3;\n@@ -50,67 +39,11 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n         return false;\n     }\n \n-    protected abstract boolean evaluateCompare(int compare);\n \n-    private boolean compute(Object left, Object right) {\n-        left = reduce(left);\n-        right = reduce(right);\n \n-        if (left instanceof InitialContext) {\n-            ((InitialContext) left).reset();\n-        }\n-        if (right instanceof InitialContext) {\n-            ((InitialContext) right).reset();\n-        }\n-        if (left instanceof Iterator && right instanceof Iterator) {\n-            return findMatch((Iterator) left, (Iterator) right);\n-        }\n-        if (left instanceof Iterator) {\n-            return containsMatch((Iterator) left, right);\n-        }\n-        if (right instanceof Iterator) {\n-            return containsMatch((Iterator) right, left);\n-        }\n-        return evaluateCompare(compare(left, right));\n-    }\n \n-    private Object reduce(Object o) {\n-        if (o instanceof SelfContext) {\n-            o = ((EvalContext) o).getSingleNodePointer();\n-        }\n-        if (o instanceof Collection) {\n-            o = ((Collection) o).iterator();\n-        }\n-        return o;\n-    }\n \n-    private boolean containsMatch(Iterator it, Object value) {\n-        while (it.hasNext()) {\n-            Object element = it.next();\n-            if (evaluateCompare(compare(element, value))) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n \n-    private boolean findMatch(Iterator lit, Iterator rit) {\n-        HashSet left = new HashSet();\n-        while (lit.hasNext()) {\n-            left.add(lit.next());\n-        }\n-        while (rit.hasNext()) {\n-            if (containsMatch(left.iterator(), rit.next())) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n \n-    private int compare(Object l, Object r) {\n-        double ld = InfoSetUtil.doubleValue(l);\n-        double rd = InfoSetUtil.doubleValue(r);\n-        return ld == rd ? 0 : ld < rd ? -1 : 1;\n-    }\n \n }\n"}
{"identifier": "Math-83", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex b387767..0cf01af 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -289,7 +289,7 @@ class SimplexTableau implements Serializable {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n-        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n+        int start = getNumObjectiveFunctions();\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n@@ -338,11 +338,11 @@ class SimplexTableau implements Serializable {\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n+      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n-          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n+          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value \n               // then we choose the first and set the rest equal to 0\n"}
{"identifier": "Time-23", "buggy_code": "    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n", "fixed_code": "    /**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Converts an old style id to a new style id.\n     * \n     * @param id  the old style id\n     * @return the new style id, null if not found\n     */\n    private static synchronized String getConvertedId(String id)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad0..5d89e34 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -561,11 +561,6 @@ public abstract class DateTimeZone implements Serializable {\n             // Backwards compatibility with TimeZone.\n             map = new HashMap<String, String>();\n             map.put(\"GMT\", \"UTC\");\n-            map.put(\"WET\", \"WET\");\n-            map.put(\"CET\", \"CET\");\n-            map.put(\"MET\", \"CET\");\n-            map.put(\"ECT\", \"CET\");\n-            map.put(\"EET\", \"EET\");\n             map.put(\"MIT\", \"Pacific/Apia\");\n             map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n             map.put(\"AST\", \"America/Anchorage\");\n@@ -574,19 +569,23 @@ public abstract class DateTimeZone implements Serializable {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n+            map.put(\"IET\", \"America/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n+            map.put(\"AGT\", \"America/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n+            map.put(\"WET\", \"Europe/London\");\n+            map.put(\"ECT\", \"Europe/Paris\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n+            map.put(\"EET\", \"Europe/Bucharest\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n+            map.put(\"MET\", \"Asia/Tehran\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Kolkata\");\n+            map.put(\"IST\", \"Asia/Calcutta\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n+            map.put(\"VST\", \"Asia/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n"}
{"identifier": "JacksonDatabind-65", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\nindex 5e353d388..b43c09215 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n@@ -125,8 +125,7 @@ public class StdKeyDeserializer extends KeyDeserializer\n                 return result;\n             }\n         } catch (Exception re) {\n-            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n-                    re.getClass().getName(), re.getMessage());\n+            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n         }\n         if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n             return null;\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\nindex 7f8e76d04..27a115fc3 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n@@ -522,7 +522,7 @@ public class BasicBeanDescription extends BeanDescription\n         // So, of all single-arg static methods:\n         for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n             // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-            if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n+            if (isFactoryMethod(am)) {\n                 // And must take one of expected arg types (or supertype)\n                 Class<?> actualArgType = am.getRawParameterType(0);\n                 for (Class<?> expArgType : expArgTypes) {\n@@ -555,9 +555,7 @@ public class BasicBeanDescription extends BeanDescription\n         final String name = am.getName();\n         // 24-Oct-2016, tatu: As per [databind#1429] must ensure takes exactly one arg\n         if (\"valueOf\".equals(name)) {\n-            if (am.getParameterCount() == 1) {\n                 return true;\n-            }\n         }\n         // [databind#208] Also accept \"fromString()\", if takes String or CharSequence\n         if (\"fromString\".equals(name)) {\n"}
{"identifier": "Math-86", "buggy_code": "    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n", "fixed_code": "    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\nindex 67e372f..acd9222 100644\n--- a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n@@ -111,6 +111,9 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n \n             final double[] lI = lTData[i];\n \n+            if (lTData[i][i] < absolutePositivityThreshold) {\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n             // check off-diagonal elements (and reset them to 0)\n             for (int j = i + 1; j < order; ++j) {\n                 final double[] lJ = lTData[j];\n@@ -131,9 +134,6 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n             final double[] ltI = lTData[i];\n \n             // check diagonal element\n-            if (ltI[i] < absolutePositivityThreshold) {\n-                throw new NotPositiveDefiniteMatrixException();\n-            }\n \n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];\n"}
{"identifier": "Lang-1", "buggy_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n    * <code>BigDecimal</code>.</p>\n    * \n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigDecimal as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals = 0; // Check required precision (LANG-693)\n        if (decPos > -1) { // there is a decimal point\n\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }\n", "fixed_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n    * <code>BigDecimal</code>.</p>\n    * \n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigDecimal as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen += pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            char firstSigDigit = 0; // strip leading zeroes\n            for(int i = pfxLen; i < str.length(); i++) {\n                firstSigDigit = str.charAt(i);\n                if (firstSigDigit == '0') { // count leading zeroes\n                    pfxLen++;\n                } else {\n                    break;\n                }\n            }\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n        // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n        // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n        int numDecimals = 0; // Check required precision (LANG-693)\n        if (decPos > -1) { // there is a decimal point\n\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) { // prevents double exponent causing IOOBE\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            final String numeric = str.substring(0, str.length() - 1);\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        }\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) { // no decimal point and no exponent\n            //Must be an Integer, Long, Biginteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n        }\n\n        //Must be a Float, Double, BigDecimal\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        try {\n            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        return createBigDecimal(str);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 70b8d64..1e6ccdc 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -464,20 +464,11 @@ public class NumberUtils {\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n-            char firstSigDigit = 0; // strip leading zeroes\n-            for(int i = pfxLen; i < str.length(); i++) {\n-                firstSigDigit = str.charAt(i);\n-                if (firstSigDigit == '0') { // count leading zeroes\n-                    pfxLen++;\n-                } else {\n-                    break;\n-                }\n-            }\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n+            if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n-            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n+            if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n"}
{"identifier": "Compress-16", "buggy_code": "    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n                try {\n                    TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    // COMPRESS-191 - verify the header checksum\n                    tais.getNextEntry();\n                        return new TarArchiveInputStream(in);\n                } catch (Exception e) { // NOPMD\n                    // can generate IllegalArgumentException as well\n                    // as IOException\n                    // autodetection, simply not a TAR\n                    // ignored\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n", "fixed_code": "    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = in.read(signature);\n            in.reset();\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = in.read(tarheader);\n            in.reset();\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n                try {\n                    TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                    // COMPRESS-191 - verify the header checksum\n                    if (tais.getNextTarEntry().isCheckSumOK()) {\n                        return new TarArchiveInputStream(in);\n                    }\n                } catch (Exception e) { // NOPMD\n                    // can generate IllegalArgumentException as well\n                    // as IOException\n                    // autodetection, simply not a TAR\n                    // ignored\n                }\n            }\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     * \n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\nindex 90820df8..37dfbe03 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n@@ -241,9 +241,8 @@ public class ArchiveStreamFactory {\n                 try {\n                     TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                     // COMPRESS-191 - verify the header checksum\n-                    if (tais.getNextTarEntry().isCheckSumOK()) {\n+                    tais.getNextEntry();\n                         return new TarArchiveInputStream(in);\n-                    }\n                 } catch (Exception e) { // NOPMD\n                     // can generate IllegalArgumentException as well\n                     // as IOException\n"}
{"identifier": "Math-100", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\nindex 8e5fe1a..ea5083d 100644\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n@@ -163,7 +163,7 @@ public abstract class AbstractEstimator implements Estimator {\n \n         // compute transpose(J).J, avoiding building big intermediate matrices\n         final int rows = problem.getMeasurements().length;\n-        final int cols = problem.getUnboundParameters().length;\n+        final int cols = problem.getAllParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {\n@@ -199,12 +199,12 @@ public abstract class AbstractEstimator implements Estimator {\n     public double[] guessParametersErrors(EstimationProblem problem)\n       throws EstimationException {\n         int m = problem.getMeasurements().length;\n-        int p = problem.getUnboundParameters().length;\n+        int p = problem.getAllParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n                                           new Object[] { new Integer(m), new Integer(p)});\n         }\n-        double[] errors = new double[problem.getUnboundParameters().length];\n+        double[] errors = new double[problem.getAllParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n         double[][] covar = getCovariances(problem);\n         for (int i = 0; i < errors.length; ++i) {\n"}
{"identifier": "JacksonDatabind-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\nindex be9bf4491..d4a0b0562 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n@@ -56,7 +56,6 @@ public final class StringArrayDeserializer\n         int ix = 0;\n         JsonToken t;\n \n-        try {\n             while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                 // Ok: no need to convert Strings, but must recognize nulls\n                 String value;\n@@ -73,10 +72,7 @@ public final class StringArrayDeserializer\n                 }\n                 chunk[ix++] = value;\n             }\n-        } catch (Exception e) {\n             // note: pass String.class, not String[].class, as we need element type for error info\n-            throw JsonMappingException.wrapWithPath(e, String.class, ix);\n-        }\n         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n         ctxt.returnObjectBuffer(buffer);\n         return result;\n@@ -94,7 +90,6 @@ public final class StringArrayDeserializer\n         int ix = 0;\n         JsonToken t;\n \n-        try {\n             while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n                 // Ok: no need to convert Strings, but must recognize nulls\n                 String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n@@ -104,10 +99,7 @@ public final class StringArrayDeserializer\n                 }\n                 chunk[ix++] = value;\n             }\n-        } catch (Exception e) {\n             // note: pass String.class, not String[].class, as we need element type for error info\n-            throw JsonMappingException.wrapWithPath(e, String.class, ix);\n-        }\n         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n         ctxt.returnObjectBuffer(buffer);\n         return result;\n"}
{"identifier": "JacksonDatabind-53", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\nindex 6752f2022..b888ab97c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n@@ -299,11 +299,8 @@ name, i, t.getRawClass()));\n      *\n      * @since 2.8\n      */\n-    public Object asKey(Class<?> rawBase) {\n         // safe to pass _types array without copy since it is not exposed via\n         // any access, nor modified by this class\n-        return new AsKey(rawBase, _types, _hashCode);\n-    }\n \n     /*\n     /**********************************************************************\n@@ -428,46 +425,6 @@ name, i, t.getRawClass()));\n      *\n      * @since 2.8\n      */\n-    final static class AsKey {\n-        private final Class<?> _raw;\n-        private final JavaType[] _params;\n-        private final int _hash;\n-\n-        public AsKey(Class<?> raw, JavaType[] params, int hash) {\n-            _raw = raw ;\n-            _params = params;\n-            _hash = hash;\n-        }\n \n-        @Override\n-        public int hashCode() { return _hash; }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o == null) return false;\n-            if (o.getClass() != getClass()) return false;\n-            AsKey other = (AsKey) o;\n-\n-            if ((_hash == other._hash) && (_raw == other._raw)) {\n-                final JavaType[] otherParams = other._params;\n-                final int len = _params.length;\n-\n-                if (len == otherParams.length) {\n-                    for (int i = 0; i < len; ++i) {\n-                        if (!_params[i].equals(otherParams[i])) {\n-                            return false;\n-                        }\n-                    }\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n \n-        @Override\n-        public String toString() {\n-            return _raw.getName()+\"<>\";\n-        }\n-    }\n }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\nindex a27097e4a..098cd2e35 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n@@ -114,7 +114,7 @@ public final class TypeFactory\n      * actual generic types), we will use small cache to avoid repetitive\n      * resolution of core types\n      */\n-    protected final LRUMap<Object,JavaType> _typeCache = new LRUMap<Object,JavaType>(16, 100);\n+    protected final LRUMap<Class<?>, JavaType> _typeCache = new LRUMap<Class<?>, JavaType>(16, 100);\n \n     /*\n     /**********************************************************\n@@ -382,15 +382,24 @@ public final class TypeFactory\n             //  for a case where this code does get invoked: not ideal\n             // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but\n             //  not certain it would reliably work... but let's hope for best for now\n-            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n             if (baseType.isInterface()) {\n-                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });\n+                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });\n             } else {\n-                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);\n+                newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);\n             }\n             // Only SimpleType returns null, but if so just resolve regularly\n             if (newType == null) {\n-                newType = _fromClass(null, subclass, tb);\n+                TypeBindings tb = null;\n+                if (baseType.containedTypeCount() == typeParamCount) {\n+                    if (typeParamCount == 1) {\n+                        tb = TypeBindings.create(subclass, baseType.containedType(0));\n+                    } else if (typeParamCount == 2) {\n+                        tb = TypeBindings.create(subclass, baseType.containedType(0),\n+                                baseType.containedType(1));\n+                    }\n+                }\n+                newType = _fromClass(null, subclass,\n+                        (tb == null) ? TypeBindings.emptyBindings() : tb);\n             }\n         } while (false);\n \n@@ -444,28 +453,9 @@ public final class TypeFactory\n         */\n     }\n \n-    private TypeBindings _bindingsForSubtype(JavaType baseType, int typeParamCount, Class<?> subclass)\n-    {\n         // But otherwise gets bit tricky, as we need to partially resolve the type hierarchy\n         // (hopefully passing null Class for root is ok)\n-        int baseCount = baseType.containedTypeCount();\n-        if (baseCount == typeParamCount) {\n-            if (typeParamCount == 1) {\n-                return TypeBindings.create(subclass, baseType.containedType(0));\n-            }\n-            if (typeParamCount == 2) {\n-                return TypeBindings.create(subclass, baseType.containedType(0),\n-                        baseType.containedType(1));\n-            }\n-            List<JavaType> types = new ArrayList<JavaType>(baseCount);\n-            for (int i = 0; i < baseCount; ++i) {\n-                types.add(baseType.containedType(i));\n-            }\n-            return TypeBindings.create(subclass, types);\n-        }\n         // Otherwise, two choices: match N first, or empty. Do latter, for now\n-        return TypeBindings.emptyBindings();\n-    }\n \n     /**\n      * Method similar to {@link #constructSpecializedType}, but that creates a\n@@ -1167,16 +1157,12 @@ public final class TypeFactory\n             return result;\n         }\n         // Barring that, we may have recently constructed an instance\n-        final Object key;\n-        if ((bindings == null) || bindings.isEmpty()) {\n-            key = rawType;\n-            result = _typeCache.get(key); // ok, cache object is synced\n-        } else {\n-            key = bindings.asKey(rawType);\n-        }\n-        result = _typeCache.get(key); // ok, cache object is synced\n+        boolean cachable = (bindings == null) || bindings.isEmpty();\n+        if (cachable) {\n+            result = _typeCache.get(rawType);\n         if (result != null) {\n             return result;\n+            }\n         }\n \n         // 15-Oct-2015, tatu: recursive reference?\n@@ -1236,7 +1222,9 @@ public final class TypeFactory\n             }\n         }\n         context.resolveSelfReferences(result);\n-        _typeCache.putIfAbsent(key, result); // cache object syncs\n+        if (cachable) {\n+            _typeCache.putIfAbsent(rawType, result);\n+        }\n         return result;\n     }\n \n"}
{"identifier": "Lang-16", "buggy_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 5b7891a..882358f 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -455,7 +455,7 @@ public class NumberUtils {\n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n"}
{"identifier": "JxPath-5", "buggy_code": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n", "fixed_code": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            return 0;\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\nindex 8ba1c04..6ff8d5f 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n@@ -662,7 +662,9 @@ public abstract class NodePointer implements Pointer {\n         }\n \n         if (depth1 == 1) {\n-            return 0;\n+            throw new JXPathException(\n+                    \"Cannot compare pointers that do not belong to the same tree: '\"\n+                            + p1 + \"' and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n"}
{"identifier": "Closure-26", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\nindex fa01cd9..1744a58 100644\n--- a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n@@ -125,7 +125,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n       AbstractPostOrderCallback {\n \n     private int scriptNodeCount = 0;\n-    private Set<String> modulesWithExports = Sets.newHashSet();\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n@@ -205,9 +204,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n-      if (!modulesWithExports.contains(moduleName)) {\n-        return;\n-      }\n \n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));\n@@ -229,7 +225,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n       Node exports = prop.getChildAtIndex(1);\n       exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n       exports.setString(\"module$exports\");\n-      modulesWithExports.add(moduleName);\n     }\n \n     /**\n"}
{"identifier": "Cli-21", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/cli2/WriteableCommandLine.java b/src/java/org/apache/commons/cli2/WriteableCommandLine.java\nindex 8bd6752..d6aaf49 100644\n--- a/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n+++ b/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n@@ -99,7 +99,6 @@ public interface WriteableCommandLine extends CommandLine {\n      *\n      * @return the current option\n      */\n-    Option getCurrentOption();\n \n     /**\n      * Sets the current option. This method is called by concrete option\n@@ -108,5 +107,4 @@ public interface WriteableCommandLine extends CommandLine {\n      *\n      * @param currentOption the new current option\n      */\n-    void setCurrentOption(Option currentOption);\n }\ndiff --git a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\nindex 8c5e29b..88d3286 100644\n--- a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n@@ -48,8 +48,6 @@ public class WriteableCommandLineImpl\n     private final Map defaultSwitches = new HashMap();\n     private final List normalised;\n     private final Set prefixes;\n-    private Option currentOption;\n-    private String checkForOption;\n \n     /**\n      * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n@@ -62,16 +60,9 @@ public class WriteableCommandLineImpl\n                                     final List arguments) {\n         this.prefixes = rootOption.getPrefixes();\n         this.normalised = arguments;\n-        setCurrentOption(rootOption);\n     }\n \n-    public Option getCurrentOption() {\n-        return currentOption;\n-    }\n \n-    public void setCurrentOption(Option currentOption) {\n-        this.currentOption = currentOption;\n-    }\n \n     public void addOption(Option option) {\n         options.add(option);\n@@ -240,35 +231,18 @@ public class WriteableCommandLineImpl\n      */\n     public boolean looksLikeOption(final String trigger)\n     {\n-        if (checkForOption != null)\n-        {\n             // this is a reentrant call\n-            return !checkForOption.equals(trigger);\n-        }\n \n-        checkForOption = trigger;\n-        try\n-        {\n             for (final Iterator i = prefixes.iterator(); i.hasNext();)\n             {\n                 final String prefix = (String) i.next();\n \n                 if (trigger.startsWith(prefix))\n                 {\n-                    if (getCurrentOption().canProcess(this, trigger)\n-                            || getCurrentOption().findOption(trigger) != null)\n-                    {\n                         return true;\n-                    }\n                 }\n             }\n-\n             return false;\n-        }\n-        finally\n-        {\n-            checkForOption = null;\n-        }\n     }\n \n     public String toString() {\ndiff --git a/src/java/org/apache/commons/cli2/option/GroupImpl.java b/src/java/org/apache/commons/cli2/option/GroupImpl.java\nindex fc5a82d..75d87f7 100644\n--- a/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n@@ -510,13 +510,7 @@ public class GroupImpl\n      */\n     private boolean looksLikeOption(final WriteableCommandLine commandLine,\n             final String trigger) {\n-        Option oldOption = commandLine.getCurrentOption();\n-        try {\n-            commandLine.setCurrentOption(this);\n             return commandLine.looksLikeOption(trigger);\n-        } finally {\n-            commandLine.setCurrentOption(oldOption);\n-        }\n     }\n }\n \n"}
{"identifier": "Lang-34", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\nindex 26214ed..aa1f448 100644\n--- a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n@@ -145,7 +145,7 @@ public abstract class ToStringStyle implements Serializable {\n      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n-        return REGISTRY.get();\n+        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n     }\n \n     /**\n@@ -161,7 +161,7 @@ public abstract class ToStringStyle implements Serializable {\n      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n-        return m != null && m.containsKey(value);\n+        return m.containsKey(value);\n     }\n \n     /**\n"}
{"identifier": "Cli-32", "buggy_code": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n        return pos == text.length() ? -1 : pos;\n    }\n", "fixed_code": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/HelpFormatter.java b/src/main/java/org/apache/commons/cli/HelpFormatter.java\nindex 7d8a901..6b74e4e 100644\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n@@ -934,7 +934,11 @@ public class HelpFormatter\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        \n+        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n+               && (c != '\\n') && (c != '\\r'))\n+        {\n+            ++pos;\n+        }        \n         return pos == text.length() ? -1 : pos;\n     }\n \n"}
{"identifier": "Closure-52", "buggy_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0;\n  }\n", "fixed_code": "  static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return len > 0 && s.charAt(0) != '0';\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nstatic boolean isSimpleNumber(String s)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 535148c..ac6299d 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -742,7 +742,7 @@ class CodeGenerator {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+    return len > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n"}
{"identifier": "Closure-47", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\nindex 5ee9108..d67dc10 100644\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n@@ -486,8 +486,8 @@ public class SourceMapConsumerV3 implements SourceMapConsumer,\n       // Adjust the line/column here to be start at 1.\n       Builder x = OriginalMapping.newBuilder()\n         .setOriginalFile(sources[entry.getSourceFileId()])\n-        .setLineNumber(entry.getSourceLine() + 1)\n-        .setColumnPosition(entry.getSourceColumn() + 1);\n+        .setLineNumber(entry.getSourceLine())\n+        .setColumnPosition(entry.getSourceColumn());\n       if (entry.getNameId() != UNMAPPED) {\n         x.setIdentifier(names[entry.getNameId()]);\n       }\ndiff --git a/src/com/google/javascript/jscomp/SourceMap.java b/src/com/google/javascript/jscomp/SourceMap.java\nindex 7192408..835dfa4 100644\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n@@ -135,15 +135,10 @@ public class SourceMap {\n     // zero based.\n     // We don't change this for the v1 or v2 source maps but for\n     // v3 we make them both 0 based.\n-    int lineBaseOffset = 1;\n-    if (generator instanceof SourceMapGeneratorV1\n-        || generator instanceof SourceMapGeneratorV2) {\n-      lineBaseOffset = 0;\n-    }\n \n     generator.addMapping(\n         sourceFile, originalName,\n-        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),\n+        new FilePosition(node.getLineno(), node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }\n \n"}
{"identifier": "Jsoup-23", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex 4db4d79..e07f7de 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -115,25 +115,7 @@ class CharacterReader {\n         return input.substring(start, pos);\n     }\n \n-    String consumeLetterThenDigitSequence() {\n-        int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n-            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n-                pos++;\n-            else\n-                break;\n-        }\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n-            if (c >= '0' && c <= '9')\n-                pos++;\n-            else\n-                break;\n-        }\n \n-        return input.substring(start, pos);\n-    }\n \n     String consumeHexSequence() {\n         int start = pos;\ndiff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java\nindex d53a49b..d1e3ee6 100644\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n@@ -132,7 +132,7 @@ class Tokeniser {\n             }\n         } else { // named\n             // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n-            String nameRef = reader.consumeLetterThenDigitSequence();\n+            String nameRef = reader.consumeLetterSequence();\n             String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches\n             boolean looksLegit = reader.matches(';');\n             boolean found = false;\n"}
{"identifier": "Math-73", "buggy_code": "    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n", "fixed_code": "    /**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     *\n     * @param f function to solve.\n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */\n    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb427..8142b5e 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,10 +133,6 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-        }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n"}
{"identifier": "JacksonDatabind-15", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/JavaType.java b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\nindex 07b6ba968..c3d85c947 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n@@ -299,7 +299,6 @@ public abstract class JavaType\n      *\n      * @since 2.5\n      */\n-    public final boolean isJavaLangObject() { return _class == Object.class; }\n \n     /**\n      * Accessor for checking whether handlers for dealing with values of\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\nindex 14e6d9345..a65f9d24e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n@@ -160,7 +160,7 @@ public class BeanSerializerFactory\n             ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n         }\n         // [databind#731]: Should skip if nominally java.lang.Object\n-        if (ser == null && !delegateType.isJavaLangObject()) {\n+        if (ser == null) {\n             ser = _createSerializer2(prov, delegateType, beanDesc, true);\n         }\n         return new StdDelegatingSerializer(conv, delegateType, ser);\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\nindex 3e1164808..e69205ed6 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n@@ -367,8 +367,7 @@ public abstract class BeanSerializerBase\n                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                     // [databind#731]: Should skip if nominally java.lang.Object\n-                    JsonSerializer<?> ser = delegateType.isJavaLangObject() ? null\n-                            : provider.findValueSerializer(delegateType, prop);\n+                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n                     return new StdDelegatingSerializer(conv, delegateType, ser);\n                 }\n             }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\nindex 6c52b736e..3aeb4f306 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n@@ -118,17 +118,13 @@ public class StdDelegatingSerializer\n             /* 02-Apr-2015, tatu: For \"dynamic case\", where type is only specified as\n              *    java.lang.Object (or missing generic), [databind#731]\n              */\n-            if (!delegateType.isJavaLangObject()) {\n                 delSer = provider.findValueSerializer(delegateType);\n-            }\n         }\n         if (delSer instanceof ContextualSerializer) {\n             delSer = provider.handleSecondaryContextualization(delSer, property);\n         }\n-        if (delSer == _delegateSerializer && delegateType == _delegateType) {\n-            return this;\n-        }\n-        return withDelegate(_converter, delegateType, delSer);\n+        return (delSer == _delegateSerializer) ? this\n+                : withDelegate(_converter, delegateType, delSer);\n     }\n \n     /*\n@@ -162,11 +158,7 @@ public class StdDelegatingSerializer\n             return;\n         }\n         // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-        JsonSerializer<Object> ser = _delegateSerializer;\n-        if (ser == null) {\n-            ser = _findSerializer(delegateValue, provider);\n-        }\n-        ser.serialize(delegateValue, gen, provider);\n+        _delegateSerializer.serialize(delegateValue, gen, provider);\n     }\n \n     @Override\n@@ -177,11 +169,7 @@ public class StdDelegatingSerializer\n          *    let's give it a chance?\n          */\n         Object delegateValue = convertValue(value);\n-        JsonSerializer<Object> ser = _delegateSerializer;\n-        if (ser == null) {\n-            ser = _findSerializer(value, provider);\n-        }\n-        ser.serializeWithType(delegateValue, gen, provider, typeSer);\n+        _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n     }\n \n     @Override\n@@ -189,9 +177,6 @@ public class StdDelegatingSerializer\n     public boolean isEmpty(Object value)\n     {\n         Object delegateValue = convertValue(value);\n-        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n-            return (value == null);\n-        }\n         return _delegateSerializer.isEmpty(delegateValue);\n     }\n \n@@ -199,9 +184,6 @@ public class StdDelegatingSerializer\n     public boolean isEmpty(SerializerProvider prov, Object value)\n     {\n         Object delegateValue = convertValue(value);\n-        if (_delegateSerializer == null) { // best we can do for now, too costly to look up\n-            return (value == null);\n-        }\n         return _delegateSerializer.isEmpty(prov, delegateValue);\n     }\n \n@@ -239,9 +221,7 @@ public class StdDelegatingSerializer\n          *    properly... but for now, try this:\n          */\n         // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-        if (_delegateSerializer != null) {\n-            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n-        }\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n \n     /*\n@@ -273,10 +253,5 @@ public class StdDelegatingSerializer\n      *\n      * @since 2.6\n      */\n-    protected JsonSerializer<Object> _findSerializer(Object value, SerializerProvider serializers)\n-        throws JsonMappingException\n-    {\n         // NOTE: will NOT call contextualization\n-        return serializers.findValueSerializer(value.getClass());\n-    }\n }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\nindex 6089e6be2..53e09849c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n@@ -259,7 +259,7 @@ public abstract class StdSerializer<T>\n                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                     // [databind#731]: Should skip if nominally java.lang.Object\n-                    if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) {\n+                    if (existingSerializer == null) {\n                         existingSerializer = provider.findValueSerializer(delegateType);\n                     }\n                     return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n"}
{"identifier": "Closure-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex c46ee7d..a77221a 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -152,7 +152,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n-      if (c.canInline(t.getScope())) {\n+      if (c.canInline()) {\n         c.inlineVariable();\n \n         // If definition c has dependencies, then inlining it may have\n@@ -277,7 +277,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n       return defMetadata.node;\n     }\n \n-    private boolean canInline(final Scope scope) {\n+    private boolean canInline() {\n       // Cannot inline a parameter.\n       if (getDefCfgNode().isFunction()) {\n         return false;\n@@ -372,12 +372,6 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n                   case Token.REGEXP:\n                   case Token.NEW:\n                     return true;\n-                  case Token.NAME:\n-                    Var var = scope.getOwnSlot(input.getString());\n-                    if (var != null\n-                        && var.getParentNode().isCatch()) {\n-                      return true;\n-                    }\n                 }\n                 return false;\n               }\n"}
{"identifier": "JacksonDatabind-93", "buggy_code": "    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n", "fixed_code": "    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\nindex 42273e084..afc7c45ba 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\n@@ -80,8 +80,8 @@ public class SubTypeValidator\n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n+            if (full.startsWith(PREFIX_STRING)) {\n+                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n"}
{"identifier": "Math-60", "buggy_code": "    /**\n     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n     * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\n     * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\n     *\n     * @param x Value at which the CDF is evaluated.\n     * @return CDF evaluated at {@code x}.\n     * @throws MathException if the algorithm fails to converge\n     */\n    public double cumulativeProbability(double x) throws MathException {\n        final double dev = x - mean;\n        try {\n        return 0.5 * (1.0 + Erf.erf((dev) /\n                    (standardDeviation * FastMath.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\n            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n                return 0;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1;\n            } else {\n                throw ex;\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n     * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\n     * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\n     *\n     * @param x Value at which the CDF is evaluated.\n     * @return CDF evaluated at {@code x}.\n     * @throws MathException if the algorithm fails to converge\n     */\n    public double cumulativeProbability(double x) throws MathException {\n        final double dev = x - mean;\n        if (FastMath.abs(dev) > 40 * standardDeviation) { \n            return dev < 0 ? 0.0d : 1.0d;\n        }\n        return 0.5 * (1.0 + Erf.erf((dev) /\n                    (standardDeviation * FastMath.sqrt(2.0))));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * For this distribution,\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex 0d7ce7d..0e124d8 100644\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -123,11 +123,18 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        if (FastMath.abs(dev) > 40 * standardDeviation) { \n-            return dev < 0 ? 0.0d : 1.0d;\n-        }\n+        try {\n         return 0.5 * (1.0 + Erf.erf((dev) /\n                     (standardDeviation * FastMath.sqrt(2.0))));\n+        } catch (MaxIterationsExceededException ex) {\n+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n+                return 0;\n+            } else if (x > (mean + 20 * standardDeviation)) {\n+                return 1;\n+            } else {\n+                throw ex;\n+            }\n+        }\n     }\n \n     /**\n"}
{"identifier": "Closure-37", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeTraversal.java b/src/com/google/javascript/jscomp/NodeTraversal.java\nindex 435b4a8..8201b41 100644\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n@@ -538,7 +538,7 @@ public class NodeTraversal {\n \n     // Body\n     Preconditions.checkState(body.getNext() == null &&\n-            body.isBlock(), body);\n+            body.isBlock());\n     traverseBranch(body, n);\n \n     popScope();\ndiff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 26cbc19..4da4085 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -664,13 +664,9 @@ class IRFactory {\n       node.addChildToBack(lp);\n \n       Node bodyNode = transform(functionNode.getBody());\n-      if (!bodyNode.isBlock()) {\n         // When in ideMode Rhino tries to parse some constructs the compiler\n         // doesn't support, repair it here. see Rhino's\n         // Parser#parseFunctionBodyExpr.\n-        Preconditions.checkState(config.isIdeMode);\n-        bodyNode = IR.block();\n-      }\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;\n"}
{"identifier": "Closure-57", "buggy_code": "  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n", "fixed_code": "  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null && target.getType() == Token.STRING) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ClosureCodingConvention.java b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\nindex b5a3c1b..c507c92 100644\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n@@ -194,7 +194,7 @@ public class ClosureCodingConvention extends DefaultCodingConvention {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null && target.getType() == Token.STRING) {\n+          if (target != null) {\n             className = target.getString();\n           }\n         }\n"}
{"identifier": "Lang-54", "buggy_code": "    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(String str) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len != 2 && len != 5 && len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch0 = str.charAt(0);\n        char ch1 = str.charAt(1);\n        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str, \"\");\n        } else {\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            } else {\n                if (str.charAt(5) != '_') {\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(String str) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len != 2 && len != 5 && len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch0 = str.charAt(0);\n        char ch1 = str.charAt(1);\n        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str, \"\");\n        } else {\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            char ch4 = str.charAt(4);\n            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            } else {\n                if (str.charAt(5) != '_') {\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex 9607953..139d9a7 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -111,9 +111,6 @@ public class LocaleUtils {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             char ch3 = str.charAt(3);\n-            if (ch3 == '_') {\n-                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n-            }\n             char ch4 = str.charAt(4);\n             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n"}
{"identifier": "Jsoup-71", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/PseudoTextElement.java b/src/main/java/org/jsoup/nodes/PseudoTextElement.java\ndeleted file mode 100644\nindex cacec3f..0000000\n--- a/src/main/java/org/jsoup/nodes/PseudoTextElement.java\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-package org.jsoup.nodes;\n-\n-import org.jsoup.parser.Tag;\n-\n-import java.io.IOException;\n-\n-/**\n- * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with\n- * the {@link org.jsoup.select.Selector} {@code :matchText} syntax.\n- */\n-public class PseudoTextElement extends Element {\n-\n-    public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) {\n-        super(tag, baseUri, attributes);\n-    }\n-\n-    @Override\n-    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n-    }\n-\n-    @Override\n-    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n-    }\n-}\ndiff --git a/src/main/java/org/jsoup/select/Evaluator.java b/src/main/java/org/jsoup/select/Evaluator.java\nindex 735606f..86b43d9 100644\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n@@ -6,8 +6,6 @@ import org.jsoup.nodes.Document;\n import org.jsoup.nodes.DocumentType;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n-import org.jsoup.nodes.PseudoTextElement;\n-import org.jsoup.nodes.TextNode;\n import org.jsoup.nodes.XmlDeclaration;\n \n import java.util.List;\n@@ -753,26 +751,6 @@ public abstract class Evaluator {\n         }\n     }\n \n-    public static final class MatchText extends Evaluator {\n \n-        @Override\n-        public boolean matches(Element root, Element element) {\n-            if (element instanceof PseudoTextElement)\n-                return true;\n-\n-            List<TextNode> textNodes = element.textNodes();\n-            for (TextNode textNode : textNodes) {\n-                PseudoTextElement pel = new PseudoTextElement(\n-                    org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes());\n-                textNode.replaceWith(pel);\n-                pel.appendChild(textNode);\n-            }\n-            return false;\n-        }\n \n-        @Override\n-        public String toString() {\n-            return \":matchText\";\n-        }\n-    }\n }\ndiff --git a/src/main/java/org/jsoup/select/QueryParser.java b/src/main/java/org/jsoup/select/QueryParser.java\nindex 99e5147..e00f46e 100644\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n@@ -200,8 +200,6 @@ public class QueryParser {\n         \tevals.add(new Evaluator.IsEmpty());\n         else if (tq.matchChomp(\":root\"))\n         \tevals.add(new Evaluator.IsRoot());\n-        else if (tq.matchChomp(\":matchText\"))\n-            evals.add(new Evaluator.MatchText());\n \t\telse // unhandled\n             throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n \n"}
{"identifier": "JacksonDatabind-46", "buggy_code": "    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(';');\n        return sb;\n    }\n", "fixed_code": "    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\nindex 6083faf8d..b724510b4 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n@@ -153,7 +153,7 @@ public class ReferenceType extends SimpleType\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(\">;\");\n+        sb.append(';');\n         return sb;\n     }\n     \n"}
{"identifier": "Closure-5", "buggy_code": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically, we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore most indirect references, like x.y (but not x.y(),\n        // since the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target may be using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-referential. IOW,\n        // disallow things like x = {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n        // but x = {a: 1, b: x.a} is.\n        //\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }\n", "fixed_code": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically, we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore most indirect references, like x.y (but not x.y(),\n        // since the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target may be using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n          if (gramps.isDelProp()) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-referential. IOW,\n        // disallow things like x = {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n        // but x = {a: 1, b: x.a} is.\n        //\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Counts the number of direct (full) references to an object.\n     * Specifically, we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex d03988c..2b85d84 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,9 +173,6 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n-          if (gramps.isDelProp()) {\n-            return false;\n-          }\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an\n"}
{"identifier": "JxPath-6", "buggy_code": "    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n            return contains((Iterator) l, r);\n        }\n        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n            return contains((Iterator) r, l);\n        }\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        return equal(l, r);\n    }\n", "fixed_code": "    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext) {\n            ((EvalContext) l).reset();\n        }\n\n        if (l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext) {\n            ((EvalContext) r).reset();\n        }\n\n        if (r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n            return contains((Iterator) l, r);\n        }\n        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n            return contains((Iterator) r, l);\n        }\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        return equal(l, r);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\nindex 945cddb..5058dd2 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n@@ -54,19 +54,11 @@ public abstract class CoreOperationCompare extends CoreOperation {\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext) {\n-            ((EvalContext) l).reset();\n-        }\n-\n-        if (l instanceof SelfContext) {\n+        if (l instanceof InitialContext || l instanceof SelfContext) {\n             l = ((EvalContext) l).getSingleNodePointer();\n         }\n \n-        if (r instanceof InitialContext) {\n-            ((EvalContext) r).reset();\n-        }\n-\n-        if (r instanceof SelfContext) {\n+        if (r instanceof InitialContext || r instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n"}
{"identifier": "Codec-8", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 2521c27b..76f14f50 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -416,6 +416,13 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         return eof ? -1 : 0;\n     }\n \n+    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n+        if (out != null && out.length == outAvail) {\n+            buffer = out;\n+            pos = outPos;\n+            readPos = outPos;\n+        }\n+    }\n     /**\n      * <p>\n      * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\ndiff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\nindex ad006f2e..a706702f 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n@@ -166,6 +166,9 @@ public class Base64InputStream extends FilterInputStream {\n                 if (!base64.hasData()) {\n                     byte[] buf = new byte[doEncode ? 4096 : 8192];\n                     int c = in.read(buf);\n+                    if (c > 0 && b.length == len) {\n+                        base64.setInitialBuffer(b, offset, len);\n+                    }\n                     if (doEncode) {\n                         base64.encode(buf, 0, c);\n                     } else {\n"}
{"identifier": "JacksonDatabind-9", "buggy_code": "    @Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n        String str;\n        \n        if (value instanceof Date) {\n            provider.defaultSerializeDateKey((Date) value, jgen);\n            return;\n        } else {\n            str = value.toString();\n        }\n        jgen.writeFieldName(str);\n    }\n", "fixed_code": "    @Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n        String str;\n        Class<?> cls = value.getClass();\n        \n        if (cls == String.class) {\n            str = (String) value;\n        } else if (Date.class.isAssignableFrom(cls)) {\n            provider.defaultSerializeDateKey((Date) value, jgen);\n            return;\n        } else if (cls == Class.class) {\n            str = ((Class<?>) value).getName();\n        } else {\n            str = value.toString();\n        }\n        jgen.writeFieldName(str);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\nindex 56fbbe112..5fdf4eb9e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n@@ -24,15 +24,10 @@ public class StdKeySerializer extends StdSerializer<Object>\n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n-        Class<?> cls = value.getClass();\n         \n-        if (cls == String.class) {\n-            str = (String) value;\n-        } else if (Date.class.isAssignableFrom(cls)) {\n+        if (value instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n-        } else if (cls == Class.class) {\n-            str = ((Class<?>) value).getName();\n         } else {\n             str = value.toString();\n         }\n"}
{"identifier": "Closure-75", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex c97e091..7a882de 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -310,10 +310,7 @@ public final class NodeUtil {\n   }\n \n   static Double getStringNumberValue(String rawJsString) {\n-    if (rawJsString.contains(\"\\u000b\")) {\n       // vertical tab is not always whitespace\n-      return null;\n-    }\n \n     String s = trimJsWhiteSpace(rawJsString);\n     // return ScriptRuntime.toNumber(s);\n@@ -375,7 +372,7 @@ public final class NodeUtil {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\n       case '\\u000B': // <VT>\n-        return TernaryValue.UNKNOWN;  // IE says \"no\", EcmaScript says \"yes\"\n+        return TernaryValue.TRUE;\n       case ' ': // <SP>\n       case '\\n': // <LF>\n       case '\\r': // <CR>\n"}
{"identifier": "Closure-23", "buggy_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n\n    if (!right.isNumber()) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node current = left.getFirstChild();\n    Node elem = null;\n    for (int i = 0; current != null && i < intIndex; i++) {\n        elem = current;\n\n      current = current.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.isEmpty()) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }\n", "fixed_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n\n    if (!right.isNumber()) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node current = left.getFirstChild();\n    Node elem = null;\n    for (int i = 0; current != null; i++) {\n      if (i != intIndex) {\n        if (mayHaveSideEffects(current)) {\n          return n;\n        }\n      } else {\n        elem = current;\n      }\n\n      current = current.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.isEmpty()) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate Node tryFoldArrayAccess(Node n, Node left, Node right)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 7a0313c..f777b1c 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1448,14 +1448,8 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null; i++) {\n-      if (i != intIndex) {\n-        if (mayHaveSideEffects(current)) {\n-          return n;\n-        }\n-      } else {\n+    for (int i = 0; current != null && i < intIndex; i++) {\n         elem = current;\n-      }\n \n       current = current.getNext();\n     }\n"}
{"identifier": "JacksonDatabind-5", "buggy_code": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                        mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }\n", "fixed_code": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                    am = mixIns.find(m);\n                    if (am != null) {\n                        _addMixUnders(m, am);\n                    } else {\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\nindex fa379b104..d6e44ab58 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n@@ -655,12 +655,7 @@ public final class AnnotatedClass\n                      */\n                 } else {\n                     // Well, or, as per [Issue#515], multi-level merge within mixins...\n-                    am = mixIns.find(m);\n-                    if (am != null) {\n-                        _addMixUnders(m, am);\n-                    } else {\n                         mixIns.add(_constructMethod(m));\n-                    }\n                 }\n             }\n         }\n"}
{"identifier": "Closure-50", "buggy_code": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node right = callTarget.getNext();\n    if (right != null) {\n      if (!NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n      // \",\" is the default, it doesn't need to be explicit\n\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n\n    return n;\n  }\n", "fixed_code": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node right = callTarget.getNext();\n    if (right != null) {\n      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    if (right != null && right.getType() == Token.STRING\n        && \",\".equals(right.getString())) {\n      // \",\" is the default, it doesn't need to be explicit\n      n.removeChild(right);\n      reportCodeChange();\n    }\n\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n\n    return n;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\nindex afaf85a..ffe47d3 100644\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n@@ -373,7 +373,7 @@ class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n \n     Node right = callTarget.getNext();\n     if (right != null) {\n-      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n+      if (!NodeUtil.isImmutableValue(right)) {\n         return n;\n       }\n     }\n@@ -386,12 +386,7 @@ class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n       return n;\n     }\n \n-    if (right != null && right.getType() == Token.STRING\n-        && \",\".equals(right.getString())) {\n       // \",\" is the default, it doesn't need to be explicit\n-      n.removeChild(right);\n-      reportCodeChange();\n-    }\n \n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n"}
{"identifier": "Compress-5", "buggy_code": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n            if (inf.needsInput()) {\n                fill();\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0 && inf.finished()) {\n                return -1;\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }\n", "fixed_code": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n            if (inf.needsInput()) {\n                fill();\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0) {\n                if (inf.finished()) {\n                    return -1;\n                } else if (lengthOfLastRead == -1) {\n                    throw new IOException(\"Truncated ZIP file\");\n                }\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic int read(byte[] buffer, int start, int length) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\nindex 5ee2eab9..befee541 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n@@ -236,12 +236,8 @@ public class ZipArchiveInputStream extends ArchiveInputStream {\n             } catch (DataFormatException e) {\n                 throw new ZipException(e.getMessage());\n             }\n-            if (read == 0) {\n-                if (inf.finished()) {\n-                    return -1;\n-                } else if (lengthOfLastRead == -1) {\n-                    throw new IOException(\"Truncated ZIP file\");\n-                }\n+            if (read == 0 && inf.finished()) {\n+                return -1;\n             }\n             crc.update(buffer, start, read);\n             return read;\n"}
{"identifier": "Jsoup-92", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java\nindex 85dabcf..a716abc 100644\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -3,7 +3,6 @@ package org.jsoup.nodes;\n import org.jsoup.SerializationException;\n import org.jsoup.helper.Validate;\n import org.jsoup.internal.StringUtil;\n-import org.jsoup.parser.ParseSettings;\n \n import java.io.IOException;\n import java.util.AbstractMap;\n@@ -116,12 +115,11 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n      * Adds a new attribute. Will produce duplicates if the key already exists.\n      * @see Attributes#put(String, String)\n      */\n-    public Attributes add(String key, String value) {\n+    private void add(String key, String value) {\n         checkCapacity(size + 1);\n         keys[size] = key;\n         vals[size] = value;\n         size++;\n-        return this;\n     }\n \n     /**\n@@ -238,9 +236,6 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n     /**\n      * Test if this Attributes list is empty (size==0).\n      */\n-    public boolean isEmpty() {\n-        return size == 0;\n-    }\n \n     /**\n      Add all the attributes from the incoming set to this set.\n@@ -399,24 +394,6 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n      * @param settings case sensitivity\n      * @return number of removed dupes\n      */\n-    public int deduplicate(ParseSettings settings) {\n-        if (isEmpty())\n-            return 0;\n-        boolean preserve = settings.preserveAttributeCase();\n-        int dupes = 0;\n-        OUTER: for (int i = 0; i < keys.length; i++) {\n-            for (int j = i + 1; j < keys.length; j++) {\n-                if (keys[j] == null)\n-                    continue OUTER; // keys.length doesn't shrink when removing, so re-test\n-                if ((preserve && keys[i].equals(keys[j])) || (!preserve && keys[i].equalsIgnoreCase(keys[j]))) {\n-                    dupes++;\n-                    remove(j);\n-                    j--;\n-                }\n-            }\n-        }\n-        return dupes;\n-    }\n \n     private static class Dataset extends AbstractMap<String, String> {\n         private final Attributes attributes;\ndiff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 099859d..e51f5f3 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -196,12 +196,6 @@ public class HtmlTreeBuilder extends TreeBuilder {\n \n     Element insert(final Token.StartTag startTag) {\n         // cleanup duplicate attributes:\n-        if (!startTag.attributes.isEmpty()) {\n-            int dupes = startTag.attributes.deduplicate(settings);\n-            if (dupes > 0) {\n-                error(\"Duplicate attribute\");\n-            }\n-        }\n \n         // handle empty unknown tags\n         // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\ndiff --git a/src/main/java/org/jsoup/parser/ParseSettings.java b/src/main/java/org/jsoup/parser/ParseSettings.java\nindex 18c685a..1378978 100644\n--- a/src/main/java/org/jsoup/parser/ParseSettings.java\n+++ b/src/main/java/org/jsoup/parser/ParseSettings.java\n@@ -35,9 +35,6 @@ public class ParseSettings {\n     /**\n      * Returns true if preserving attribute case.\n      */\n-    public boolean preserveAttributeCase() {\n-        return preserveAttributeCase;\n-    }\n \n     /**\n      * Define parse settings.\ndiff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java\nindex ca26404..9b0b7c2 100644\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n@@ -113,7 +113,7 @@ abstract class Token {\n                     else\n                         value = null;\n                     // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).\n-                    attributes.add(pendingAttributeName, value);\n+                    attributes.put(pendingAttributeName, value);\n                 }\n             }\n             pendingAttributeName = null;\ndiff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex 7fbe251..01dbcef 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -75,7 +75,6 @@ public class XmlTreeBuilder extends TreeBuilder {\n     Element insert(Token.StartTag startTag) {\n         Tag tag = Tag.valueOf(startTag.name(), settings);\n         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n-        startTag.attributes.deduplicate(settings);\n \n         Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n         insertNode(el);\n"}
{"identifier": "JacksonDatabind-103", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java b/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\nindex 11110380b..134498bd6 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n@@ -192,7 +192,7 @@ public abstract class DatabindContext\n                 throw invalidTypeIdException(baseType, subClass, String.format(\n                         \"problem: (%s) %s\",\n                         e.getClass().getName(),\n-                        ClassUtil.exceptionMessage(e)));\n+                        e.getMessage()));\n             }\n             if (baseType.isTypeOrSuperTypeOf(cls)) {\n                 return getTypeFactory().constructSpecializedType(baseType, cls);\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\nindex e2ff054bf..5ac7cdbf7 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n@@ -711,7 +711,7 @@ public abstract class DeserializationContext\n         } catch (ParseException e) {\n             throw new IllegalArgumentException(String.format(\n                     \"Failed to parse Date value '%s': %s\", dateStr,\n-                    ClassUtil.exceptionMessage(e)));\n+                    e.getMessage()));\n         }\n     }\n \n@@ -1600,7 +1600,7 @@ trailingToken, ClassUtil.nameOf(targetType)\n         String excMsg;\n         if (cause == null) {\n             excMsg = \"N/A\";\n-        } else if ((excMsg = ClassUtil.exceptionMessage(cause)) == null) {\n+        } else if ((excMsg = cause.getMessage()) == null) {\n             excMsg = ClassUtil.nameOf(cause.getClass());\n         }\n         String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\nindex 4c258186f..e0c6408b2 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n@@ -7,7 +7,6 @@ import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Checked exception used to signal fatal problems with mapping of\n@@ -337,7 +336,7 @@ public class JsonMappingException\n         return new JsonMappingException(null,\n                 String.format(\"Unexpected IOException (of type %s): %s\",\n                         src.getClass().getName(),\n-                        ClassUtil.exceptionMessage(src)));\n+                        src.getMessage()));\n     }\n \n     /**\n@@ -378,7 +377,7 @@ public class JsonMappingException\n             jme = (JsonMappingException) src;\n         } else {\n             // [databind#2128]: try to avoid duplication\n-            String msg = ClassUtil.exceptionMessage(src);\n+            String msg = src.getMessage();\n             // Let's use a more meaningful placeholder if all we have is null\n             if (msg == null || msg.length() == 0) {\n                 msg = \"(was \"+src.getClass().getName()+\")\";\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\nindex ac24e1128..d68b57809 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n@@ -1338,7 +1338,7 @@ public abstract class SerializerProvider\n             // We better only expose checked exceptions, since those\n             // are what caller is expected to handle\n             ser = null; // doesn't matter but compiler whines otherwise\n-            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n+            reportMappingProblem(iae, iae.getMessage());\n         }\n \n         if (ser != null) {\n@@ -1358,7 +1358,7 @@ public abstract class SerializerProvider\n             // We better only expose checked exceptions, since those\n             // are what caller is expected to handle\n             ser = null;\n-            reportMappingProblem(iae, ClassUtil.exceptionMessage(iae));\n+            reportMappingProblem(iae, iae.getMessage());\n         }\n     \n         if (ser != null) {\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex 2019d1e05..042cf0afd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -1586,7 +1586,7 @@ nonAnnotatedParamIndex, ctor);\n             return b.buildTypeDeserializer(config, baseType, subtypes);\n         } catch (IllegalArgumentException e0) {\n             InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n-                    ClassUtil.exceptionMessage(e0), baseType);\n+                    e0.getMessage(), baseType);\n             e.initCause(e0);\n             throw e;\n         }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex 1f02d709f..9835b52dd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -219,7 +219,7 @@ public class BeanDeserializerFactory\n             //   to throw proper exception, it doesn't actually have reference to this\n             //   instance so...\n             throw InvalidDefinitionException.from(ctxt.getParser(),\n-                    ClassUtil.exceptionMessage(e),\n+                    e.getMessage(),\n                     beanDesc, null);\n         }\n         BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n@@ -278,7 +278,7 @@ public class BeanDeserializerFactory\n             //   to throw proper exception, it doesn't actually have reference to this\n             //   instance so...\n             throw InvalidDefinitionException.from(ctxt.getParser(),\n-                    ClassUtil.exceptionMessage(e),\n+                    e.getMessage(),\n                     builderDesc, null);\n         }\n         final DeserializationConfig config = ctxt.getConfig();\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\nindex 8aff0256a..b4dbdbe23 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n@@ -265,7 +265,7 @@ public final class DeserializerCache\n         } catch (IllegalArgumentException iae) {\n             // We better only expose checked exceptions, since those\n             // are what caller is expected to handle\n-            throw JsonMappingException.from(ctxt, ClassUtil.exceptionMessage(iae), iae);\n+            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n         }\n         if (deser == null) {\n             return null;\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\nindex 465562eed..e6663f158 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n@@ -199,7 +199,7 @@ public class SettableAnyProperty\n             StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n             msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n             msg.append(\"; actual type: \").append(actType).append(\")\");\n-            String origMsg = ClassUtil.exceptionMessage(e);\n+            String origMsg = e.getMessage();\n             if (origMsg != null) {\n                 msg.append(\", problem: \").append(origMsg);\n             } else {\n@@ -211,7 +211,7 @@ public class SettableAnyProperty\n         ClassUtil.throwIfRTE(e);\n         // let's wrap the innermost problem\n         Throwable t = ClassUtil.getRootCause(e);\n-        throw new JsonMappingException(null, ClassUtil.exceptionMessage(t), t);\n+        throw new JsonMappingException(null, t.getMessage(), t);\n     }\n \n     private String getClassName() { return _setter.getDeclaringClass().getName(); }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\nindex bd0c044b1..31a5bb056 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n@@ -587,7 +587,7 @@ public abstract class SettableBeanProperty\n                     .append(getType())\n                     .append(\"; actual type: \")\n                     .append(actType).append(\")\");\n-            String origMsg = ClassUtil.exceptionMessage(e);\n+            String origMsg = e.getMessage();\n             if (origMsg != null) {\n                 msg.append(\", problem: \")\n                     .append(origMsg);\n@@ -608,7 +608,7 @@ public abstract class SettableBeanProperty\n         ClassUtil.throwIfRTE(e);\n         // let's wrap the innermost problem\n         Throwable th = ClassUtil.getRootCause(e);\n-        throw JsonMappingException.from(p, ClassUtil.exceptionMessage(th), th);\n+        throw JsonMappingException.from(p, th.getMessage(), th);\n     }\n \n     @Deprecated // since 2.7\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\nindex 9a6f482f5..05ece2983 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n@@ -523,7 +523,7 @@ public abstract class StdDeserializer<T>\n         } catch (IllegalArgumentException iae) {\n             return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                     \"not a valid representation (error: %s)\",\n-                    ClassUtil.exceptionMessage(iae));\n+                    iae.getMessage());\n         }\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\nindex 5ff36d43c..c904c2e54 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n@@ -132,7 +132,7 @@ public class StdKeyDeserializer extends KeyDeserializer\n         } catch (Exception re) {\n             return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                     re.getClass().getName(),\n-                    ClassUtil.exceptionMessage(re));\n+                    re.getMessage());\n         }\n         if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n             return null;\n@@ -259,7 +259,7 @@ public class StdKeyDeserializer extends KeyDeserializer\n     // @since 2.9\n     protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n         return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n-                ClassUtil.exceptionMessage(e));\n+                e.getMessage());\n     }\n \n     /*\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\nindex 919c9636b..3d112e489 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n@@ -453,7 +453,7 @@ public class StdValueInstantiator\n             }\n         }\n         return new JsonMappingException(null,\n-                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+ClassUtil.exceptionMessage(t), t);\n+                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n     }\n \n     /**\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\nindex 139f73a1c..c23b068a6 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n@@ -361,7 +361,7 @@ anyField.getName()));\n             ClassUtil.throwIfRTE(t);\n             throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                     +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n-                    +ClassUtil.exceptionMessage(t), t);\n+                    +t.getMessage(), t);\n         }\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\nindex 2d521421f..549a25664 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n@@ -168,7 +168,7 @@ public abstract class DefaultSerializerProvider\n         } catch (Throwable t) {\n             String msg = String.format(\n \"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\n-filter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(t));\n+filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n             reportBadDefinition(filter.getClass(), msg, t);\n             return false; // never gets here\n         }\n@@ -502,7 +502,7 @@ filter.getClass().getName(), t.getClass().getName(), ClassUtil.exceptionMessage(\n         if (e instanceof IOException) {\n             return (IOException) e;\n         }\n-        String msg = ClassUtil.exceptionMessage(e);\n+        String msg = e.getMessage();\n         if (msg == null) {\n             msg = \"[no message for \"+e.getClass().getName()+\"]\";\n         }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\nindex 957af4caf..43602e351 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n@@ -100,9 +100,9 @@ public class PropertyBuilder\n             serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n         } catch (JsonMappingException e) {\n             if (propDef == null) {\n-                return prov.reportBadDefinition(declaredType, ClassUtil.exceptionMessage(e));\n+                return prov.reportBadDefinition(declaredType, e.getMessage());\n             }\n-            return prov.reportBadPropertyDefinition(_beanDesc, propDef, ClassUtil.exceptionMessage(e));\n+            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n         }\n \n         // Container types can have separate type serializers for content (value / element) type\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\nindex 28e88c5fa..b241a7552 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n@@ -7,7 +7,6 @@ import java.lang.reflect.*;\n import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n@@ -750,12 +749,6 @@ public final class ClassUtil\n      *\n      * @since 2.9.7\n      */\n-    public static String exceptionMessage(Throwable t) {\n-        if (t instanceof JsonProcessingException) {\n-            return ((JsonProcessingException) t).getOriginalMessage();\n-        }\n-        return t.getMessage();\n-    }\n     \n     /*\n     /**********************************************************\n"}
{"identifier": "Closure-101", "buggy_code": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n    if (flags.process_closure_primitives) {\n      options.closurePass = true;\n    }\n\n    initOptionsFromFlags(options);\n    return options;\n  }\n", "fixed_code": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.process_closure_primitives;\n    initOptionsFromFlags(options);\n    return options;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  protected CompilerOptions createOptions()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex c18639a..bdf5592 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -430,8 +430,10 @@ public class CommandLineRunner extends\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n+    if (flags.process_closure_primitives) {\n+      options.closurePass = true;\n+    }\n \n-    options.closurePass = flags.process_closure_primitives;\n     initOptionsFromFlags(options);\n     return options;\n   }\n"}
{"identifier": "Jsoup-43", "buggy_code": "    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n", "fixed_code": "    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element == search)\n                return i;\n        }\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate static <E extends Element> Integer indexInList(Element search, List<E> elements)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex 1575fd0..f1ae8dd 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -571,7 +571,7 @@ public class Element extends Node {\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element == search)\n+            if (element.equals(search))\n                 return i;\n         }\n         return null;\n"}
{"identifier": "Gson-10", "buggy_code": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }\n", "fixed_code": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\nindex 9d9f6be8..ab1d05a6 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n@@ -119,8 +119,8 @@ public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t = jsonAdapterPresent ? typeAdapter\n-            : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+        TypeAdapter t =\n+          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n"}
{"identifier": "Lang-14", "buggy_code": "    /**\n     * <p>Compares two CharSequences, returning {@code true} if they represent\n     * equal sequences of characters.</p>\n     *\n     * <p>{@code null}s are handled without exceptions. Two {@code null}\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * @see java.lang.CharSequence#equals(Object)\n     * @param cs1  the first CharSequence, may be {@code null}\n     * @param cs2  the second CharSequence, may be {@code null}\n     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n     * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n     */\n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n            return cs1.equals(cs2);\n    }\n", "fixed_code": "    /**\n     * <p>Compares two CharSequences, returning {@code true} if they represent\n     * equal sequences of characters.</p>\n     *\n     * <p>{@code null}s are handled without exceptions. Two {@code null}\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * @see java.lang.CharSequence#equals(Object)\n     * @param cs1  the first CharSequence, may be {@code null}\n     * @param cs2  the second CharSequence, may be {@code null}\n     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n     * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n     */\n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Compares two CharSequences, returning\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 4733b7e..535a3f2 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -785,10 +785,7 @@ public class StringUtils {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n-        if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n-        }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n \n     /**\n"}
{"identifier": "Codec-9", "buggy_code": "    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n", "fixed_code": "    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex e81b7e91..2cd0163b 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -824,7 +824,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n+        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n"}
{"identifier": "Mockito-37", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\nindex afaf14a..5d80578 100644\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n@@ -25,16 +25,8 @@ public class AnswersValidator {\n             validateDoNothing((DoesNothing) answer, invocation);\n         }\n         \n-        if (answer instanceof CallsRealMethods) {\n-            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\n-        }\n     }\n \n-    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\n-        if (invocation.getMethod().getDeclaringClass().isInterface()) {\n-            reporter.cannotCallRealMethodOnInterface();\n-        }\n-    }\n \n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\n         if (!invocation.isVoid()) {\n"}
{"identifier": "Math-36", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/fraction/BigFraction.java b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\nindex a6672e4..6181ec3 100644\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n@@ -683,14 +683,8 @@ public class BigFraction\n     @Override\n     public double doubleValue() {\n         double result = numerator.doubleValue() / denominator.doubleValue();\n-        if (Double.isNaN(result)) {\n             // Numerator and/or denominator must be out of range:\n             // Calculate how far to shift them to put them in range.\n-            int shift = Math.max(numerator.bitLength(),\n-                                 denominator.bitLength()) - Double.MAX_EXPONENT;\n-            result = numerator.shiftRight(shift).doubleValue() /\n-                denominator.shiftRight(shift).doubleValue();\n-        }\n         return result;\n     }\n \n@@ -736,14 +730,8 @@ public class BigFraction\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n-        if (Double.isNaN(result)) {\n             // Numerator and/or denominator must be out of range:\n             // Calculate how far to shift them to put them in range.\n-            int shift = Math.max(numerator.bitLength(),\n-                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n-            result = numerator.shiftRight(shift).floatValue() /\n-                denominator.shiftRight(shift).floatValue();\n-        }\n         return result;\n     }\n \n"}
{"identifier": "Compress-46", "buggy_code": "    private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x100000000L;\n        if (l >= TWO_TO_32) {\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }\n", "fixed_code": "    private static ZipLong unixTimeToZipLong(long l) {\n        if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate static ZipLong unixTimeToZipLong(long l)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\nindex f0508740..f7a74406 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n@@ -526,7 +526,8 @@ private static ZipLong dateToZipLong(final Date d) {\n     }\n \n     private static ZipLong unixTimeToZipLong(long l) {\n-        if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n+        final long TWO_TO_32 = 0x100000000L;\n+        if (l >= TWO_TO_32) {\n             throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n         }\n         return new ZipLong(l);\n"}
{"identifier": "Closure-67", "buggy_code": "    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n          ) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n", "fixed_code": "    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n          && assign.getParent().getType() == Token.EXPR_RESULT) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate boolean isPrototypePropertyAssign(Node assign)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\nindex 4472638..30b19e0 100644\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n@@ -315,7 +315,7 @@ class AnalyzePrototypeProperties implements CompilerPass {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          && assign.getParent().getType() == Token.EXPR_RESULT) {\n+          ) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n"}
{"identifier": "Jsoup-40", "buggy_code": "    /**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */\n    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        Validate.notEmpty(name);\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n", "fixed_code": "    /**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */\n    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */\n    public DocumentType(String name, String publicId, String systemId, String baseUri)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/DocumentType.java b/src/main/java/org/jsoup/nodes/DocumentType.java\nindex fc1ca23..4b4a5e9 100644\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n@@ -19,6 +19,7 @@ public class DocumentType extends Node {\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n+        Validate.notEmpty(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n"}
{"identifier": "Closure-25", "buggy_code": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n    return scope;\n  }\n", "fixed_code": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node constructor = n.getFirstChild();\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n          backwardsInferenceFromCallSite(n, ct);\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate FlowScope traverseNew(Node n, FlowScope scope)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 74728ee..7e218d8 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1033,9 +1033,9 @@ class TypeInference\n   }\n \n   private FlowScope traverseNew(Node n, FlowScope scope) {\n-    scope = traverseChildren(n, scope);\n \n     Node constructor = n.getFirstChild();\n+    scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {\n@@ -1052,11 +1052,13 @@ class TypeInference\n         }\n         if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n-          backwardsInferenceFromCallSite(n, ct);\n         }\n       }\n     }\n     n.setJSType(type);\n+    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n+      scope = traverse(arg, scope);\n+    }\n     return scope;\n   }\n \n"}
{"identifier": "Closure-151", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 609df79d..ebf4b51b 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -298,9 +298,6 @@ public class CommandLineRunner extends\n         + \"a manifest for each module.\")\n     private String output_manifest = \"\";\n \n-    @Option(name = \"--version\",\n-        usage = \"Prints the compiler version to stderr.\")\n-    private boolean version = false;\n \n     // Our own option parser to be backwards-compatible.\n     // It needs to be public because of the crazy reflection that args4j does.\n@@ -367,8 +364,6 @@ public class CommandLineRunner extends\n \n   private final Flags flags = new Flags();\n \n-  private static final String configResource =\n-      \"com.google.javascript.jscomp.parsing.ParserConfig\";\n \n   private boolean isConfigValid = false;\n \n@@ -420,14 +415,6 @@ public class CommandLineRunner extends\n       isConfigValid = false;\n     }\n \n-    if (flags.version) {\n-      ResourceBundle config = ResourceBundle.getBundle(configResource);\n-      err.println(\n-          \"Closure Compiler (http://code.google.com/p/closure/compiler)\\n\" +\n-          \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n-          \"Built on: \" + config.getString(\"compiler.date\"));\n-      err.flush();\n-    }\n \n     if (!isConfigValid || flags.display_help) {\n       isConfigValid = false;\n"}
{"identifier": "JxPath-12", "buggy_code": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n", "fixed_code": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic static boolean testNode(Node node, NodeTest test)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex 03efb68..de50adf 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -105,8 +105,7 @@ public class DOMNodePointer extends NodePointer {\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n-                        && equalStrings(testPrefix, getPrefix(node));\n+                return equalStrings(namespaceURI, nodeNS);\n             }\n             return false;\n         }\n"}
{"identifier": "Closure-86", "buggy_code": "  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n", "fixed_code": "  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return false;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 9049aae..dd78f90 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2462,7 +2462,7 @@ public final class NodeUtil {\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return false;\n+        return true;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n"}
{"identifier": "Closure-36", "buggy_code": "    /**\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     */\n    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n      if (!isValidDeclaration(declaration)\n          || !isValidInitialization(initialization)\n          || !isValidReference(reference)) {\n        return false;\n      }\n\n      // If the value is read more than once, skip it.\n      // VAR declarations and EXPR_RESULT don't need the value, but other\n      // ASSIGN expressions parents do.\n      if (declaration != initialization &&\n          !initialization.getGrandparent().isExprResult()) {\n        return false;\n      }\n\n      // Be very conservative and do no cross control structures or\n      // scope boundaries\n      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n        return false;\n      }\n\n      // Do not inline into a call node. This would change\n      // the context in which it was being called. For example,\n      //   var a = b.c;\n      //   a();\n      // should not be inlined, because it calls a in the context of b\n      // rather than the context of the window.\n      //   var a = b.c;\n      //   f(a)\n      // is ok.\n      Node value = initialization.getAssignedValue();\n      Preconditions.checkState(value != null);\n      if (value.isGetProp()\n          && reference.getParent().isCall()\n          && reference.getParent().getFirstChild() == reference.getNode()) {\n        return false;\n      }\n\n      if (value.isFunction()) {\n        Node callNode = reference.getParent();\n        if (reference.getParent().isCall()) {\n          CodingConvention convention = compiler.getCodingConvention();\n          // Bug 2388531: Don't inline subclass definitions into class defining\n          // calls as this confused class removing logic.\n          SubclassRelationship relationship =\n              convention.getClassesDefinedByCall(callNode);\n          if (relationship != null) {\n            return false;\n          }\n\n          // issue 668: Don't inline singleton getter methods\n          // calls as this confused class removing logic.\n        }\n      }\n\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }\n", "fixed_code": "    /**\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     */\n    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n      if (!isValidDeclaration(declaration)\n          || !isValidInitialization(initialization)\n          || !isValidReference(reference)) {\n        return false;\n      }\n\n      // If the value is read more than once, skip it.\n      // VAR declarations and EXPR_RESULT don't need the value, but other\n      // ASSIGN expressions parents do.\n      if (declaration != initialization &&\n          !initialization.getGrandparent().isExprResult()) {\n        return false;\n      }\n\n      // Be very conservative and do no cross control structures or\n      // scope boundaries\n      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n        return false;\n      }\n\n      // Do not inline into a call node. This would change\n      // the context in which it was being called. For example,\n      //   var a = b.c;\n      //   a();\n      // should not be inlined, because it calls a in the context of b\n      // rather than the context of the window.\n      //   var a = b.c;\n      //   f(a)\n      // is ok.\n      Node value = initialization.getAssignedValue();\n      Preconditions.checkState(value != null);\n      if (value.isGetProp()\n          && reference.getParent().isCall()\n          && reference.getParent().getFirstChild() == reference.getNode()) {\n        return false;\n      }\n\n      if (value.isFunction()) {\n        Node callNode = reference.getParent();\n        if (reference.getParent().isCall()) {\n          CodingConvention convention = compiler.getCodingConvention();\n          // Bug 2388531: Don't inline subclass definitions into class defining\n          // calls as this confused class removing logic.\n          SubclassRelationship relationship =\n              convention.getClassesDefinedByCall(callNode);\n          if (relationship != null) {\n            return false;\n          }\n\n          // issue 668: Don't inline singleton getter methods\n          // calls as this confused class removing logic.\n          if (convention.getSingletonGetterClassName(callNode) != null) {\n            return false;\n          }\n        }\n      }\n\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     */\n    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 47b8e8a..0b4b3de 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,9 +572,6 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n-          if (convention.getSingletonGetterClassName(callNode) != null) {\n-            return false;\n-          }\n         }\n       }\n \n"}
{"identifier": "JacksonDatabind-42", "buggy_code": "        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            // As per [databind#398], URI requires special handling\n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            // As per [databind#1123], Locale too\n            return super._deserializeFromEmptyString();\n        }\n", "fixed_code": "        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            // As per [databind#398], URI requires special handling\n            if (_kind == STD_URI) {\n                return URI.create(\"\");\n            }\n            // As per [databind#1123], Locale too\n            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }\n            return super._deserializeFromEmptyString();\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n        protected Object _deserializeFromEmptyString() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex b2ccd1aeb..cdbd5e8ac 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -281,9 +281,6 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n                 return URI.create(\"\");\n             }\n             // As per [databind#1123], Locale too\n-            if (_kind == STD_LOCALE) {\n-                return Locale.ROOT;\n-            }\n             return super._deserializeFromEmptyString();\n         }\n     }\n"}
{"identifier": "Mockito-1", "buggy_code": "    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            throw new UnsupportedOperationException();\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }\n", "fixed_code": "    public void captureArgumentsFrom(Invocation invocation) {\n        if (invocation.getMethod().isVarArgs()) {\n            int indexOfVararg = invocation.getRawArguments().length - 1;\n            for (int position = 0; position < indexOfVararg; position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n            for (int position = indexOfVararg; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n                }\n            }\n\n        } else {\n            for (int position = 0; position < matchers.size(); position++) {\n                Matcher m = matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic void captureArgumentsFrom(Invocation invocation)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex d45e4c6..7b877b1 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -120,18 +120,7 @@ public class InvocationMatcher implements DescribedInvocation, CapturesArgumensF\n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            for (int position = 0; position < indexOfVararg; position++) {\n-                Matcher m = matchers.get(position);\n-                if (m instanceof CapturesArguments) {\n-                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n-                }\n-            }\n-            for (int position = indexOfVararg; position < matchers.size(); position++) {\n-                Matcher m = matchers.get(position);\n-                if (m instanceof CapturesArguments) {\n-                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n-                }\n-            }\n+            throw new UnsupportedOperationException();\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n"}
{"identifier": "Closure-24", "buggy_code": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar()) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n        }\n      }\n    }\n", "fixed_code": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar() &&\n            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void findAliases(NodeTraversal t)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex c248002..30d29d0 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -275,8 +275,8 @@ class ScopedAliases implements HotSwapCompilerPass {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar() &&\n-            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n+        if (parent.isVar()) {\n+          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n           String name = n.getString();\n           Var aliasVar = scope.getVar(name);\n           aliases.put(name, aliasVar);\n@@ -284,16 +284,15 @@ class ScopedAliases implements HotSwapCompilerPass {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n-        } else if (v.isBleedingFunction()) {\n           // Bleeding functions already get a BAD_PARAMETERS error, so just\n           // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n         } else {\n           // TODO(robbyw): Support using locals for private variables.\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n+        }\n       }\n     }\n \n"}
{"identifier": "Closure-7", "buggy_code": "    @Override\n    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n          // Objects are restricted to \"Function\", subtypes are left\n          // Only filter out subtypes of \"function\"\n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }\n", "fixed_code": "    @Override\n    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          // Objects are restricted to \"Function\", subtypes are left\n          return ctorType.getGreatestSubtype(type);\n        } else {\n          // Only filter out subtypes of \"function\"\n          return type.isSubtype(ctorType) ? null : type;\n        }\n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public JSType caseObjectType(ObjectType type)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex fa7d47d..0afabc8 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -610,13 +610,9 @@ public abstract class ChainableReverseAbstractInterpreter\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        if (resultEqualsValue) {\n+        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n-          return ctorType.getGreatestSubtype(type);\n-        } else {\n           // Only filter out subtypes of \"function\"\n-          return type.isSubtype(ctorType) ? null : type;\n-        }\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n"}
{"identifier": "Closure-161", "buggy_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.getType() == Token.EMPTY) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }\n", "fixed_code": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.getType() == Token.EMPTY) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate Node tryFoldArrayAccess(Node n, Node left, Node right)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex c51297f5..0b2636f4 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1280,9 +1280,6 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     // If GETPROP/GETELEM is used as assignment target the array literal is\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n-    if (isAssignmentTarget(n)) {\n-      return n;\n-    }\n \n     if (right.getType() != Token.NUMBER) {\n       // Sometimes people like to use complex expressions to index into\n"}
{"identifier": "Math-23", "buggy_code": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return\n                            best(current,\n                                 previous,\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n        UnivariatePointValuePair best = current;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best;\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return best(best,\n                            best(current,\n                                 previous,\n                                 isMinim),\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex 25f2f50..5136a14 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -148,7 +148,6 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n         // Best point encountered so far (which is the initial guess).\n-        UnivariatePointValuePair best = current;\n \n         int iter = 0;\n         while (true) {\n@@ -232,15 +231,10 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                 // User-defined convergence checker.\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n-                best = best(best,\n-                            best(current,\n-                                 previous,\n-                                 isMinim),\n-                            isMinim);\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best;\n+                        return best(current, previous, isMinim);\n                     }\n                 }\n \n@@ -277,10 +271,9 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(best,\n+                return\n                             best(current,\n                                  previous,\n-                                 isMinim),\n                             isMinim);\n             }\n             ++iter;\n"}
{"identifier": "Compress-32", "buggy_code": "    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }\n", "fixed_code": "    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Long.parseLong(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Long.parseLong(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void applyPaxHeadersToCurrentEntry(Map<String, String> headers)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex 41acf2af..c5570071 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -498,11 +498,11 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n             } else if (\"linkpath\".equals(key)){\n                 currEntry.setLinkName(val);\n             } else if (\"gid\".equals(key)){\n-                currEntry.setGroupId(Long.parseLong(val));\n+                currEntry.setGroupId(Integer.parseInt(val));\n             } else if (\"gname\".equals(key)){\n                 currEntry.setGroupName(val);\n             } else if (\"uid\".equals(key)){\n-                currEntry.setUserId(Long.parseLong(val));\n+                currEntry.setUserId(Integer.parseInt(val));\n             } else if (\"uname\".equals(key)){\n                 currEntry.setUserName(val);\n             } else if (\"size\".equals(key)){\n"}
{"identifier": "JxPath-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\nindex 4193b3a..4198333 100644\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n@@ -16,12 +16,10 @@\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n-import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n-import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n@@ -32,7 +30,6 @@ import org.apache.commons.jxpath.ri.model.NodePointer;\n  * @version $Revision$ $Date$\n  */\n public class AttributeContext extends EvalContext {\n-    private static final NodeNameTest WILDCARD_TEST = new NodeNameTest(new QName(null, \"*\"));\n \n     private NodeTest nodeTest;\n     private boolean setStarted = false;\n@@ -75,20 +72,12 @@ public class AttributeContext extends EvalContext {\n         super.setPosition(getCurrentPosition() + 1);\n         if (!setStarted) {\n             setStarted = true;\n-            NodeNameTest nodeNameTest = null;\n-            if (nodeTest instanceof NodeTypeTest) {\n-                if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE) {\n-                    nodeNameTest = WILDCARD_TEST;\n-                }\n-            }\n-            else if (nodeTest instanceof NodeNameTest) {\n-                nodeNameTest = (NodeNameTest) nodeTest;\n-            }\n-            if (nodeNameTest == null) {\n+            if (!(nodeTest instanceof NodeNameTest)) {\n                 return false;\n             }\n-            iterator = parentContext.getCurrentNodePointer().attributeIterator(\n-                    nodeNameTest.getNodeName());\n+            QName name = ((NodeNameTest) nodeTest).getNodeName();\n+            iterator =\n+                parentContext.getCurrentNodePointer().attributeIterator(name);\n         }\n         if (iterator == null) {\n             return false;\n@@ -99,4 +88,4 @@ public class AttributeContext extends EvalContext {\n         currentNodePointer = iterator.getNodePointer();\n         return true;\n     }\n-}\n\\ No newline at end of file\n+}\n"}
{"identifier": "Codec-10", "buggy_code": "    /**\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param txt String the source string\n     * @return A caverphone code for the given String\n     */\n    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }\n", "fixed_code": "    /**\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param txt String the source string\n     * @return A caverphone code for the given String\n     */\n    public String caverphone(String txt) {\n        // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n        // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n        if( txt == null || txt.length() == 0 ) {\n            return \"1111111111\";\n        }\n\n        // 1. Convert to lowercase\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"mb$\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n        txt = txt.replaceAll(\"b\", \"p\");\n        txt = txt.replaceAll(\"sh\", \"s2\");\n        txt = txt.replaceAll(\"z\", \"s\");\n        txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n        txt = txt.replaceAll(\"[aeiou]\", \"3\");\n        txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n        txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n        txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n        txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n        txt = txt.replaceAll(\"gh\", \"22\");\n        txt = txt.replaceAll(\"g\", \"k\");\n        txt = txt.replaceAll(\"s+\", \"S\");\n        txt = txt.replaceAll(\"t+\", \"T\");\n        txt = txt.replaceAll(\"p+\", \"P\");\n        txt = txt.replaceAll(\"k+\", \"K\");\n        txt = txt.replaceAll(\"f+\", \"F\");\n        txt = txt.replaceAll(\"m+\", \"M\");\n        txt = txt.replaceAll(\"n+\", \"N\");\n        txt = txt.replaceAll(\"w3\", \"W3\");\n        //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\n        txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n        txt = txt.replaceAll(\"w\", \"2\");\n        txt = txt.replaceAll(\"^h\", \"A\");\n        txt = txt.replaceAll(\"h\", \"2\");\n        txt = txt.replaceAll(\"r3\", \"R3\");\n        txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n        txt = txt.replaceAll(\"r\", \"2\");\n        txt = txt.replaceAll(\"l3\", \"L3\");\n        txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n        //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n        txt = txt.replaceAll(\"l\", \"2\");\n        //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n        //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n        //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n        // 5. Handle removals\n        txt = txt.replaceAll(\"2\", \"\");\n        txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n        txt = txt.replaceAll(\"3\", \"\");\n\n        // 6. put ten 1s on the end\n        txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n        // 7. take the first six characters as the code\n        return txt.substring(0, 10);          // 1.0 truncates to 6\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Encodes the given String into a Caverphone value.\n     *\n     * @param txt String the source string\n     * @return A caverphone code for the given String\n     */\n    public String caverphone(String txt)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/language/Caverphone.java b/src/java/org/apache/commons/codec/language/Caverphone.java\nindex 28505574..5ac7e9ce 100644\n--- a/src/java/org/apache/commons/codec/language/Caverphone.java\n+++ b/src/java/org/apache/commons/codec/language/Caverphone.java\n@@ -73,7 +73,7 @@ public class Caverphone implements StringEncoder {\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"mb$\", \"m2\");\n+        txt = txt.replaceAll(\"^mb\", \"m2\");\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n"}
{"identifier": "JacksonDatabind-98", "buggy_code": "    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    buffer.assignParameter(typeProp, typeId);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n", "fixed_code": "    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    final Object v;\n                    if (typeProp.getType().hasRawClass(String.class)) {\n                        v = typeId;\n                    } else {\n                        TokenBuffer tb = new TokenBuffer(p, ctxt);\n                        tb.writeString(typeId);\n                        v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt);\n                        tb.close();\n                    }\n                    buffer.assignParameter(typeProp, v);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\nindex 9ff1c0b9e..2a3fbaab1 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n@@ -295,16 +295,7 @@ public class ExternalTypeHandler\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    final Object v;\n-                    if (typeProp.getType().hasRawClass(String.class)) {\n-                        v = typeId;\n-                    } else {\n-                        TokenBuffer tb = new TokenBuffer(p, ctxt);\n-                        tb.writeString(typeId);\n-                        v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt);\n-                        tb.close();\n-                    }\n-                    buffer.assignParameter(typeProp, v);\n+                    buffer.assignParameter(typeProp, typeId);\n                 }\n             }\n         }\n"}
{"identifier": "Jsoup-76", "buggy_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    // todo - refactor to a switch statement\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        // same as final else, but short circuits lots of checks\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                // case will follow the original node (so honours ParseSettings)\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        // same as final fall through, but saves short circuit\n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "fixed_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    // todo - refactor to a switch statement\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        // same as final else, but short circuits lots of checks\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\");\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.processStartTag(\"input\", inputAttribs);\n                        tb.processEndTag(\"label\");\n                        tb.processStartTag(\"hr\");\n                        tb.processEndTag(\"form\");\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\");\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue;\n                                } else if (node == formatEl)\n                                    break;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n                                // case will follow the original node (so honours ParseSettings)\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"span\")) {\n                        // same as final fall through, but saves short circuit\n                        return anyOtherEndTag(t, tb);\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.processEndTag(\"body\");\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nboolean process(Token t, HtmlTreeBuilder tb)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex a230677..20820ee 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -379,7 +379,6 @@ enum HtmlTreeBuilderState {\n                             tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n-                        tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n                         tb.framesetOk(false);\n                     } else if (name.equals(\"form\")) {\n                         if (tb.getFormElement() != null) {\n"}
{"identifier": "Time-27", "buggy_code": "    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n", "fixed_code": "    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n            }\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n//-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\nindex f7c7738..1533228 100644\n--- a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n@@ -798,11 +798,9 @@ public class PeriodFormatterBuilder {\n         int size = elementPairs.size();\n         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n             Separator sep = (Separator) elementPairs.get(0);\n-            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                 sep = sep.finish(f.getPrinter(), f.getParser());\n                 return new PeriodFormatter(sep, sep);\n-            }\n         }\n         Object[] comp = createComposite(elementPairs);\n         if (notPrinter) {\n"}
{"identifier": "Compress-6", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex fe5270fd..6a7c1e93 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -61,7 +61,6 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n      */\n     public ZipArchiveEntry(String name) {\n         super(name);\n-        setName(name);\n     }\n \n     /**\n@@ -460,13 +459,11 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n             return false;\n         }\n         ZipArchiveEntry other = (ZipArchiveEntry) obj;\n-        String myName = getName();\n-        String otherName = other.getName();\n-        if (myName == null) {\n-            if (otherName != null) {\n+        if (name == null) {\n+            if (other.name != null) {\n                 return false;\n             }\n-        } else if (!myName.equals(otherName)) {\n+        } else if (!name.equals(other.name)) {\n             return false;\n         }\n         return true;\n"}
{"identifier": "Gson-2", "buggy_code": "  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) typeAdapter;\n\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n", "fixed_code": "  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n          @Override public void write(JsonWriter out, T1 value) throws IOException {\n            typeAdapter.write(out, value);\n          }\n\n          @Override public T1 read(JsonReader in) throws IOException {\n            T1 result = typeAdapter.read(in);\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n            return result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Returns a factory for all subtypes of\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\nindex 0268aa8a..dea7af76 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n@@ -830,20 +830,8 @@ public final class TypeAdapters {\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) new TypeAdapter<T1>() {\n-          @Override public void write(JsonWriter out, T1 value) throws IOException {\n-            typeAdapter.write(out, value);\n-          }\n+        return (TypeAdapter<T2>) typeAdapter;\n \n-          @Override public T1 read(JsonReader in) throws IOException {\n-            T1 result = typeAdapter.read(in);\n-            if (result != null && !requestedType.isInstance(result)) {\n-              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n-                  + \" but was \" + result.getClass().getName());\n-            }\n-            return result;\n-          }\n-        };\n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n"}
{"identifier": "Compress-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\nindex 2dc3b26f..005e3e76 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n@@ -52,7 +52,6 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n     private boolean closed = false;\n \n     /* Indicates if putArchiveEntry has been called without closeArchiveEntry */\n-    private boolean haveUnclosedEntry = false;\n     \n     private final OutputStream out;\n \n@@ -110,9 +109,6 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n      * @throws IOException on error\n      */\n     public void finish() throws IOException {\n-        if(haveUnclosedEntry) {\n-            throw new IOException(\"This archives contains unclosed entries.\");\n-        }\n         writeEOFRecord();\n         writeEOFRecord();\n     }\n@@ -188,7 +184,6 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n             currSize = entry.getSize();\n         }\n         currName = entry.getName();\n-        haveUnclosedEntry = true;\n     }\n \n     /**\n@@ -219,7 +214,6 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n                                   + \"' before the '\" + currSize\n                                   + \"' bytes specified in the header were written\");\n         }\n-        haveUnclosedEntry = false;\n     }\n \n     /**\n"}
{"identifier": "Cli-38", "buggy_code": "    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n        // check for several concatenated short options\n    }\n", "fixed_code": "    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName))\n        {\n            return true;\n        }\n        // check for several concatenated short options\n        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 2cee432..4bff7f3 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -307,12 +307,8 @@ public class DefaultParser implements CommandLineParser\n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        if (options.hasShortOption(optName))\n-        {\n-            return true;\n-        }\n+        return options.hasShortOption(optName);\n         // check for several concatenated short options\n-        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n     }\n \n     /**\n"}
{"identifier": "JacksonCore-6", "buggy_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n", "fixed_code": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        char c = str.charAt(0);\n        if (c <= '0') {\n            return (len == 1 && c == '0') ? 0 : -1;\n        }\n        if (c > '9') {\n            return -1;\n        }\n        for (int i = 1; i < len; ++i) {\n            c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate final static int _parseIndex(String str)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\nindex ff84f5ed..ab37c3b5 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n@@ -190,15 +190,8 @@ public class JsonPointer\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        char c = str.charAt(0);\n-        if (c <= '0') {\n-            return (len == 1 && c == '0') ? 0 : -1;\n-        }\n-        if (c > '9') {\n-            return -1;\n-        }\n-        for (int i = 1; i < len; ++i) {\n-            c = str.charAt(i);\n+        for (int i = 0; i < len; ++i) {\n+            char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n"}
{"identifier": "Closure-109", "buggy_code": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }\n", "fixed_code": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return newNode(Token.QMARK);\n    } else {\n      return parseBasicTypeExpression(token);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex c115e10..e30c350 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,11 +1905,7 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-    if (token == JsDocToken.QMARK) {\n-      return newNode(Token.QMARK);\n-    } else {\n-      return parseBasicTypeExpression(token);\n-    }\n+          return parseTypeName(token);\n   }\n \n   /**\n"}
{"identifier": "Closure-41", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\nindex e20d788..14694ce 100644\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n@@ -289,9 +289,6 @@ final class FunctionTypeBuilder {\n       }\n \n       // Clone any remaining params that aren't in the function literal.\n-      while (oldParams.hasNext()) {\n-        paramBuilder.newParameterFromNode(oldParams.next());\n-      }\n \n       parametersNode = paramBuilder.build();\n     }\n@@ -483,12 +480,6 @@ final class FunctionTypeBuilder {\n     }\n \n     // Copy over any old parameters that aren't in the param list.\n-    if (!isVarArgs) {\n-      while (oldParameterType != null && !isVarArgs) {\n-        builder.newParameterFromNode(oldParameterType);\n-        oldParameterType = oldParameterType.getNext();\n-      }\n-    }\n \n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n"}
{"identifier": "JacksonDatabind-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\nindex c0e79c8c0..b4ce3e956 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n@@ -25,24 +25,20 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n     /**\n      * State in which iterator is closed\n      */\n-    protected final static int STATE_CLOSED = 0;\n     \n     /**\n      * State in which value read failed\n      */\n-    protected final static int STATE_NEED_RESYNC = 1;\n     \n     /**\n      * State in which no recovery is needed, but \"hasNextValue()\" needs\n      * to be called first\n      */\n-    protected final static int STATE_MAY_HAVE_VALUE = 2;\n \n     /**\n      * State in which \"hasNextValue()\" has been succesfully called\n      * and deserializer can be called to fetch value\n      */\n-    protected final static int STATE_HAS_VALUE = 3;\n \n     /*\n     /**********************************************************\n@@ -70,13 +66,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n      * as not <code>null</code> but set as <code>null</null> when\n      * iterator is closed, to denote closing.\n      */\n-    protected final JsonParser _parser;\n+    protected JsonParser _parser;\n \n     /**\n      * Context to resynchronize to, in case an exception is encountered\n      * but caller wants to try to read more elements.\n      */\n-    protected final JsonStreamContext _seqContext;\n     \n     /**\n      * If not null, \"value to update\" instead of creating a new instance\n@@ -100,7 +95,7 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n     /**\n      * State of the iterator\n      */\n-    protected int _state;\n+    protected boolean _hasNextChecked;\n \n     /*\n     /**********************************************************\n@@ -140,25 +135,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n          * and if not, caller needs to hand us JsonParser instead, pointing to\n          * the first token of the first element.\n          */\n-        if (p == null) { // can this occur?\n-            _seqContext = null;\n-            _state = STATE_CLOSED;\n-        } else {\n-            JsonStreamContext sctxt = p.getParsingContext();\n-            if (managedParser && p.isExpectedStartArrayToken()) {\n+        if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {\n                 // If pointing to START_ARRAY, context should be that ARRAY\n                 p.clearCurrentToken();\n-            } else {\n                 // regardless, recovery context should be whatever context we have now,\n                 // with sole exception of pointing to a start marker, in which case it's\n                 // the parent\n-                JsonToken t = p.getCurrentToken();\n-                if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {\n-                    sctxt = sctxt.getParent();\n-                }\n-            }\n-            _seqContext = sctxt;\n-            _state = STATE_MAY_HAVE_VALUE;\n         }\n     }\n \n@@ -204,12 +186,9 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n     \n     @Override\n     public void close() throws IOException {\n-        if (_state != STATE_CLOSED) {\n-            _state = STATE_CLOSED;\n             if (_parser != null) {\n                 _parser.close();\n             }\n-        }\n     }\n \n     /*\n@@ -228,28 +207,25 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n      */\n     public boolean hasNextValue() throws IOException\n     {\n-        switch (_state) {\n-        case STATE_CLOSED:\n+        if (_parser == null) {\n             return false;\n-        case STATE_NEED_RESYNC:\n-            _resync();\n             // fall-through\n-        case STATE_MAY_HAVE_VALUE:\n+        }\n+        if (!_hasNextChecked) {\n             JsonToken t = _parser.getCurrentToken();\n+            _hasNextChecked = true;\n             if (t == null) { // un-initialized or cleared; find next\n                 t = _parser.nextToken();\n                 // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).\n                 if (t == null || t == JsonToken.END_ARRAY) {\n-                    _state = STATE_CLOSED;\n-                    if (_closeParser && (_parser != null)) {\n-                        _parser.close();\n+                    JsonParser jp = _parser;\n+                    _parser = null;\n+                    if (_closeParser) {\n+                        jp.close();\n                     }\n                     return false;\n                 }\n             }\n-            _state = STATE_HAS_VALUE;\n-            return true;\n-        case STATE_HAS_VALUE:\n             // fall through\n         }\n         return true;\n@@ -257,20 +233,16 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n \n     public T nextValue() throws IOException\n     {\n-        switch (_state) {\n-        case STATE_CLOSED:\n-            return _throwNoSuchElement();\n-        case STATE_NEED_RESYNC: // fall-through, will do re-sync\n-        case STATE_MAY_HAVE_VALUE:\n+        if (!_hasNextChecked) {\n             if (!hasNextValue()) {\n                 return _throwNoSuchElement();\n             }\n-            break;\n-        case STATE_HAS_VALUE:\n-            break;\n         }\n+        if (_parser == null) {\n+            return _throwNoSuchElement();\n+        }\n+        _hasNextChecked = false;\n \n-        int nextState = STATE_NEED_RESYNC;\n         try {\n             T value;\n             if (_updatedValue == null) {\n@@ -279,10 +251,8 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n                 _deserializer.deserialize(_parser, _context, _updatedValue);\n                 value = _updatedValue;\n             }\n-            nextState = STATE_MAY_HAVE_VALUE;\n             return value;\n         } finally {\n-            _state = nextState;\n             /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no\n              *   matter what, to avoid infinite loop for certain failure cases.\n              *   For 2.6 need to improve further.\n@@ -379,28 +349,8 @@ public class MappingIterator<T> implements Iterator<T>, Closeable\n     /**********************************************************\n      */\n \n-    protected void _resync() throws IOException\n-    {\n-        final JsonParser p = _parser;\n         // First, a quick check to see if we might have been lucky and no re-sync needed\n-        if (p.getParsingContext() == _seqContext) {\n-            return;\n-        }\n \n-        while (true) {\n-            JsonToken t = p.nextToken();\n-            if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {\n-                if (p.getParsingContext() == _seqContext) {\n-                    p.clearCurrentToken();\n-                    return;\n-                }\n-            } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {\n-                p.skipChildren();\n-            } else if (t == null) {\n-                return;\n-            }\n-        }\n-    }\n \n     protected <R> R _throwNoSuchElement() {\n         throw new NoSuchElementException();\n"}
{"identifier": "Closure-99", "buggy_code": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n            return false;\n          }\n      }\n    }\n\n    return true;\n  }\n", "fixed_code": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Since this pass reports errors only when a global\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex 5108686..25327af 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -89,7 +89,6 @@ final class CheckGlobalThis implements Callback {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n-           jsDoc.isInterface() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;\n@@ -123,17 +122,13 @@ final class CheckGlobalThis implements Callback {\n       } else {\n         // Only traverse the right side if it's not an assignment to a prototype\n         // property or subproperty.\n-        if (NodeUtil.isGet(lhs)) {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n-          Node llhs = lhs.getFirstChild();\n-          if (llhs.getType() == Token.GETPROP &&\n-              llhs.getLastChild().getString().equals(\"prototype\")) {\n+          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n             return false;\n           }\n-        }\n       }\n     }\n \n"}
{"identifier": "JacksonDatabind-32", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\nindex c96221412..76754bd37 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n@@ -218,7 +218,6 @@ public class UntypedObjectDeserializer\n         case JsonTokenId.ID_FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n-        case JsonTokenId.ID_END_OBJECT:\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n@@ -533,10 +532,8 @@ public class UntypedObjectDeserializer\n             case JsonTokenId.ID_NULL: // should not get this but...\n                 return null;\n \n-            case JsonTokenId.ID_END_OBJECT:\n                 // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n                 //    if caller has advanced to the first token of Object, but for empty Object\n-                return new LinkedHashMap<String,Object>(2);\n \n             //case JsonTokenId.ID_END_ARRAY: // invalid\n             default:\n"}
{"identifier": "Compress-40", "buggy_code": "    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        \n        final long bitsOut;\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        return bitsOut;\n    }\n", "fixed_code": "    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        while (bitsCachedSize < count && bitsCachedSize < 57) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else {\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            bitsCachedSize += 8;\n        }\n        int overflowBits = 0;\n        long overflow = 0l;\n        if (bitsCachedSize < count) {\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n            int bitsToAddCount = count - bitsCachedSize;\n            overflowBits = 8 - bitsToAddCount;\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return nextByte;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n                bitsCached |= (bitsToAdd << bitsCachedSize);\n                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n            } else {\n                bitsCached <<= bitsToAddCount;\n                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n                bitsCached |= bitsToAdd;\n                overflow = nextByte & MASKS[overflowBits];\n            }\n            bitsCachedSize = count;\n        }\n        \n        final long bitsOut;\n        if (overflowBits == 0) {\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        } else {\n            bitsOut = bitsCached & MASKS[count];\n            bitsCached = overflow;\n            bitsCachedSize = overflowBits;\n        }\n        return bitsOut;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\nindex 35773b7d..86dda14e 100644\n--- a/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/BitInputStream.java\n@@ -82,7 +82,7 @@ public class BitInputStream implements Closeable {\n         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n             throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n         }\n-        while (bitsCachedSize < count && bitsCachedSize < 57) {\n+        while (bitsCachedSize < count) {\n             final long nextByte = in.read();\n             if (nextByte < 0) {\n                 return nextByte;\n@@ -95,31 +95,9 @@ public class BitInputStream implements Closeable {\n             }\n             bitsCachedSize += 8;\n         }\n-        int overflowBits = 0;\n-        long overflow = 0l;\n-        if (bitsCachedSize < count) {\n             // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n-            int bitsToAddCount = count - bitsCachedSize;\n-            overflowBits = 8 - bitsToAddCount;\n-            final long nextByte = in.read();\n-            if (nextByte < 0) {\n-                return nextByte;\n-            }\n-            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n-                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n-                bitsCached |= (bitsToAdd << bitsCachedSize);\n-                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n-            } else {\n-                bitsCached <<= bitsToAddCount;\n-                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n-                bitsCached |= bitsToAdd;\n-                overflow = nextByte & MASKS[overflowBits];\n-            }\n-            bitsCachedSize = count;\n-        }\n         \n         final long bitsOut;\n-        if (overflowBits == 0) {\n             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                 bitsOut = (bitsCached & MASKS[count]);\n                 bitsCached >>>= count;\n@@ -127,11 +105,6 @@ public class BitInputStream implements Closeable {\n                 bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n             }\n             bitsCachedSize -= count;\n-        } else {\n-            bitsOut = bitsCached & MASKS[count];\n-            bitsCached = overflow;\n-            bitsCachedSize = overflowBits;\n-        }\n         return bitsOut;\n     }\n }\n"}
{"identifier": "Closure-167", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\nindex 8165840a4..9e702797b 100644\n--- a/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\n@@ -298,8 +298,8 @@ public class SemanticReverseAbstractInterpreter\n     if (merged != null) {\n       return maybeRestrictTwoNames(\n           blindScope,\n-          left, leftType, leftIsRefineable ? merged.typeA : null,\n-          right, rightType, rightIsRefineable ? merged.typeB : null);\n+          left, leftIsRefineable, merged.typeA,\n+          right, rightIsRefineable, merged.typeB);\n     }\n     return blindScope;\n   }\n@@ -345,8 +345,8 @@ public class SemanticReverseAbstractInterpreter\n       // creating new scope\n       return maybeRestrictTwoNames(\n           blindScope,\n-          left, leftType, leftIsRefineable ? restrictedLeftType : null,\n-          right, rightType, rightIsRefineable ? restrictedRightType : null);\n+          left, leftIsRefineable, restrictedLeftType,\n+          right, rightIsRefineable, restrictedRightType);\n     }\n     return blindScope;\n   }\n@@ -391,7 +391,7 @@ public class SemanticReverseAbstractInterpreter\n    */\n   private FlowScope maybeRestrictName(\n       FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\n-    if (restrictedType != null && restrictedType != originalType) {\n+    if (restrictedType != null && !restrictedType.equals(originalType)) {\n       FlowScope informed = blindScope.createChildFlowScope();\n       declareNameInScope(informed, node, restrictedType);\n       return informed;\n@@ -404,12 +404,12 @@ public class SemanticReverseAbstractInterpreter\n    */\n   private FlowScope maybeRestrictTwoNames(\n       FlowScope blindScope,\n-      Node left, JSType originalLeftType, JSType restrictedLeftType,\n-      Node right, JSType originalRightType, JSType restrictedRightType) {\n+      Node left, boolean leftIsRefineable, JSType restrictedLeftType,\n+      Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n     boolean shouldRefineLeft =\n-        restrictedLeftType != null && restrictedLeftType != originalLeftType;\n+        leftIsRefineable && restrictedLeftType != null;\n     boolean shouldRefineRight =\n-        restrictedRightType != null && restrictedRightType != originalRightType;\n+        rightIsRefineable && restrictedRightType != null;\n     if (shouldRefineLeft || shouldRefineRight) {\n       FlowScope informed = blindScope.createChildFlowScope();\n       if (shouldRefineLeft) {\n@@ -427,9 +427,11 @@ public class SemanticReverseAbstractInterpreter\n       boolean outcome) {\n     JSType type = getTypeIfRefinable(name, blindScope);\n     if (type != null) {\n-      return maybeRestrictName(\n-          blindScope, name, type,\n-          type.getRestrictedTypeGivenToBooleanOutcome(outcome));\n+      JSType restrictedType =\n+          type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n+      FlowScope informed = blindScope.createChildFlowScope();\n+      declareNameInScope(informed, name, restrictedType);\n+      return informed;\n     }\n     return blindScope;\n   }\ndiff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex 44d1e93b6..8f0a1f69a 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -880,9 +880,6 @@ public abstract class JSType implements Serializable {\n    * method of types to get the restricted type.\n    */\n   public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n-    if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {\n-      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n-    }\n \n     BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n     if (literals.contains(outcome)) {\n"}
{"identifier": "Jsoup-63", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 3fe076a..c9963b9 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -224,11 +224,12 @@ public class HtmlTreeBuilder extends TreeBuilder {\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n             if (tag.isKnownTag()) {\n-                if (!tag.isEmpty())\n-                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n+                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();\n             }\n-            else // unknown tag, remember this is self closing for output\n+            else {\n                 tag.setSelfClosing();\n+                tokeniser.acknowledgeSelfClosingFlag();\n+            }\n         }\n         return el;\n     }\ndiff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java\nindex b047940..29fe4cc 100644\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n@@ -33,6 +33,7 @@ final class Tokeniser {\n     Token.Doctype doctypePending = new Token.Doctype(); // doctype building up\n     Token.Comment commentPending = new Token.Comment(); // comment building up\n     private String lastStartTag; // the last start tag emitted, to test appropriate end tag\n+    private boolean selfClosingFlagAcknowledged = true;\n \n     Tokeniser(CharacterReader reader, ParseErrorList errors) {\n         this.reader = reader;\n@@ -40,6 +41,10 @@ final class Tokeniser {\n     }\n \n     Token read() {\n+        if (!selfClosingFlagAcknowledged) {\n+            error(\"Self closing flag not acknowledged\");\n+            selfClosingFlagAcknowledged = true;\n+        }\n         while (!isEmitPending)\n             state.read(this, reader);\n \n@@ -68,6 +73,8 @@ final class Tokeniser {\n         if (token.type == Token.TokenType.StartTag) {\n             Token.StartTag startTag = (Token.StartTag) token;\n             lastStartTag = startTag.tagName;\n+            if (startTag.selfClosing)\n+                selfClosingFlagAcknowledged = false;\n         } else if (token.type == Token.TokenType.EndTag) {\n             Token.EndTag endTag = (Token.EndTag) token;\n             if (endTag.attributes != null)\n@@ -114,6 +121,9 @@ final class Tokeniser {\n         this.state = state;\n     }\n \n+    void acknowledgeSelfClosingFlag() {\n+        selfClosingFlagAcknowledged = true;\n+    }\n     final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays\n     final private int[] multipointHolder = new int[2];\n     int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n"}
{"identifier": "Lang-52", "buggy_code": "    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param out write to receieve the escaped string\n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuote escapes single quotes if <code>true</code>\n     * @throws IOException if an IOException occurs\n     */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (str == null) {\n            return;\n        }\n        int sz;\n        sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n\n            // handle unicode\n            if (ch > 0xfff) {\n                out.write(\"\\\\u\" + hex(ch));\n            } else if (ch > 0xff) {\n                out.write(\"\\\\u0\" + hex(ch));\n            } else if (ch > 0x7f) {\n                out.write(\"\\\\u00\" + hex(ch));\n            } else if (ch < 32) {\n                switch (ch) {\n                    case '\\b':\n                        out.write('\\\\');\n                        out.write('b');\n                        break;\n                    case '\\n':\n                        out.write('\\\\');\n                        out.write('n');\n                        break;\n                    case '\\t':\n                        out.write('\\\\');\n                        out.write('t');\n                        break;\n                    case '\\f':\n                        out.write('\\\\');\n                        out.write('f');\n                        break;\n                    case '\\r':\n                        out.write('\\\\');\n                        out.write('r');\n                        break;\n                    default :\n                        if (ch > 0xf) {\n                            out.write(\"\\\\u00\" + hex(ch));\n                        } else {\n                            out.write(\"\\\\u000\" + hex(ch));\n                        }\n                        break;\n                }\n            } else {\n                switch (ch) {\n                    case '\\'':\n                        if (escapeSingleQuote) {\n                          out.write('\\\\');\n                        }\n                        out.write('\\'');\n                        break;\n                    case '\"':\n                        out.write('\\\\');\n                        out.write('\"');\n                        break;\n                    case '\\\\':\n                        out.write('\\\\');\n                        out.write('\\\\');\n                        break;\n                    default :\n                        out.write(ch);\n                        break;\n                }\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Worker method for the {@link #escapeJavaScript(String)} method.</p>\n     * \n     * @param out write to receieve the escaped string\n     * @param str String to escape values in, may be null\n     * @param escapeSingleQuote escapes single quotes if <code>true</code>\n     * @throws IOException if an IOException occurs\n     */\n    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (str == null) {\n            return;\n        }\n        int sz;\n        sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            char ch = str.charAt(i);\n\n            // handle unicode\n            if (ch > 0xfff) {\n                out.write(\"\\\\u\" + hex(ch));\n            } else if (ch > 0xff) {\n                out.write(\"\\\\u0\" + hex(ch));\n            } else if (ch > 0x7f) {\n                out.write(\"\\\\u00\" + hex(ch));\n            } else if (ch < 32) {\n                switch (ch) {\n                    case '\\b':\n                        out.write('\\\\');\n                        out.write('b');\n                        break;\n                    case '\\n':\n                        out.write('\\\\');\n                        out.write('n');\n                        break;\n                    case '\\t':\n                        out.write('\\\\');\n                        out.write('t');\n                        break;\n                    case '\\f':\n                        out.write('\\\\');\n                        out.write('f');\n                        break;\n                    case '\\r':\n                        out.write('\\\\');\n                        out.write('r');\n                        break;\n                    default :\n                        if (ch > 0xf) {\n                            out.write(\"\\\\u00\" + hex(ch));\n                        } else {\n                            out.write(\"\\\\u000\" + hex(ch));\n                        }\n                        break;\n                }\n            } else {\n                switch (ch) {\n                    case '\\'':\n                        if (escapeSingleQuote) {\n                          out.write('\\\\');\n                        }\n                        out.write('\\'');\n                        break;\n                    case '\"':\n                        out.write('\\\\');\n                        out.write('\"');\n                        break;\n                    case '\\\\':\n                        out.write('\\\\');\n                        out.write('\\\\');\n                        break;\n                    case '/':\n                        out.write('\\\\');\n                        out.write('/');\n                        break;\n                    default :\n                        out.write(ch);\n                        break;\n                }\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Worker method for the\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/StringEscapeUtils.java b/src/java/org/apache/commons/lang/StringEscapeUtils.java\nindex db2d7bd..4fda091 100644\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -233,10 +233,6 @@ public class StringEscapeUtils {\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n-                    case '/':\n-                        out.write('\\\\');\n-                        out.write('/');\n-                        break;\n                     default :\n                         out.write(ch);\n                         break;\n"}
{"identifier": "Math-27", "buggy_code": "    /**\n     * <p>\n     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n     * fraction as the numerator divided by denominator multiplied by 100.\n     * </p>\n     *\n     * @return the fraction percentage as a <tt>double</tt>.\n     */\n    public double percentageValue() {\n        return multiply(100).doubleValue();\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n     * fraction as the numerator divided by denominator multiplied by 100.\n     * </p>\n     *\n     * @return the fraction percentage as a <tt>double</tt>.\n     */\n    public double percentageValue() {\n        return 100 * doubleValue();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n     * fraction as the numerator divided by denominator multiplied by 100.\n     * </p>\n     *\n     * @return the fraction percentage as a <tt>double</tt>.\n     */\n    public double percentageValue()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex f81ff0a..f84218e 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -594,7 +594,7 @@ public class Fraction\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return 100 * doubleValue();\n+        return multiply(100).doubleValue();\n     }\n \n     /**\n"}
{"identifier": "Lang-8", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\nindex c952309..5c0edda 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n@@ -1095,6 +1095,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n+        private final TimeZone zone;\n         private final String mStandard;\n         private final String mDaylight;\n \n@@ -1108,6 +1109,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n+            zone = timeZone;\n             \n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n@@ -1129,7 +1131,6 @@ public class FastDatePrinter implements DatePrinter, Serializable {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n"}
{"identifier": "Closure-141", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex aaf84703d..044bdd930 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -599,11 +599,8 @@ public final class NodeUtil {\n       case Token.GETELEM:\n         return true;\n \n-      case Token.FUNCTION:\n         // Anonymous functions definitions are not changed by side-effects,\n         // and named functions are not part of expressions.\n-        Preconditions.checkState(NodeUtil.isAnonymousFunction(n));\n-        return false;\n     }\n \n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\ndiff --git a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\nindex 894d65ba2..55afa6078 100644\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n@@ -174,9 +174,11 @@ class PureFunctionIdentifier implements CompilerPass {\n    */\n   private static Collection<Definition> getCallableDefinitions(\n       DefinitionProvider definitionProvider, Node name) {\n-    if (NodeUtil.isGetProp(name) || NodeUtil.isName(name)) {\n       List<Definition> result = Lists.newArrayList();\n \n+      if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n+        return null;\n+      }\n       Collection<Definition> decls =\n           definitionProvider.getDefinitionsReferencedAt(name);\n       if (decls == null) {\n@@ -193,27 +195,6 @@ class PureFunctionIdentifier implements CompilerPass {\n       }\n \n       return result;\n-    } else if (name.getType() == Token.OR || name.getType() == Token.HOOK) {\n-      Node firstVal;\n-      if (name.getType() == Token.HOOK) {\n-        firstVal = name.getFirstChild().getNext();\n-      } else {\n-        firstVal = name.getFirstChild();\n-      }\n-\n-      Collection<Definition> defs1 = getCallableDefinitions(definitionProvider,\n-                                                            firstVal);\n-      Collection<Definition> defs2 = getCallableDefinitions(definitionProvider,\n-                                                            firstVal.getNext());\n-      if (defs1 != null && defs2 != null) {\n-        defs1.addAll(defs2);\n-        return defs1;\n-      } else {\n-        return null;\n-      }\n-    } else {\n-      return null;\n-    }\n   }\n \n   /**\n"}
{"identifier": "Cli-17", "buggy_code": "    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex 1792c99..cafcede 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -300,7 +300,6 @@ public class PosixParser extends Parser {\n             else if (stopAtNonOption)\n             {\n                 process(token.substring(i));\n-                break;\n             }\n             else\n             {\n"}
{"identifier": "Jsoup-36", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex 33457c3..f07173c 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -7,7 +7,6 @@ import org.jsoup.parser.Parser;\n import java.io.*;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n-import java.nio.charset.IllegalCharsetNameException;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import java.util.Locale;\n@@ -17,7 +16,7 @@ import java.util.Locale;\n  *\n  */\n public class DataUtil {\n-    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n+    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n     private static final int bufferSize = 0x20000; // ~130K.\n \n@@ -85,21 +84,11 @@ public class DataUtil {\n                 String foundCharset;\n                 if (meta.hasAttr(\"http-equiv\")) {\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                        try {\n-                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                                foundCharset = meta.attr(\"charset\");\n-                            }\n-                        } catch (IllegalCharsetNameException e) {\n-                            foundCharset = null;\n-                        }\n-                    }\n                 } else {\n                     foundCharset = meta.attr(\"charset\");\n                 }\n \n                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n-                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                     charsetName = foundCharset;\n                     byteData.rewind();\n                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n@@ -169,16 +158,10 @@ public class DataUtil {\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n-            charset = charset.replace(\"charset=\", \"\");\n-            if (charset.isEmpty()) return null;\n-            try {\n                 if (Charset.isSupported(charset)) return charset;\n                 charset = charset.toUpperCase(Locale.ENGLISH);\n                 if (Charset.isSupported(charset)) return charset;\n-            } catch (IllegalCharsetNameException e) {\n                 // if our advanced charset matching fails.... we just take the default\n-                return null;\n-            }\n         }\n         return null;\n     }\n"}
{"identifier": "Closure-64", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 45d88ba..71f76d8 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1429,7 +1429,7 @@ public class Compiler extends AbstractCompiler {\n \n         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n         // for the first input file\n-        String code = toSource(root, sourceMap, inputSeqNum == 0);\n+        String code = toSource(root, sourceMap);\n         if (!code.isEmpty()) {\n           cb.append(code);\n \n@@ -1458,19 +1458,19 @@ public class Compiler extends AbstractCompiler {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n-    return toSource(n, null, true);\n+    return toSource(n, null);\n   }\n \n   /**\n    * Generates JavaScript source code for an AST.\n    */\n-  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n+  private String toSource(Node n, SourceMap sourceMap) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n-    builder.setTagAsStrict(firstOutput &&\n+    builder.setTagAsStrict(\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);\n \n"}
{"identifier": "Jsoup-1", "buggy_code": "    // does not recurse.\n    private void normalise(Element element) {\n        List<Node> toMove = new ArrayList<Node>();\n        for (Node node: element.childNodes) {\n            if (node instanceof TextNode) {\n                TextNode tn = (TextNode) node;\n                if (!tn.isBlank())\n                    toMove.add(tn);\n            }\n        }\n\n        for (Node node: toMove) {\n            element.removeChild(node);\n            body().appendChild(new TextNode(\" \", \"\"));\n            body().appendChild(node);\n        }\n    }\n", "fixed_code": "    // does not recurse.\n    private void normalise(Element element) {\n        List<Node> toMove = new ArrayList<Node>();\n        for (Node node: element.childNodes) {\n            if (node instanceof TextNode) {\n                TextNode tn = (TextNode) node;\n                if (!tn.isBlank())\n                    toMove.add(tn);\n            }\n        }\n\n        for (Node node: toMove) {\n            element.removeChild(node);\n            body().prependChild(node);\n            body().prependChild(new TextNode(\" \", \"\"));\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// does not recurse.\n    private void normalise(Element element)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Document.java b/src/main/java/org/jsoup/nodes/Document.java\nindex 6ed4c12..bc0f650 100644\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n@@ -122,8 +122,8 @@ public class Document extends Element {\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().prependChild(node);\n-            body().prependChild(new TextNode(\" \", \"\"));\n+            body().appendChild(new TextNode(\" \", \"\"));\n+            body().appendChild(node);\n         }\n     }\n \n"}
{"identifier": "Closure-4", "buggy_code": "  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      finishPropertyContinuations();\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n      finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }\n", "fixed_code": "  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectInheritanceCycle()) {\n      handleTypeCycle(t);\n    }\n\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      finishPropertyContinuations();\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    resolveViaProperties(t, enclosing);\n    if (detectInheritanceCycle()) {\n      handleTypeCycle(t);\n    }\n\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n      finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/NamedType.java b/src/com/google/javascript/rhino/jstype/NamedType.java\nindex 06988ab..70142c4 100644\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n@@ -187,7 +187,7 @@ class NamedType extends ProxyObjectType {\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n     boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectInheritanceCycle()) {\n+    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }\n \n@@ -199,7 +199,7 @@ class NamedType extends ProxyObjectType {\n     }\n \n     resolveViaProperties(t, enclosing);\n-    if (detectInheritanceCycle()) {\n+    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }\n \n"}
{"identifier": "Jsoup-8", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java\nindex 71e6ff0..084ce12 100644\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n@@ -360,13 +360,10 @@ public abstract class Node {\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n+        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n-    private Document.OutputSettings getOutputSettings() {\n-        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n-    }\n \n     /**\n      Get the outer HTML of this node.\n"}
{"identifier": "Closure-96", "buggy_code": "  /**\n   * Visits the parameters of a CALL or a NEW node.\n   */\n  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           parameters.hasNext()) {\n      // If there are no parameters left in the list, then the while loop\n      // above implies that this must be a var_args function.\n        parameter = parameters.next();\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }\n", "fixed_code": "  /**\n   * Visits the parameters of a CALL or a NEW node.\n   */\n  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    while (arguments.hasNext() &&\n           (parameters.hasNext() ||\n            parameter != null && parameter.isVarArgs())) {\n      // If there are no parameters left in the list, then the while loop\n      // above implies that this must be a var_args function.\n      if (parameters.hasNext()) {\n        parameter = parameters.next();\n      }\n      argument = arguments.next();\n      ordinal++;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              String.valueOf(numArgs), String.valueOf(minArgs),\n              maxArgs != Integer.MAX_VALUE ?\n              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Visits the parameters of a CALL or a NEW node.\n   */\n  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex b05fbc4..8077e0d 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1406,13 +1406,10 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           (parameters.hasNext() ||\n-            parameter != null && parameter.isVarArgs())) {\n+           parameters.hasNext()) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n-      if (parameters.hasNext()) {\n         parameter = parameters.next();\n-      }\n       argument = arguments.next();\n       ordinal++;\n \n"}
{"identifier": "Compress-19", "buggy_code": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\nindex fbcec484..134871be 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n@@ -256,7 +256,7 @@ public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n                 + (hasCompressedSize ? DWORD : 0)\n                 + (hasRelativeHeaderOffset ? DWORD : 0)\n                 + (hasDiskStart ? WORD : 0);\n-            if (rawCentralDirectoryData.length < expectedLength) {\n+            if (rawCentralDirectoryData.length != expectedLength) {\n                 throw new ZipException(\"central directory zip64 extended\"\n                                        + \" information extra field's length\"\n                                        + \" doesn't match central directory\"\n"}
{"identifier": "Jsoup-55", "buggy_code": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeAttributeName);\n            }\n        }\n", "fixed_code": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid read(Tokeniser t, CharacterReader r)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex 2e998d5..3a2ac1f 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -880,7 +880,6 @@ enum TokeniserState {\n                     break;\n                 default:\n                     t.error(this);\n-                    r.unconsume();\n                     t.transition(BeforeAttributeName);\n             }\n         }\n"}
{"identifier": "Closure-1", "buggy_code": "  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n", "fixed_code": "  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n    if (!removeGlobals) {\n      return;\n    }\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex 4c84735..dfad51b 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,9 +376,6 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n-    if (!removeGlobals) {\n-      return;\n-    }\n \n     Node function = fnScope.getRootNode();\n \n"}
{"identifier": "Closure-53", "buggy_code": "    /**\n     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n     * Note that the resulting expression will always evaluate to\n     * true, as would the x = {...} expression.\n     */\n    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n      }\n\n      // TODO(user): Better source information.\n      for (String var : all) {\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)),\n                   NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n        // All assignments evaluate to true, so make sure that the\n        // expr statement evaluates to true in case it matters.\n        nodes.add(new Node(Token.TRUE));\n\n        // Join these using COMMA.  A COMMA node must have 2 children, so we\n        // create a tree. In the tree the first child be the COMMA to match\n        // the parser, otherwise tree equality tests fail.\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }\n", "fixed_code": "    /**\n     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n     * Note that the resulting expression will always evaluate to\n     * true, as would the x = {...} expression.\n     */\n    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n      }\n\n      // TODO(user): Better source information.\n      for (String var : all) {\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)),\n                   NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = new Node(Token.TRUE);\n      } else {\n        // All assignments evaluate to true, so make sure that the\n        // expr statement evaluates to true in case it matters.\n        nodes.add(new Node(Token.TRUE));\n\n        // Join these using COMMA.  A COMMA node must have 2 children, so we\n        // create a tree. In the tree the first child be the COMMA to match\n        // the parser, otherwise tree equality tests fail.\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n      }\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Replaces an assignment like x =\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex d92b16c..9061925 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -328,9 +328,6 @@ class InlineObjectLiterals implements CompilerPass {\n       }\n \n       Node replacement;\n-      if (nodes.isEmpty()) {\n-        replacement = new Node(Token.TRUE);\n-      } else {\n         // All assignments evaluate to true, so make sure that the\n         // expr statement evaluates to true in case it matters.\n         nodes.add(new Node(Token.TRUE));\n@@ -350,7 +347,6 @@ class InlineObjectLiterals implements CompilerPass {\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n-      }\n \n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);\n"}
{"identifier": "Compress-9", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\nindex 53d44502..15beec89 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n@@ -105,16 +105,7 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n     }\n \n \n-    @Deprecated\n-    @Override\n-    public int getCount() {\n-        return (int) getBytesWritten();\n-    }\n \n-    @Override\n-    public long getBytesWritten() {\n-        return ((CountingOutputStream) out).getBytesWritten();\n-    }\n \n     /**\n      * Ends the TAR archive without closing the underlying OutputStream.\n@@ -336,6 +327,7 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n             numToWrite -= num;\n             wOffset += num;\n         }\n+        count(numToWrite);\n     }\n \n     /**\n"}
{"identifier": "Closure-69", "buggy_code": "  /**\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n\n    // A couple of types can be called as if they were functions.\n    // If it is a function type, then validate parameters.\n    if (childType instanceof FunctionType) {\n      FunctionType functionType = (FunctionType) childType;\n\n      boolean isExtern = false;\n      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n      if(functionJSDocInfo != null) {\n        String sourceName = functionJSDocInfo.getSourceName();\n        CompilerInput functionSource = compiler.getInput(sourceName);\n        isExtern = functionSource.isExtern();\n      }\n\n      // Non-native constructors should not be called directly\n      // unless they specify a return type and are defined\n      // in an extern.\n      if (functionType.isConstructor() &&\n          !functionType.isNativeObjectType() &&\n          (functionType.getReturnType().isUnknownType() ||\n           functionType.getReturnType().isVoidType() ||\n           !isExtern)) {\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n      }\n\n      // Functions with explcit 'this' types must be called in a GETPROP\n      // or GETELEM.\n\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());\n    } else {\n      ensureTyped(t, n);\n    }\n\n    // TODO: Add something to check for calls of RegExp objects, which is not\n    // supported by IE.  Either say something about the return type or warn\n    // about the non-portability of the call or both.\n  }\n", "fixed_code": "  /**\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n\n    // A couple of types can be called as if they were functions.\n    // If it is a function type, then validate parameters.\n    if (childType instanceof FunctionType) {\n      FunctionType functionType = (FunctionType) childType;\n\n      boolean isExtern = false;\n      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n      if(functionJSDocInfo != null) {\n        String sourceName = functionJSDocInfo.getSourceName();\n        CompilerInput functionSource = compiler.getInput(sourceName);\n        isExtern = functionSource.isExtern();\n      }\n\n      // Non-native constructors should not be called directly\n      // unless they specify a return type and are defined\n      // in an extern.\n      if (functionType.isConstructor() &&\n          !functionType.isNativeObjectType() &&\n          (functionType.getReturnType().isUnknownType() ||\n           functionType.getReturnType().isVoidType() ||\n           !isExtern)) {\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n      }\n\n      // Functions with explcit 'this' types must be called in a GETPROP\n      // or GETELEM.\n      if (functionType.isOrdinaryFunction() &&\n          !functionType.getTypeOfThis().isUnknownType() &&\n          !functionType.getTypeOfThis().isNativeObjectType() &&\n          !(child.getType() == Token.GETELEM ||\n            child.getType() == Token.GETPROP)) {\n        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n      }\n\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());\n    } else {\n      ensureTyped(t, n);\n    }\n\n    // TODO: Add something to check for calls of RegExp objects, which is not\n    // supported by IE.  Either say something about the return type or warn\n    // about the non-portability of the call or both.\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitCall(NodeTraversal t, Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 5edb4f0..f58418c 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,13 +1577,6 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n-      if (functionType.isOrdinaryFunction() &&\n-          !functionType.getTypeOfThis().isUnknownType() &&\n-          !functionType.getTypeOfThis().isNativeObjectType() &&\n-          !(child.getType() == Token.GETELEM ||\n-            child.getType() == Token.GETPROP)) {\n-        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n-      }\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());\n"}
{"identifier": "Csv-11", "buggy_code": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n", "fixed_code": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex b7ca3fa..b6867a4 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -381,7 +381,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n+                    final boolean emptyHeader = header.trim().isEmpty();\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n"}
{"identifier": "JacksonDatabind-34", "buggy_code": "    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n", "fixed_code": "    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\nindex 13118a0ee..5624624af 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n@@ -78,7 +78,7 @@ public class NumberSerializer\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n+                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n"}
{"identifier": "Csv-1", "buggy_code": "    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\n') {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n", "fixed_code": "    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public int read() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\nindex 219fe68..563ece1 100644\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n@@ -55,7 +55,7 @@ class ExtendedBufferedReader extends BufferedReader {\n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n+        if (current == '\\n') {\n             lineCounter++;\n         }\n         lastChar = current;\n"}
{"identifier": "Collections-28", "buggy_code": "", "fixed_code": "        @Override\n        public void clear() {\n            Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n            Set<K> currentKeys = keySet();\n            while (it.hasNext()) {\n                if (currentKeys.contains(it.next().getKey())) {\n                    it.remove();\n                }\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\nindex bd11f75b..41f8535d 100644\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\n@@ -2259,16 +2259,6 @@ abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n             return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n         }\n \n-        @Override\n-        public void clear() {\n-            Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n-            Set<K> currentKeys = keySet();\n-            while (it.hasNext()) {\n-                if (currentKeys.contains(it.next().getKey())) {\n-                    it.remove();\n-                }\n-            }\n-        }\n     }\n \n     /**\n"}
{"identifier": "JacksonDatabind-107", "buggy_code": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                    //   generic type with custom type resolvers. If so, should try to retain them.\n                    //  Whether this is sufficient to avoid problems remains to be seen, but for\n                    //  now it should improve things.\n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n", "fixed_code": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                        return NullifyingDeserializer.instance;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                    //   generic type with custom type resolvers. If so, should try to retain them.\n                    //  Whether this is sufficient to avoid problems remains to be seen, but for\n                    //  now it should improve things.\n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\nindex 58f1a5f9a..dfef4589f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n@@ -162,7 +162,7 @@ public abstract class TypeDeserializerBase\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return NullifyingDeserializer.instance;\n+                        return null;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n"}
{"identifier": "Closure-147", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex 604526e6..d63c72b1 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -105,8 +105,7 @@ final class CheckGlobalThis implements Callback {\n       if (!(pType == Token.BLOCK ||\n             pType == Token.SCRIPT ||\n             pType == Token.NAME ||\n-            pType == Token.ASSIGN ||\n-            pType == Token.OBJECTLIT)) {\n+            pType == Token.ASSIGN)) {\n         return false;\n       }\n     }\ndiff --git a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\nold mode 100755\nnew mode 100644\ndiff --git a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\nindex 5cedf1e0..ed4a6b9a 100644\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n@@ -244,11 +244,6 @@ class RuntimeTypeCheck implements CompilerPass {\n \n       // To satisfy normalization constraints, the type checking must be\n       // added after any inner function declarations.\n-      for (Node next = block.getFirstChild();\n-           next != null && NodeUtil.isFunctionDeclaration(next);\n-           next = next.getNext()) {\n-        insertionPoint = next;\n-      }\n \n       for (Node paramType : funType.getParameters()) {\n         // Can this ever happen?\ndiff --git a/src/com/google/javascript/jscomp/SourceInformationAnnotator.java b/src/com/google/javascript/jscomp/SourceInformationAnnotator.java\nold mode 100755\nnew mode 100644\ndiff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nold mode 100755\nnew mode 100644\ndiff --git a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\nold mode 100755\nnew mode 100644\n"}
{"identifier": "Gson-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex 838355cb..214df65e 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -571,6 +571,9 @@ public class JsonReader implements Closeable {\n       checkLenient();\n       return peeked = PEEKED_SINGLE_QUOTED;\n     case '\"':\n+      if (stackSize == 1) {\n+        checkLenient();\n+      }\n       return peeked = PEEKED_DOUBLE_QUOTED;\n     case '[':\n       return peeked = PEEKED_BEGIN_ARRAY;\n@@ -579,6 +582,9 @@ public class JsonReader implements Closeable {\n     default:\n       pos--; // Don't consume the first character in a literal value.\n     }\n+    if (stackSize == 1) {\n+      checkLenient();\n+    }\n \n     int result = peekKeyword();\n     if (result != PEEKED_NONE) {\ndiff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\nindex 9bf2d22a..d76f7c10 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n@@ -322,7 +322,7 @@ public class JsonWriter implements Closeable, Flushable {\n    * bracket.\n    */\n   private JsonWriter open(int empty, String openBracket) throws IOException {\n-    beforeValue();\n+    beforeValue(true);\n     push(empty);\n     out.write(openBracket);\n     return this;\n@@ -415,7 +415,7 @@ public class JsonWriter implements Closeable, Flushable {\n       return nullValue();\n     }\n     writeDeferredName();\n-    beforeValue();\n+    beforeValue(false);\n     string(value);\n     return this;\n   }\n@@ -432,7 +432,7 @@ public class JsonWriter implements Closeable, Flushable {\n       return nullValue();\n     }\n     writeDeferredName();\n-    beforeValue();\n+    beforeValue(false);\n     out.append(value);\n     return this;\n   }\n@@ -451,7 +451,7 @@ public class JsonWriter implements Closeable, Flushable {\n         return this; // skip the name and the value\n       }\n     }\n-    beforeValue();\n+    beforeValue(false);\n     out.write(\"null\");\n     return this;\n   }\n@@ -463,7 +463,7 @@ public class JsonWriter implements Closeable, Flushable {\n    */\n   public JsonWriter value(boolean value) throws IOException {\n     writeDeferredName();\n-    beforeValue();\n+    beforeValue(false);\n     out.write(value ? \"true\" : \"false\");\n     return this;\n   }\n@@ -480,7 +480,7 @@ public class JsonWriter implements Closeable, Flushable {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     writeDeferredName();\n-    beforeValue();\n+    beforeValue(false);\n     out.append(Double.toString(value));\n     return this;\n   }\n@@ -492,7 +492,7 @@ public class JsonWriter implements Closeable, Flushable {\n    */\n   public JsonWriter value(long value) throws IOException {\n     writeDeferredName();\n-    beforeValue();\n+    beforeValue(false);\n     out.write(Long.toString(value));\n     return this;\n   }\n@@ -515,7 +515,7 @@ public class JsonWriter implements Closeable, Flushable {\n         && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n-    beforeValue();\n+    beforeValue(false);\n     out.append(string);\n     return this;\n   }\n@@ -610,7 +610,7 @@ public class JsonWriter implements Closeable, Flushable {\n    * closing bracket or another element.\n    */\n   @SuppressWarnings(\"fallthrough\")\n-  private void beforeValue() throws IOException {\n+  private void beforeValue(boolean root) throws IOException {\n     switch (peek()) {\n     case NONEMPTY_DOCUMENT:\n       if (!lenient) {\n@@ -619,6 +619,10 @@ public class JsonWriter implements Closeable, Flushable {\n       }\n       // fall-through\n     case EMPTY_DOCUMENT: // first in document\n+      if (!lenient && !root) {\n+        throw new IllegalStateException(\n+            \"JSON must start with an array or an object.\");\n+      }\n       replaceTop(NONEMPTY_DOCUMENT);\n       break;\n \n"}
{"identifier": "Jsoup-64", "buggy_code": "    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.insert(startTag);\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n    }\n", "fixed_code": "    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n        tb.tokeniser.transition(TokeniserState.Rawtext);\n        tb.markInsertionMode();\n        tb.transition(Text);\n        tb.insert(startTag);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex a9a9583..f4b56f7 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -1486,10 +1486,10 @@ enum HtmlTreeBuilderState {\n     }\n \n     private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n+        tb.insert(startTag);\n         tb.tokeniser.transition(TokeniserState.Rawtext);\n         tb.markInsertionMode();\n         tb.transition(Text);\n-        tb.insert(startTag);\n     }\n \n     // lists of tags to search through. A little harder to read here, but causes less GC than dynamic varargs.\n"}
{"identifier": "Math-18", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 866c8fd..bc754a5 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -929,7 +929,7 @@ public class CMAESOptimizer\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = x[i] / diff;\n+                res[i] = (x[i] - boundaries[0][i]) / diff;\n             }\n             return res;\n         }\n@@ -955,7 +955,7 @@ public class CMAESOptimizer\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i];\n+                res[i] = diff * x[i] + boundaries[0][i];\n             }\n             return res;\n         }\n@@ -987,14 +987,12 @@ public class CMAESOptimizer\n                 return true;\n             }\n \n-            final double[] bLoEnc = encode(boundaries[0]);\n-            final double[] bHiEnc = encode(boundaries[1]);\n \n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < bLoEnc[i]) {\n+                if (x[i] < 0) {\n                     return false;\n                 }\n-                if (x[i] > bHiEnc[i]) {\n+                if (x[i] > 1.0) {\n                     return false;\n                 }\n             }\n"}
{"identifier": "Mockito-38", "buggy_code": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }\n", "fixed_code": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate boolean toStringEquals(Matcher m, Object arg)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 9d4f834..671fbc5 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -45,6 +45,6 @@ public class ArgumentMatchingTool {\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n+        return StringDescription.toString(m).equals(arg.toString());\n     }\n }\n"}
{"identifier": "Jsoup-93", "buggy_code": "    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n\n            if (\"select\".equals(el.normalName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }\n", "fixed_code": "    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (type.equalsIgnoreCase(\"button\")) continue; // browsers don't submit these\n\n            if (\"select\".equals(el.normalName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/FormElement.java b/src/main/java/org/jsoup/nodes/FormElement.java\nindex 5770289..3949f22 100644\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n@@ -86,7 +86,6 @@ public class FormElement extends Element {\n             if (name.length() == 0) continue;\n             String type = el.attr(\"type\");\n \n-            if (type.equalsIgnoreCase(\"button\")) continue; // browsers don't submit these\n \n             if (\"select\".equals(el.normalName())) {\n                 Elements options = el.select(\"option[selected]\");\n"}
{"identifier": "JacksonDatabind-47", "buggy_code": "    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n                //    static typing this way\n                type = type.withStaticTyping();\n            } else {\n                try {\n                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                    //   may be needed here too in future?\n                        type = tf.constructGeneralizedType(type, serClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                        //   specialize (narrow) type sometimes, even if more commonly opposite\n                        //   is needed.\n                        if (keyClass.isAssignableFrom(currRaw)) { // common case\n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n                   //   specialize (narrow) type sometimes, even if more commonly opposite\n                   //   is needed.\n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { // common case\n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { // shouldn't really happen\n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n", "fixed_code": "    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n                //    static typing this way\n                type = type.withStaticTyping();\n            } else {\n                Class<?> currRaw = type.getRawClass();\n                try {\n                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                    //   may be needed here too in future?\n                    if (serClass.isAssignableFrom(currRaw)) { // common case\n                        type = tf.constructGeneralizedType(type, serClass);\n                    } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n                        type = tf.constructSpecializedType(type, serClass);\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n                                        type, serClass.getName()));\n                    }\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                        //   specialize (narrow) type sometimes, even if more commonly opposite\n                        //   is needed.\n                        if (keyClass.isAssignableFrom(currRaw)) { // common case\n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n                   //   specialize (narrow) type sometimes, even if more commonly opposite\n                   //   is needed.\n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { // common case\n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { // shouldn't really happen\n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\nindex 3966997e9..dab32273e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n@@ -813,19 +813,10 @@ public abstract class AnnotationIntrospector\n                 //    static typing this way\n                 type = type.withStaticTyping();\n             } else {\n-                Class<?> currRaw = type.getRawClass();\n                 try {\n                     // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                     //   may be needed here too in future?\n-                    if (serClass.isAssignableFrom(currRaw)) { // common case\n                         type = tf.constructGeneralizedType(type, serClass);\n-                    } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n-                        type = tf.constructSpecializedType(type, serClass);\n-                    } else {\n-                        throw new JsonMappingException(null,\n-                                String.format(\"Can not refine serialization type %s into %s; types not related\",\n-                                        type, serClass.getName()));\n-                    }\n                 } catch (IllegalArgumentException iae) {\n                     throw new JsonMappingException(null,\n                             String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n"}
{"identifier": "Lang-50", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/time/FastDateFormat.java b/src/java/org/apache/commons/lang/time/FastDateFormat.java\nindex d1caaa8..8a26f28 100644\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -282,14 +282,16 @@ public class FastDateFormat extends Format {\n             key = new Pair(key, timeZone);\n         }\n \n-        if (locale == null) {\n-            locale = Locale.getDefault();\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n         }\n \n-        key = new Pair(key, locale);\n \n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();\n@@ -460,13 +462,15 @@ public class FastDateFormat extends Format {\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n         }\n-        key = new Pair(key, locale);\n \n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);\n"}
{"identifier": "Math-52", "buggy_code": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  // norms computation\n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  // preliminary computation\n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n  if (c == 0) {\n    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n    // we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        // the (q1, q2, q3) vector is aligned with everything\n        // this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      // we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }\n\n  // compute the vectorial part\n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  // compute the scalar part\n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }\n", "fixed_code": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  // norms computation\n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  // preliminary computation\n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n  final double inPlaneThreshold = 0.001;\n  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n    // we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c <= 0) {\n        // the (q1, q2, q3) vector is aligned with everything\n        // this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      // we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }\n\n  // compute the vectorial part\n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  // compute the scalar part\n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\nindex ada0a8f..20f5b34 100644\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n@@ -341,8 +341,7 @@ public class Rotation implements Serializable {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  final double inPlaneThreshold = 0.001;\n-  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n+  if (c == 0) {\n     // the (q1, q2, q3) vector is close to the (u1, u2) plane\n     // we try other vectors\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n@@ -351,13 +350,13 @@ public class Rotation implements Serializable {\n     Vector3D u2Prime = u1.crossProduct(u3);\n     c = k.dotProduct(u2Prime);\n \n-    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n+    if (c == 0) {\n       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n       k = v2Su2.crossProduct(v3Su3);;\n       c = k.dotProduct(u2.crossProduct(u3));;\n \n-      if (c <= 0) {\n+      if (c == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n"}
{"identifier": "Compress-29", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\nindex c73e665f..6bd8f031 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n@@ -294,11 +294,7 @@ public class ArchiveStreamFactory {\n             }\n         }\n         if (JAR.equalsIgnoreCase(archiverName)) {\n-            if (entryEncoding != null) {\n-                return new JarArchiveOutputStream(out, entryEncoding);\n-            } else {\n                 return new JarArchiveOutputStream(out);\n-            }\n         }\n         if (CPIO.equalsIgnoreCase(archiverName)) {\n             if (entryEncoding != null) {\n@@ -361,11 +357,7 @@ public class ArchiveStreamFactory {\n                     return new CpioArchiveInputStream(in);\n                 }\n             } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n-                if (entryEncoding != null) {\n-                    return new ArjArchiveInputStream(in, entryEncoding);\n-                } else {\n                     return new ArjArchiveInputStream(in);\n-                }\n             } else if (SevenZFile.matches(signature, signatureLength)) {\n                 throw new StreamingNotSupportedException(SEVEN_Z);\n             }\ndiff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\nindex 915b56e5..1ad5f10e 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java\n@@ -94,7 +94,6 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n     private final ZipEncoding zipEncoding;\n \n     // the provided encoding (for unit tests)\n-    final String encoding;\n \n     /**\n      * Construct the cpio input stream with a blocksize of {@link\n@@ -153,7 +152,6 @@ public class CpioArchiveInputStream extends ArchiveInputStream implements\n     public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n         this.in = in;\n         this.blockSize = blockSize;\n-        this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     }\n \ndiff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\nindex fc829ffa..d2d12826 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java\n@@ -95,7 +95,6 @@ public class CpioArchiveOutputStream extends ArchiveOutputStream implements\n     private final ZipEncoding zipEncoding;\n \n     // the provided encoding (for unit tests)\n-    final String encoding;\n \n     /**\n      * Construct the cpio output stream with a specified format, a\n@@ -160,7 +159,6 @@ public class CpioArchiveOutputStream extends ArchiveOutputStream implements\n         }\n         this.entryFormat = format;\n         this.blockSize = blockSize;\n-        this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     }\n \ndiff --git a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\nindex 09431a40..84c78396 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java\n@@ -77,7 +77,6 @@ public class DumpArchiveInputStream extends ArchiveInputStream {\n     private final ZipEncoding zipEncoding;\n \n     // the provided encoding (for unit tests)\n-    final String encoding;\n \n     /**\n      * Constructor using the platform's default encoding for file\n@@ -102,7 +101,6 @@ public class DumpArchiveInputStream extends ArchiveInputStream {\n         throws ArchiveException {\n         this.raw = new TapeInputStream(is);\n         this.hasHitEOF = false;\n-        this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n \n         try {\ndiff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex c5570071..b3cd0d61 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -76,7 +76,6 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n     private final ZipEncoding zipEncoding;\n \n     // the provided encoding (for unit tests)\n-    final String encoding;\n \n     /**\n      * Constructor for TarInputStream.\n@@ -140,7 +139,6 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n                                  String encoding) {\n         this.is = is;\n         this.hasHitEOF = false;\n-        this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.recordSize = recordSize;\n         this.blockSize = blockSize;\ndiff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\nindex 43525c8c..96ec740c 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n@@ -87,7 +87,6 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n     private final ZipEncoding zipEncoding;\n \n     // the provided encoding (for unit tests)\n-    final String encoding;\n \n     private boolean addPaxHeadersForNonAsciiNames = false;\n     private static final ZipEncoding ASCII =\n@@ -153,7 +152,6 @@ public class TarArchiveOutputStream extends ArchiveOutputStream {\n     public TarArchiveOutputStream(OutputStream os, int blockSize,\n                                   int recordSize, String encoding) {\n         out = new CountingOutputStream(os);\n-        this.encoding = encoding;\n         this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n \n         this.assemLen = 0;\ndiff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\nindex 7a69141c..711c149a 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java\n@@ -62,7 +62,6 @@ public class ZipArchiveInputStream extends ArchiveInputStream {\n     private final ZipEncoding zipEncoding;\n \n     // the provided encoding (for unit tests)\n-    final String encoding;\n \n     /** Whether to look for and use Unicode extra fields. */\n     private final boolean useUnicodeExtraFields;\n@@ -182,7 +181,6 @@ public class ZipArchiveInputStream extends ArchiveInputStream {\n                                  String encoding,\n                                  boolean useUnicodeExtraFields,\n                                  boolean allowStoredEntriesWithDataDescriptor) {\n-        this.encoding = encoding;\n         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n         this.useUnicodeExtraFields = useUnicodeExtraFields;\n         in = new PushbackInputStream(inputStream, buf.capacity());\n"}
{"identifier": "Cli-30", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 2f957b1..bfea0e4 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -147,18 +147,12 @@ public class DefaultParser implements CommandLineParser\n         {\n             String option = e.nextElement().toString();\n             \n-            Option opt = options.getOption(option);\n-            if (opt == null)\n+            if (!cmd.hasOption(option))\n             {\n-                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n-            }\n+                Option opt = options.getOption(option);\n             \n             // if the option is part of a group, check if another option of the group has been selected\n-            OptionGroup group = options.getOptionGroup(opt);\n-            boolean selected = group != null && group.getSelected() != null;\n             \n-            if (!cmd.hasOption(option) && !selected)\n-            {\n                 // get the value from the properties\n                 String value = properties.getProperty(option);\n                 \ndiff --git a/src/main/java/org/apache/commons/cli/Parser.java b/src/main/java/org/apache/commons/cli/Parser.java\nindex ba4b6bc..913922d 100644\n--- a/src/main/java/org/apache/commons/cli/Parser.java\n+++ b/src/main/java/org/apache/commons/cli/Parser.java\n@@ -260,18 +260,12 @@ public abstract class Parser implements CommandLineParser\n         {\n             String option = e.nextElement().toString();\n             \n-            Option opt = options.getOption(option);\n-            if (opt == null)\n+            if (!cmd.hasOption(option))\n             {\n-                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n-            }\n+                Option opt = getOptions().getOption(option);\n             \n             // if the option is part of a group, check if another option of the group has been selected\n-            OptionGroup group = options.getOptionGroup(opt);\n-            boolean selected = group != null && group.getSelected() != null;\n             \n-            if (!cmd.hasOption(option) && !selected)\n-            {\n                 // get the value from the properties instance\n                 String value = properties.getProperty(option);\n \n"}
{"identifier": "Closure-154", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 41b94e0c..a752e76a 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -182,6 +182,13 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n           \"original: {2}\\n\" +\n           \"override: {3}\");\n \n+  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH =\n+      DiagnosticType.warning(\n+          \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\",\n+          \"mismatch of the {0} property type and the type \" +\n+          \"of the property it overrides from interface {1}\\n\" +\n+          \"original: {2}\\n\" +\n+          \"override: {3}\");\n   static final DiagnosticType UNKNOWN_OVERRIDE =\n       DiagnosticType.warning(\n           \"JSC_UNKNOWN_OVERRIDE\",\n@@ -232,6 +239,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       HIDDEN_SUPERCLASS_PROPERTY,\n       HIDDEN_INTERFACE_PROPERTY,\n       HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n+      HIDDEN_INTERFACE_PROPERTY_MISMATCH,\n       UNKNOWN_OVERRIDE,\n       INTERFACE_METHOD_OVERRIDE,\n       UNKNOWN_EXPR_TYPE,\n@@ -1038,6 +1046,16 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n               HIDDEN_INTERFACE_PROPERTY, propertyName,\n               interfaceType.getTopMostDefiningType(propertyName).toString()));\n         }\n+        if (interfaceHasProperty) {\n+          JSType interfacePropType =\n+              interfaceType.getPrototype().getPropertyType(propertyName);\n+          if (!propertyType.canAssignTo(interfacePropType)) {\n+            compiler.report(t.makeError(n,\n+                HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,\n+                interfaceType.getTopMostDefiningType(propertyName).toString(),\n+                interfacePropType.toString(), propertyType.toString()));\n+          }\n+        }\n       }\n     }\n \ndiff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java\nindex 24bf792f..1d585226 100644\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -107,13 +107,6 @@ class TypeValidator {\n           \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\",\n           \"property {0} on interface {1} is not implemented by type {2}\");\n \n-  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH =\n-      DiagnosticType.warning(\n-        \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\",\n-        \"mismatch of the {0} property type and the type \" +\n-        \"of the property it overrides from interface {1}\\n\" +\n-        \"original: {2}\\n\" +\n-        \"override: {3}\");\n \n   static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n       INVALID_CAST,\n@@ -121,8 +114,7 @@ class TypeValidator {\n       MISSING_EXTENDS_TAG_WARNING,\n       DUP_VAR_DECLARATION,\n       HIDDEN_PROPERTY_MISMATCH,\n-      INTERFACE_METHOD_NOT_IMPLEMENTED,\n-      HIDDEN_INTERFACE_PROPERTY_MISMATCH);\n+      INTERFACE_METHOD_NOT_IMPLEMENTED);\n \n   TypeValidator(AbstractCompiler compiler) {\n     this.compiler = compiler;\n@@ -593,24 +585,7 @@ class TypeValidator {\n             prop, implementedInterface.toString(), instance.toString()));\n       }\n       registerMismatch(instance, implementedInterface);\n-    } else {\n-      JSType found = instance.getPropertyType(prop);\n-      JSType required\n-        = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n-      found = found.restrictByNotNullOrUndefined();\n-      required = required.restrictByNotNullOrUndefined();\n-      if (!found.canAssignTo(required)) {\n         // Implemented, but not correctly typed\n-        if (shouldReport) {\n-          FunctionType constructor\n-            = implementedInterface.toObjectType().getConstructor();\n-          compiler.report(t.makeError(n,\n-              HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n-              constructor.getTopMostDefiningType(prop).toString(),\n-              required.toString(), found.toString()));\n-        }\n-        registerMismatch(found, required);\n-      }\n     }\n   }\n \n"}
{"identifier": "JacksonDatabind-110", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java\nindex f16d95e42..3228bacda 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java\n@@ -44,7 +44,6 @@ public abstract class JavaUtilCollectionsDeserializers\n     /* 02-Mar-2019, tatu: for [databind#2265], need to consider possible alternate type...\n      *    which we essentially coerce into the other one\n      */\n-    private final static Class<?> CLASS_UNMODIFIABLE_LIST_ALIAS;\n     private final static Class<?> CLASS_UNMODIFIABLE_MAP;\n \n     static {\n@@ -56,7 +55,6 @@ public abstract class JavaUtilCollectionsDeserializers\n         CLASS_SINGLETON_LIST = list.getClass();\n         CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();\n         // for [databind#2265]\n-        CLASS_UNMODIFIABLE_LIST_ALIAS = Collections.unmodifiableList(new LinkedList<Object>()).getClass();\n         \n         Map<?,?> map = Collections.singletonMap(\"a\", \"b\");\n         CLASS_SINGLETON_MAP = map.getClass();\n@@ -77,7 +75,7 @@ public abstract class JavaUtilCollectionsDeserializers\n         } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n             conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n         // [databind#2265]: we may have another impl type for unmodifiable Lists, check both\n-        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST) || type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS)) {\n+        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n             conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n         } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n             conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n"}
{"identifier": "JacksonDatabind-99", "buggy_code": "    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        return sb.toString();\n    }\n", "fixed_code": "    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        sb.append('>');\n        return sb.toString();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    protected String buildCanonicalName()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\nindex e8c69628c..4add34ee0 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n@@ -166,7 +166,6 @@ public class ReferenceType extends SimpleType\n         sb.append(_class.getName());\n         sb.append('<');\n         sb.append(_referencedType.toCanonical());\n-        sb.append('>');\n         return sb.toString();\n     }\n \n"}
{"identifier": "Chart-21", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java b/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java\nindex a973da9..7fd86f4 100644\n--- a/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java\n+++ b/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java\n@@ -154,7 +154,6 @@ public class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n                 && this.minimumRangeValueColumn == c))  {\n             updateBounds();\n         }\n-        else {\n         \n             double minval = Double.NaN;\n             if (item.getMinOutlier() != null) {\n@@ -186,7 +185,6 @@ public class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n                 this.minimumRangeValueRow = r;\n                 this.minimumRangeValueColumn = c;\n             }\n-        }\n         \n         this.rangeBounds = new Range(this.minimumRangeValue,\n               this.maximumRangeValue);\n@@ -740,44 +738,7 @@ public class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n      */\n     private void updateBounds() {\n         this.minimumRangeValue = Double.NaN;\n-        this.minimumRangeValueRow = -1;\n-        this.minimumRangeValueColumn = -1;\n         this.maximumRangeValue = Double.NaN;\n-        this.maximumRangeValueRow = -1;\n-        this.maximumRangeValueColumn = -1;\n-        int rowCount = getRowCount();\n-        int columnCount = getColumnCount();\n-        for (int r = 0; r < rowCount; r++) {\n-            for (int c = 0; c < columnCount; c++) {\n-                BoxAndWhiskerItem item = getItem(r, c);\n-                if (item != null) {\n-                    Number min = item.getMinOutlier();\n-                    if (min != null) {\n-                        double minv = min.doubleValue();\n-                        if (!Double.isNaN(minv)) {\n-                            if (minv < this.minimumRangeValue || Double.isNaN(\n-                                    this.minimumRangeValue)) {\n-                                this.minimumRangeValue = minv;\n-                                this.minimumRangeValueRow = r;\n-                                this.minimumRangeValueColumn = c;\n-                            }\n-                        }\n-                    }\n-                    Number max = item.getMaxOutlier();\n-                    if (max != null) {\n-                        double maxv = max.doubleValue();\n-                        if (!Double.isNaN(maxv)) {\n-                            if (maxv > this.maximumRangeValue || Double.isNaN(\n-                                    this.maximumRangeValue)) {\n-                                this.maximumRangeValue = maxv;\n-                                this.maximumRangeValueRow = r;\n-                                this.maximumRangeValueColumn = c;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n     }\n     \n     /**\n"}
{"identifier": "Chart-25", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\nindex 6ff5e36..ab65ba3 100644\n--- a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n@@ -256,9 +256,6 @@ public class StatisticalBarRenderer extends BarRenderer\n \n         // BAR X\n         Number meanValue = dataset.getMeanValue(row, column);\n-        if (meanValue == null) {\n-            return;\n-        }\n \n         double value = meanValue.doubleValue();\n         double base = 0.0;\n@@ -315,9 +312,7 @@ public class StatisticalBarRenderer extends BarRenderer\n         }\n \n         // standard deviation lines\n-        Number n = dataset.getStdDevValue(row, column);\n-        if (n != null) {\n-            double valueDelta = n.doubleValue();\n+            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                     + valueDelta, dataArea, yAxisLocation);\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n@@ -346,7 +341,6 @@ public class StatisticalBarRenderer extends BarRenderer\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \n                                      lowVal, rectY + rectHeight * 0.75);\n             g2.draw(line);\n-        }\n         \n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                 column);\n@@ -406,9 +400,6 @@ public class StatisticalBarRenderer extends BarRenderer\n \n         // BAR Y\n         Number meanValue = dataset.getMeanValue(row, column);\n-        if (meanValue == null) {\n-            return;\n-        }\n \n         double value = meanValue.doubleValue();\n         double base = 0.0;\n@@ -465,9 +456,7 @@ public class StatisticalBarRenderer extends BarRenderer\n         }\n \n         // standard deviation lines\n-        Number n = dataset.getStdDevValue(row, column);\n-        if (n != null) {\n-            double valueDelta = n.doubleValue();\n+            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                     + valueDelta, dataArea, yAxisLocation);\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n@@ -495,7 +484,6 @@ public class StatisticalBarRenderer extends BarRenderer\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\n             g2.draw(line);\n-        }\n         \n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                 column);\n"}
{"identifier": "Closure-122", "buggy_code": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }\n", "fixed_code": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n    if (p.matcher(comment.getValue()).find()) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 936af02..709534b 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -249,8 +249,7 @@ class IRFactory {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n-    if (p.matcher(comment.getValue()).find()) {\n+    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n"}
{"identifier": "Closure-65", "buggy_code": "  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n", "fixed_code": "  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\000\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex cb9229a..6117a89 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1012,7 +1012,7 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\000\"); break;\n+        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n"}
{"identifier": "Math-37", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex ed76a29..8d28c5f 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -1015,15 +1015,9 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n      * @since 1.2\n      */\n     public Complex tan() {\n-        if (isNaN || Double.isInfinite(real)) {\n+        if (isNaN) {\n             return NaN;\n         }\n-        if (imaginary > 20.0) {\n-            return createComplex(0.0, 1.0);\n-        }\n-        if (imaginary < -20.0) {\n-            return createComplex(0.0, -1.0);\n-        }\n \n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n@@ -1066,15 +1060,9 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n      * @since 1.2\n      */\n     public Complex tanh() {\n-        if (isNaN || Double.isInfinite(imaginary)) {\n+        if (isNaN) {\n             return NaN;\n         }\n-        if (real > 20.0) {\n-            return createComplex(1.0, 0.0);\n-        }\n-        if (real < -20.0) {\n-            return createComplex(-1.0, 0.0);\n-        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n"}
{"identifier": "Math-94", "buggy_code": "    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * \n     * @param u a non-zero number\n     * @param v a non-zero number\n     * @return the greatest common divisor, never zero\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n        if (u * v == 0) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n", "fixed_code": "    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * \n     * @param u a non-zero number\n     * @param v a non-zero number\n     * @return the greatest common divisor, never zero\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * \n     * @param u a non-zero number\n     * @param v a non-zero number\n     * @return the greatest common divisor, never zero\n     * @since 1.1\n     */\n    public static int gcd(int u, int v)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex df71405..c5342ae 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -409,7 +409,7 @@ public final class MathUtils {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if ((u == 0) || (v == 0)) {\n+        if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n"}
{"identifier": "Cli-12", "buggy_code": "    /**\n     * <p>This flatten method does so using the following rules:\n     * <ol>\n     *  <li>If an {@link Option} exists for the first character of \n     *  the <code>arguments</code> entry <b>AND</b> an {@link Option} \n     *  does not exist for the whole <code>argument</code> then\n     *  add the first character as an option to the processed tokens\n     *  list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     *  <li>Otherwise just add the token to the processed tokens list.\n     *  </li>\n     * </ol>\n     * </p>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        List tokens = new ArrayList();\n\n        boolean eatTheRest = false;\n\n        for (int i = 0; i < arguments.length; i++)\n        {\n            String arg = arguments[i];\n\n            if (\"--\".equals(arg))\n            {\n                eatTheRest = true;\n                tokens.add(\"--\");\n            }\n            else if (\"-\".equals(arg))\n            {\n                tokens.add(\"-\");\n            }\n            else if (arg.startsWith(\"-\"))\n            {\n                String opt = Util.stripLeadingHyphens(arg);\n\n                if (options.hasOption(opt))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    if (options.hasOption(arg.substring(0, 2)))\n                    {\n                        // the format is --foo=value or -foo=value\n                        // the format is a special properties option (-Dproperty=value)\n                        tokens.add(arg.substring(0, 2)); // -D\n                        tokens.add(arg.substring(2)); // property=value\n                    }\n                    else\n                    {\n                        eatTheRest = stopAtNonOption;\n                        tokens.add(arg);\n                    }\n                }\n            }\n            else\n            {\n                tokens.add(arg);\n            }\n\n            if (eatTheRest)\n            {\n                for (i++; i < arguments.length; i++)\n                {\n                    tokens.add(arguments[i]);\n                }\n            }\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n", "fixed_code": "    /**\n     * <p>This flatten method does so using the following rules:\n     * <ol>\n     *  <li>If an {@link Option} exists for the first character of \n     *  the <code>arguments</code> entry <b>AND</b> an {@link Option} \n     *  does not exist for the whole <code>argument</code> then\n     *  add the first character as an option to the processed tokens\n     *  list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     *  <li>Otherwise just add the token to the processed tokens list.\n     *  </li>\n     * </ol>\n     * </p>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        List tokens = new ArrayList();\n\n        boolean eatTheRest = false;\n\n        for (int i = 0; i < arguments.length; i++)\n        {\n            String arg = arguments[i];\n\n            if (\"--\".equals(arg))\n            {\n                eatTheRest = true;\n                tokens.add(\"--\");\n            }\n            else if (\"-\".equals(arg))\n            {\n                tokens.add(\"-\");\n            }\n            else if (arg.startsWith(\"-\"))\n            {\n                String opt = Util.stripLeadingHyphens(arg);\n\n                if (options.hasOption(opt))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n                    {\n                        // the format is --foo=value or -foo=value\n                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n                    }\n                    else if (options.hasOption(arg.substring(0, 2)))\n                    {\n                        // the format is a special properties option (-Dproperty=value)\n                        tokens.add(arg.substring(0, 2)); // -D\n                        tokens.add(arg.substring(2)); // property=value\n                    }\n                    else\n                    {\n                        eatTheRest = stopAtNonOption;\n                        tokens.add(arg);\n                    }\n                }\n            }\n            else\n            {\n                tokens.add(arg);\n            }\n\n            if (eatTheRest)\n            {\n                for (i++; i < arguments.length; i++)\n                {\n                    tokens.add(arguments[i]);\n                }\n            }\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * <p>This flatten method does so using the following rules:\n     * <ol>\n     *  <li>If an\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/GnuParser.java b/src/java/org/apache/commons/cli/GnuParser.java\nindex 1590fc3..0de035f 100644\n--- a/src/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n@@ -78,14 +78,9 @@ public class GnuParser extends Parser {\n                 }\n                 else\n                 {\n-                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n+                    if (options.hasOption(arg.substring(0, 2)))\n                     {\n                         // the format is --foo=value or -foo=value\n-                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n-                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n-                    }\n-                    else if (options.hasOption(arg.substring(0, 2)))\n-                    {\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n"}
{"identifier": "JacksonDatabind-13", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\nindex 813201828..373ac896b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n@@ -84,9 +84,6 @@ public abstract class DefaultDeserializationContext\n         /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how\n          *   missing id already works.\n          */\n-        if (id == null) {\n-            return null;\n-        }\n \n         final ObjectIdGenerator.IdKey key = gen.key(id);\n \ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\nindex 594d85ff4..921904f4e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n@@ -89,9 +89,6 @@ public final class ObjectIdValueProperty\n          *  will be generated externally, at a later point, and is not available\n          *  quite yet. Typical use case is with DB inserts.\n          */\n-        if (id == null) {\n-            return null;\n-        }\n         \n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         roid.bindItem(instance);\n"}
{"identifier": "JacksonDatabind-52", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\nindex 43445e20d..8484caa92 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n@@ -609,7 +609,7 @@ public abstract class BeanDeserializerBase\n         if (extTypes != null) {\n             // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too,\n             //    so need to pass collected properties\n-            _externalTypeIdHandler = extTypes.build(_beanProperties);\n+            _externalTypeIdHandler = extTypes.build();\n             // we consider this non-standard, to offline handling\n             _nonStandardCreation = true;\n         }\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\nindex 30fb56f78..e273c3b5e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n@@ -307,21 +307,7 @@ public class ExternalTypeHandler\n          *\n          * @since 2.8\n          */\n-        public ExternalTypeHandler build(BeanPropertyMap otherProps) {\n             // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also\n-            final int len = _properties.size();\n-            ExtTypedProperty[] extProps = new ExtTypedProperty[len];\n-            for (int i = 0; i < len; ++i) {\n-                ExtTypedProperty extProp = _properties.get(i);\n-                String typePropId = extProp.getTypePropertyName();\n-                SettableBeanProperty typeProp = otherProps.find(typePropId);\n-                if (typeProp != null) {\n-                    extProp.linkTypeProperty(typeProp);\n-                }\n-                extProps[i] = extProp;\n-            }\n-            return new ExternalTypeHandler(extProps, _nameToPropertyIndex, null, null);\n-        }\n \n         @Deprecated // since 2.8; may be removed as early as 2.9\n         public ExternalTypeHandler build() {\n"}
{"identifier": "Mockito-27", "buggy_code": "    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n", "fixed_code": "    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic <T> void resetMock(T mock)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex d7c530c..3c20596 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -61,7 +61,8 @@ public class MockUtil {\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n+        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n+        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n"}
{"identifier": "Closure-85", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\nindex e6d4320..c2150b1 100644\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n@@ -150,7 +150,20 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback\n       return n;\n     }\n \n+    if (n.getParent() == null) {\n+      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+      if (outEdges.size() == 1) {\n+        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n+      }\n+    }\n     switch (n.getType()) {\n+      case Token.BLOCK:\n+        if (n.hasChildren()) {\n+          Node first = n.getFirstChild();\n+          return tryRemoveUnconditionalBranching(first);\n+        } else {\n+          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n+        }\n       case Token.RETURN:\n         if (n.hasChildren()) {\n           break;\n@@ -167,7 +180,7 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n \n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n-          Node fallThrough = computeFollowing(n);\n+          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);\n@@ -180,13 +193,6 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback\n \n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n-    while (next != null && next.getType() == Token.BLOCK) {\n-      if (next.hasChildren()) {\n-        next = next.getFirstChild();\n-      } else {\n-        next = computeFollowing(next);\n-      }\n-    }\n     return next;\n   }\n \n"}
{"identifier": "Lang-17", "buggy_code": "    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = Character.codePointCount(input, 0, input.length());\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n            }\n            else {\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                    if (pos < len - 2) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n                    } else {\n                        pos++;\n                    }\n                }\n                pos--;\n            }\n            pos++;\n        }\n    }\n", "fixed_code": "    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010ea..4cb581d 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -80,20 +80,26 @@ public abstract class CharSequenceTranslator {\n             return;\n         }\n         int pos = 0;\n-        int len = input.length();\n+        int len = Character.codePointCount(input, 0, input.length());\n         while (pos < len) {\n             int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n-                pos+= c.length;\n-                continue;\n             }\n+            else {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n+                    if (pos < len - 2) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n+                    } else {\n+                        pos++;\n+                    }\n+                }\n+                pos--;\n             }\n+            pos++;\n         }\n     }\n \n"}
{"identifier": "Math-82", "buggy_code": "    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n", "fixed_code": "    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 60a1b3a..8309d7b 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n"}
{"identifier": "Gson-17", "buggy_code": "  @Override\n  public Date read(JsonReader in) throws IOException {\n    if (in.peek() != JsonToken.STRING) {\n      throw new JsonParseException(\"The date should be a string value\");\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }\n", "fixed_code": "  @Override\n  public Date read(JsonReader in) throws IOException {\n    if (in.peek() == JsonToken.NULL) {\n      in.nextNull();\n      return null;\n    }\n    Date date = deserializeToDate(in.nextString());\n    if (dateType == Date.class) {\n      return date;\n    } else if (dateType == Timestamp.class) {\n      return new Timestamp(date.getTime());\n    } else if (dateType == java.sql.Date.class) {\n      return new java.sql.Date(date.getTime());\n    } else {\n      // This must never happen: dateType is guarded in the primary constructor\n      throw new AssertionError();\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public Date read(JsonReader in) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\nindex 3ce97fe8..1ab606c1 100644\n--- a/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n@@ -96,9 +96,8 @@ final class DefaultDateTypeAdapter extends TypeAdapter<Date> {\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() == JsonToken.NULL) {\n-      in.nextNull();\n-      return null;\n+    if (in.peek() != JsonToken.STRING) {\n+      throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n"}
{"identifier": "Time-22", "buggy_code": "    /**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration) {\n        this(duration, null, null);\n        // bug [3264409]\n    }\n", "fixed_code": "    /**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration) {\n        super();\n        // bug [3264409]\n        iType = PeriodType.time();\n        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n        iType = PeriodType.standard();\n        iValues = new int[8];\n        System.arraycopy(values, 0, iValues, 4, 4);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/base/BasePeriod.java b/src/main/java/org/joda/time/base/BasePeriod.java\nindex a5dcb74..679b734 100644\n--- a/src/main/java/org/joda/time/base/BasePeriod.java\n+++ b/src/main/java/org/joda/time/base/BasePeriod.java\n@@ -219,13 +219,8 @@ public abstract class BasePeriod\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        super();\n+        this(duration, null, null);\n         // bug [3264409]\n-        iType = PeriodType.time();\n-        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n-        iType = PeriodType.standard();\n-        iValues = new int[8];\n-        System.arraycopy(values, 0, iValues, 4, 4);\n     }\n \n     /**\n"}
{"identifier": "Jsoup-38", "buggy_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                            return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "fixed_code": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                        else\n                            tb.insert(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb);\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl)\n                                tb.error(this);\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                            // run-aways\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) {\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n                            if (furthestBlock == null) {\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                            // does that mean: int pos of format el in list?\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                if (tb.onStack(node))\n                                    node = tb.aboveOnStack(node);\n                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                    tb.removeFromStack(node);\n                                    continue INNER;\n                                } else if (node == formatEl)\n                                    break INNER;\n\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement;\n\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nboolean process(Token t, HtmlTreeBuilder tb)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\nindex 2df4323..b012f20 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n@@ -452,10 +452,7 @@ enum HtmlTreeBuilderState {\n                         tb.insertEmpty(startTag);\n                         tb.framesetOk(false);\n                     } else if (name.equals(\"image\")) {\n-                        if (tb.getFromStack(\"svg\") == null)\n                             return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n-                        else\n-                            tb.insert(startTag);\n                     } else if (name.equals(\"isindex\")) {\n                         // how much do we care about the early 90s?\n                         tb.error(this);\n"}
{"identifier": "Closure-157", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 593ec05d..142e8202 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -340,20 +340,14 @@ class CodeGenerator {\n         Node body = fn.getLastChild();\n \n         // Add the property name.\n-        if (!n.isQuotedString() &&\n-            TokenStream.isJSIdentifier(name) &&\n+        if (TokenStream.isJSIdentifier(name) &&\n             // do not encode literally any non-literal characters that were\n             // unicode escaped.\n             NodeUtil.isLatin(name)) {\n           add(name);\n         } else {\n           // Determine if the string is a simple number.\n-          double d = getSimpleNumber(name);\n-          if (!Double.isNaN(d)) {\n-            cc.addNumber(d);\n-          } else {\n-            add(jsString(n.getString(), outputCharsetEncoder));\n-          }\n+          add(jsString(n.getString(), outputCharsetEncoder));\n         }\n \n         add(parameters);\n@@ -657,25 +651,19 @@ class CodeGenerator {\n           if (c.getType() == Token.GET || c.getType() == Token.SET) {\n             add(c);\n           } else {\n-            Preconditions.checkState(c.getType() == Token.STRING);\n-            String key = c.getString();\n             // Object literal property names don't have to be quoted if they\n             // are not JavaScript keywords\n-            if (!c.isQuotedString() &&\n-                !TokenStream.isKeyword(key) &&\n-                TokenStream.isJSIdentifier(key) &&\n+            if (c.getType() == Token.STRING &&\n+                !c.isQuotedString() &&\n+                !TokenStream.isKeyword(c.getString()) &&\n+                TokenStream.isJSIdentifier(c.getString()) &&\n                 // do not encode literally any non-literal characters that\n                 // were unicode escaped.\n-                NodeUtil.isLatin(key)) {\n-              add(key);\n+                NodeUtil.isLatin(c.getString())) {\n+              add(c.getString());\n             } else {\n               // Determine if the string is a simple number.\n-              double d = getSimpleNumber(key);\n-              if (!Double.isNaN(d)) {\n-                cc.addNumber(d);\n-              } else {\n-                addExpr(c, 1);\n-              }\n+              addExpr(c, 1);\n             }\n             add(\":\");\n             addExpr(c.getFirstChild(), 1);\n@@ -733,26 +721,7 @@ class CodeGenerator {\n     cc.endSourceMapping(n);\n   }\n \n-  static boolean isSimpleNumber(String s) {\n-    int len = s.length();\n-    for (int index = 0; index < len; index++) {\n-      char c = s.charAt(index);\n-      if (c < '0' || c > '9') {\n-        return false;\n-      }\n-    }\n-    return len > 0;\n-  }\n \n-  static double getSimpleNumber(String s) {\n-    if (isSimpleNumber(s)) {\n-      long l = Long.parseLong(s);\n-      if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n-        return l;\n-      }\n-    }\n-    return Double.NaN;\n-  }\n \n   /**\n    * @return Whether the name is an indirect eval.\ndiff --git a/src/com/google/javascript/jscomp/RenamePrototypes.java b/src/com/google/javascript/jscomp/RenamePrototypes.java\nindex d7558d00..304c0e1e 100644\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n@@ -333,7 +333,7 @@ class RenamePrototypes implements CompilerPass {\n                  child != null;\n                  child = child.getNext()) {\n \n-              if (TokenStream.isJSIdentifier(child.getString())) {\n+              if (child.getType() != Token.NUMBER) {\n                 markObjLitPropertyCandidate(child, t.getInput());\n               }\n             }\n@@ -374,7 +374,7 @@ class RenamePrototypes implements CompilerPass {\n \n             for (Node key = map.getFirstChild();\n                  key != null; key = key.getNext()) {\n-              if (TokenStream.isJSIdentifier(key.getString())) {\n+              if (key.getType() != Token.NUMBER) {\n                // May be STRING, GET, or SET\n                 markPrototypePropertyCandidate(key, input);\n               }\ndiff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 3d1db67d..dcc3def6 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -252,26 +252,9 @@ public class IRFactory {\n     return irNode;\n   }\n \n-  private Node transformNumberAsString(NumberLiteral literalNode) {\n-    JSDocInfo jsDocInfo = handleJsDoc(literalNode);\n-    Node irNode = newStringNode(getStringValue(literalNode.getNumber()));\n-    if (jsDocInfo != null) {\n-      irNode.setJSDocInfo(jsDocInfo);\n-    }\n-    setSourceInfo(irNode, literalNode);\n-    return irNode;\n-  }\n \n-  private static String getStringValue(double value) {\n-    long longValue = (long) value;\n \n     // Return \"1\" instead of \"1.0\"\n-    if (longValue == value) {\n-      return Long.toString(longValue);\n-    } else {\n-      return Double.toString(value);\n-    }\n-  }\n \n   private void setSourceInfo(Node irNode, AstNode node) {\n     // If we have a named function, set the position to that of the name.\n@@ -361,14 +344,14 @@ public class IRFactory {\n       Node ret;\n       if (n instanceof Name) {\n         ret = transformNameAsString((Name)n);\n-      } else if (n instanceof NumberLiteral) {\n-        ret = transformNumberAsString((NumberLiteral)n);\n-        ret.putBooleanProp(Node.QUOTED_PROP, true);\n       } else {\n         ret = transform(n);\n+        Preconditions.checkState(ret.getType() == Token.NUMBER\n+            || ret.getType() == Token.STRING);\n+        if (ret.getType() == Token.STRING) {\n         ret.putBooleanProp(Node.QUOTED_PROP, true);\n+        }\n       }\n-      Preconditions.checkState(ret.getType() == Token.STRING);\n       return ret;\n     }\n \n"}
{"identifier": "Closure-2", "buggy_code": "  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n      // This can be the case if interfaceType is proxy to a non-existent\n      // object (which is a bad type annotation, but shouldn't crash).\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }\n", "fixed_code": "  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    if (implicitProto == null) {\n      // This can be the case if interfaceType is proxy to a non-existent\n      // object (which is a bad type annotation, but shouldn't crash).\n      currentPropertyNames = ImmutableSet.of();\n    } else {\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\n    }\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 96f256d..a0f95db 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1569,13 +1569,9 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n-    if (implicitProto == null) {\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = ImmutableSet.of();\n-    } else {\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n-    }\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n"}
{"identifier": "JacksonCore-21", "buggy_code": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n", "fixed_code": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n            if (!_includePath) {\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n                }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public JsonToken nextToken() throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\nindex 5274f33e..e6558fd0 100644\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n@@ -235,7 +235,6 @@ public class FilteringParserDelegate extends JsonParserDelegate\n         // If all the conditions matches then check for scalar / non-scalar property\n         if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n             //if not scalar and ended successfully, and !includePath, then return null\n-            if (!_includePath) {\n                 if (_currToken.isStructEnd()) {\n                     if (_headContext.isStartHandled()) {\n                         return (_currToken = null);\n@@ -246,7 +245,6 @@ public class FilteringParserDelegate extends JsonParserDelegate\n                     if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                         return (_currToken = null);\n                     }\n-                }\n             }\n         }\n         // Anything buffered?\n"}
{"identifier": "Chart-24", "buggy_code": "    /**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value) {\n        double v = Math.max(value, this.lowerBound);\n        v = Math.min(v, this.upperBound);\n        int g = (int) ((value - this.lowerBound) / (this.upperBound\n                - this.lowerBound) * 255.0);\n        return new Color(g, g, g);\n    }\n", "fixed_code": "    /**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value) {\n        double v = Math.max(value, this.lowerBound);\n        v = Math.min(v, this.upperBound);\n        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                - this.lowerBound) * 255.0);\n        return new Color(g, g, g);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/chart/renderer/GrayPaintScale.java b/source/org/jfree/chart/renderer/GrayPaintScale.java\nindex e62c43f..1e1e075 100644\n--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -123,7 +123,7 @@ public class GrayPaintScale\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((v - this.lowerBound) / (this.upperBound \n+        int g = (int) ((value - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n"}
{"identifier": "Jsoup-24", "buggy_code": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                r.advance();\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                        break;\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n", "fixed_code": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                        break;\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid read(Tokeniser t, CharacterReader r)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex e3013c7..e530264 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -555,6 +555,7 @@ enum TokeniserState {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n+                r.advance();\n                 return;\n             }\n \n"}
{"identifier": "JacksonXml-6", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\nindex 35d09f6..63e42a1 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n@@ -840,67 +840,14 @@ public final class ToXmlGenerator\n         }\n     }\n \n-    @Override\n-    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException\n-    {\n-        if (data == null) {\n-            writeNull();\n-            return 0;\n-        }\n-        _verifyValueWrite(\"write Binary value\");\n-        if (_nextName == null) {\n-            handleMissingName();\n-        }\n-        try {\n-            if (_nextIsAttribute) {\n                 // Stax2 API only has 'full buffer' write method:\n-                byte[] fullBuffer = toFullBuffer(data, dataLength);\n-                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n-            } else if (checkNextIsUnwrapped()) {\n               // should we consider pretty-printing or not?\n-                writeStreamAsBinary(data, dataLength);\n \n-            } else {\n-                if (_xmlPrettyPrinter != null) {\n-                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n-                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n-                            toFullBuffer(data, dataLength), 0, dataLength);\n-                } else {\n-                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                    writeStreamAsBinary(data, dataLength);\n-                    _xmlWriter.writeEndElement();\n-                }\n-            }\n-        } catch (XMLStreamException e) {\n-            StaxUtil.throwAsGenerationException(e, this);\n-        }\n \n-        return dataLength;\n-    }\n \n-    private void writeStreamAsBinary(InputStream data, int len) throws IOException, XMLStreamException \n-    {\n         // base64 encodes up to 3 bytes into a 4 bytes string\n-        byte[] tmp = new byte[3];\n-        int offset = 0;\n-        int read;\n-        while((read = data.read(tmp, offset, Math.min(3 - offset, len))) != -1) {\n-            offset += read;\n-            len -= read;\n-            if(offset == 3) {\n-                offset = 0;\n-                _xmlWriter.writeBinary(tmp, 0, 3);\n-            }\n-            if (len == 0) {\n-                break;\n-            }\n-        }\n \n         // we still have < 3 bytes in the buffer\n-        if(offset > 0) {\n-            _xmlWriter.writeBinary(tmp, 0, offset);\n-        }\n-    }\n \n     \n     private byte[] toFullBuffer(byte[] data, int offset, int len)\n@@ -916,20 +863,7 @@ public final class ToXmlGenerator\n         return result;\n     }\n \n-    private byte[] toFullBuffer(InputStream data, final int len) throws IOException \n-    {\n-        byte[] result = new byte[len];\n-        int offset = 0;\n \n-        for (; offset < len; ) {\n-            int count = data.read(result, offset, len - offset);\n-            if (count < 0) {\n-                _reportError(\"Too few bytes available: missing \"+(len - offset)+\" bytes (out of \"+len+\")\");\n-            }\n-            offset += count;\n-        }\n-        return result;\n-    }\n \n     /*\n     /**********************************************************\n"}
{"identifier": "Math-22", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\nindex e301e2e..8b0993c 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n@@ -272,7 +272,7 @@ public class FDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /** {@inheritDoc} */\ndiff --git a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\nindex 0d279de..5d32f6e 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -181,7 +181,7 @@ public class UniformRealDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /**\n"}
{"identifier": "Math-2", "buggy_code": "    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }\n", "fixed_code": "    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\nindex 81e180c..2769127 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n@@ -265,7 +265,7 @@ public class HypergeometricDistribution extends AbstractIntegerDistribution {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n+        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n"}
{"identifier": "Math-48", "buggy_code": "    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Detect early that algorithm is stuck, instead of waiting\n                    // for the maximum number of iterations to be exceeded.\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n", "fixed_code": "    /** {@inheritDoc} */\n    protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Detect early that algorithm is stuck, instead of waiting\n                    // for the maximum number of iterations to be exceeded.\n                    if (x == x1) {\n                        throw new ConvergenceException();\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex 0347525..8a667da 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -186,9 +186,6 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Detect early that algorithm is stuck, instead of waiting\n                     // for the maximum number of iterations to be exceeded.\n-                    if (x == x1) {\n-                        throw new ConvergenceException();\n-                    }\n                     break;\n                 default:\n                     // Should never happen.\n"}
{"identifier": "Jsoup-27", "buggy_code": "    /**\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     */\n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.toUpperCase(Locale.ENGLISH);\n            return charset;\n        }\n        return null;\n    }\n", "fixed_code": "    /**\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     */\n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            if (Charset.isSupported(charset)) return charset;\n            charset = charset.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(charset)) return charset;\n        }\n        return null;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     */\n    static String getCharsetFromContentType(String contentType)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex a4d4f51..f978141 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -129,9 +129,8 @@ public class DataUtil {\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n-            if (Charset.isSupported(charset)) return charset;\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            if (Charset.isSupported(charset)) return charset;\n+            return charset;\n         }\n         return null;\n     }\n"}
{"identifier": "JacksonDatabind-80", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\nindex 9cb8bec18..a12a878f3 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\n@@ -76,7 +76,6 @@ public class StdSubtypeResolver\n         }\n         \n         // then annotated types for property itself\n-        if (property != null) {\n             Collection<NamedType> st = ai.findSubtypes(property);\n             if (st != null) {\n                 for (NamedType nt : st) {\n@@ -84,7 +83,6 @@ public class StdSubtypeResolver\n                             nt.getType());\n                     _collectAndResolve(ac, nt, config, ai, collected);\n                 }            \n-            }\n         }\n \n         NamedType rootType = new NamedType(rawBase, null);\n@@ -144,14 +142,12 @@ public class StdSubtypeResolver\n         _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n         \n         // then with definitions from property\n-        if (property != null) {\n             Collection<NamedType> st = ai.findSubtypes(property);\n             if (st != null) {\n                 for (NamedType nt : st) {\n                     ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n                     _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n                 }            \n-            }\n         }\n         // and finally explicit type registrations (highest precedence)\n         if (_registeredSubtypes != null) {\n"}
{"identifier": "JacksonDatabind-6", "buggy_code": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * GMT, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                c = dateStr.charAt(len-9);\n                if (Character.isDigit(c)) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(len-5, \".000\");\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen <= 8) {\n                        sb.append(\".000\");\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n", "fixed_code": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * GMT, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n                    int offset = len - 5; // insertion offset, before tz-offset\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0'); break;\n                    case 10:\n                        sb.insert(offset, \"00\"); break;\n                    case 9: // is this legal? (just second fraction marker)\n                        sb.insert(offset, \"000\"); break;\n                    case 8:\n                        sb.insert(offset, \".000\"); break;\n                    case 7: // not legal to have single-digit second\n                        break;\n                    case 6: // probably not legal, but let's allow\n                        sb.insert(offset, \"00.000\");\n                    case 5: // is legal to omit seconds\n                        sb.insert(offset, \":00.000\");\n                    }\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen < 12) { // missing, or partial\n                    switch (timeLen) {\n                    case 11: sb.append('0');\n                    case 10: sb.append('0');\n                    case 9: sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                    }\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\nindex 6c9d6b3cb..e04380c51 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n@@ -403,26 +403,10 @@ public class StdDateFormat\n                 // Milliseconds partial or missing; and even seconds are optional\n                 len = dateStr.length();\n                 // remove 'T', '+'/'-' and 4-digit timezone-offset\n-                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n-                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n-                    int offset = len - 5; // insertion offset, before tz-offset\n+                c = dateStr.charAt(len-9);\n+                if (Character.isDigit(c)) {\n                     StringBuilder sb = new StringBuilder(dateStr);\n-                    switch (timeLen) {\n-                    case 11:\n-                        sb.insert(offset, '0'); break;\n-                    case 10:\n-                        sb.insert(offset, \"00\"); break;\n-                    case 9: // is this legal? (just second fraction marker)\n-                        sb.insert(offset, \"000\"); break;\n-                    case 8:\n-                        sb.insert(offset, \".000\"); break;\n-                    case 7: // not legal to have single-digit second\n-                        break;\n-                    case 6: // probably not legal, but let's allow\n-                        sb.insert(offset, \"00.000\");\n-                    case 5: // is legal to omit seconds\n-                        sb.insert(offset, \":00.000\");\n-                    }\n+                    sb.insert(len-5, \".000\");\n                     dateStr = sb.toString();\n                 }\n                 df = _formatISO8601;\n@@ -434,15 +418,8 @@ public class StdDateFormat\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 // And possible also millisecond part if missing\n                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-                if (timeLen < 12) { // missing, or partial\n-                    switch (timeLen) {\n-                    case 11: sb.append('0');\n-                    case 10: sb.append('0');\n-                    case 9: sb.append('0');\n-                        break;\n-                    default:\n+                if (timeLen <= 8) {\n                         sb.append(\".000\");\n-                    }\n                 }\n                 sb.append('Z');\n                 dateStr = sb.toString();\n"}
{"identifier": "Time-5", "buggy_code": "    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            years = FieldUtils.safeAdd(years, months / 12);\n            months = months % 12;\n            if (years != 0) {\n                result = result.withYears(years);\n            }\n            if (months != 0) {\n                result = result.withMonths(months);\n            }\n        }\n        return result;\n    }\n", "fixed_code": "    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            long totalMonths = years * 12L + months;\n            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n                result = result.withYears(normalizedYears);\n                totalMonths = totalMonths - (normalizedYears * 12);\n            }\n            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n                int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n                result = result.withMonths(normalizedMonths);\n                totalMonths = totalMonths - normalizedMonths;\n            }\n            if (totalMonths != 0) {\n                throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n            }\n        }\n        return result;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/Period.java b/src/main/java/org/joda/time/Period.java\nindex 5ea67a7..f404793 100644\n--- a/src/main/java/org/joda/time/Period.java\n+++ b/src/main/java/org/joda/time/Period.java\n@@ -1625,19 +1625,13 @@ public final class Period\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            long totalMonths = years * 12L + months;\n-            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n-                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n-                result = result.withYears(normalizedYears);\n-                totalMonths = totalMonths - (normalizedYears * 12);\n+            years = FieldUtils.safeAdd(years, months / 12);\n+            months = months % 12;\n+            if (years != 0) {\n+                result = result.withYears(years);\n             }\n-            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n-                int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n-                result = result.withMonths(normalizedMonths);\n-                totalMonths = totalMonths - normalizedMonths;\n-            }\n-            if (totalMonths != 0) {\n-                throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n+            if (months != 0) {\n+                result = result.withMonths(months);\n             }\n         }\n         return result;\n"}
{"identifier": "JacksonXml-5", "buggy_code": "    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = src._rootNameLookup;\n    }\n", "fixed_code": "    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = new XmlRootNameLookup();\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\nindex a50e1a8..b139d09 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n@@ -56,7 +56,7 @@ public class XmlSerializerProvider extends DefaultSerializerProvider\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = new XmlRootNameLookup();\n+        _rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n"}
{"identifier": "Compress-22", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\nindex 1cd6f913..4f89e0e5 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n@@ -64,6 +64,7 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n     private InputStream in;\n     private final boolean decompressConcatenated;\n \n+    private int currentChar = -1;\n     private static final int EOF = 0;\n     private static final int START_BLOCK_STATE = 1;\n     private static final int RAND_PART_A_STATE = 2;\n@@ -131,6 +132,7 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n \n         init(true);\n         initBlock();\n+        setupBlock();\n     }\n \n     @Override\n@@ -194,34 +196,40 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n     }\n \n     private int read0() throws IOException {\n+        final int retChar = this.currentChar;\n         switch (currentState) {\n         case EOF:\n             return -1;\n \n         case START_BLOCK_STATE:\n-            return setupBlock();\n+            throw new IllegalStateException();\n \n         case RAND_PART_A_STATE:\n             throw new IllegalStateException();\n \n         case RAND_PART_B_STATE:\n-            return setupRandPartB();\n+            setupRandPartB();\n+            break;\n \n         case RAND_PART_C_STATE:\n-            return setupRandPartC();\n+            setupRandPartC();\n+            break;\n \n         case NO_RAND_PART_A_STATE:\n             throw new IllegalStateException();\n \n         case NO_RAND_PART_B_STATE:\n-            return setupNoRandPartB();\n+            setupNoRandPartB();\n+            break;\n \n         case NO_RAND_PART_C_STATE:\n-            return setupNoRandPartC();\n+            setupNoRandPartC();\n+            break;\n \n         default:\n             throw new IllegalStateException();\n         }\n+        return retChar;\n     }\n \n     private boolean init(boolean isFirstStream) throws IOException {\n@@ -842,6 +850,7 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n             }\n             this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;\n             this.su_i2++;\n+            this.currentChar = su_ch2Shadow;\n             this.currentState = RAND_PART_B_STATE;\n             this.crc.updateCRC(su_ch2Shadow);\n             return su_ch2Shadow;\n@@ -859,6 +868,7 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n             this.su_ch2 = su_ch2Shadow;\n             this.su_tPos = this.data.tt[this.su_tPos];\n             this.su_i2++;\n+            this.currentChar = su_ch2Shadow;\n             this.currentState = NO_RAND_PART_B_STATE;\n             this.crc.updateCRC(su_ch2Shadow);\n             return su_ch2Shadow;\n@@ -900,6 +910,7 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n \n     private int setupRandPartC() throws IOException {\n         if (this.su_j2 < this.su_z) {\n+            this.currentChar = this.su_ch2;\n             this.crc.updateCRC(this.su_ch2);\n             this.su_j2++;\n             return this.su_ch2;\n@@ -928,6 +939,7 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n     private int setupNoRandPartC() throws IOException {\n         if (this.su_j2 < this.su_z) {\n             int su_ch2Shadow = this.su_ch2;\n+            this.currentChar = su_ch2Shadow;\n             this.crc.updateCRC(su_ch2Shadow);\n             this.su_j2++;\n             this.currentState = NO_RAND_PART_C_STATE;\n"}
{"identifier": "Jsoup-88", "buggy_code": "    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n        return val;\n    }\n", "fixed_code": "    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 6fab394..e321b6a 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -77,7 +77,7 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      @return the attribute value\n      */\n     public String getValue() {\n-        return Attributes.checkNotNull(val);\n+        return val;\n     }\n \n     /**\n"}
{"identifier": "Closure-29", "buggy_code": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore indirect references, like x.y (except x.y(), since\n        // the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target maybe using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-refential. IOW,\n        // disallow things like x = {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n        // but x = {a: 1, b: x.a} is.\n        //\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }\n", "fixed_code": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore indirect references, like x.y (except x.y(), since\n        // the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target maybe using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-refential. IOW,\n        // disallow things like x = {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n        // but x = {a: 1, b: x.a} is.\n        //\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 8c3159d..9f5c607 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -154,7 +154,6 @@ class InlineObjectLiterals implements CompilerPass {\n      */\n     private boolean isInlinableObject(List<Reference> refs) {\n       boolean ret = false;\n-      Set<String> validProperties = Sets.newHashSet();\n       for (Reference ref : refs) {\n         Node name = ref.getNode();\n         Node parent = ref.getParent();\n@@ -179,14 +178,6 @@ class InlineObjectLiterals implements CompilerPass {\n           // We short-circuit this problem by bailing out if we see a reference\n           // to a property that isn't defined on the object literal. This\n           // isn't a perfect algorithm, but it should catch most cases.\n-          String propName = parent.getLastChild().getString();\n-          if (!validProperties.contains(propName)) {\n-            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n-              validProperties.add(propName);\n-            } else {\n-              return false;\n-            }\n-          }\n           continue;\n         }\n \n@@ -222,7 +213,6 @@ class InlineObjectLiterals implements CompilerPass {\n             return false;\n           }\n \n-          validProperties.add(child.getString());\n \n           Node childVal = child.getFirstChild();\n           // Check if childVal is the parent of any of the passed in\n"}
{"identifier": "JacksonCore-20", "buggy_code": "    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException {\n        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n                this);\n    }\n", "fixed_code": "    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException {\n        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n        if (object == null) {\n            writeNull();\n            return;\n        }\n        if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n            return;\n        }\n        throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n                +object.getClass().getName(),\n                this);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\nindex da75a611..2a08020e 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n@@ -1327,16 +1327,7 @@ public abstract class JsonGenerator\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        if (object == null) {\n-            writeNull();\n-            return;\n-        }\n-        if (object instanceof byte[]) {\n-            writeBinary((byte[]) object);\n-            return;\n-        }\n-        throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n-                +object.getClass().getName(),\n+        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n                 this);\n     }\n     \n"}
{"identifier": "Codec-4", "buggy_code": "    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(false);\n    }\n", "fixed_code": "    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 31671e69..e4d1276c 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -222,7 +222,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n      * </p>\n      */\n     public Base64() {\n-        this(0);\n+        this(false);\n     }\n \n     /**\n"}
{"identifier": "Time-10", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java b/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\nindex 839d3b8..91b2c5c 100644\n--- a/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\n+++ b/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\n@@ -49,7 +49,6 @@ public abstract class BaseSingleFieldPeriod\n     /** Serialization version. */\n     private static final long serialVersionUID = 9386874258972L;\n     /** The start of 1972. */\n-    private static final long START_1972 = 2L * 365L * 86400L * 1000L;\n \n     /** The period in the units of this period. */\n     private volatile int iPeriod;\n@@ -102,7 +101,7 @@ public abstract class BaseSingleFieldPeriod\n             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n         }\n         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n-        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n+        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n         return values[0];\n     }\n \n"}
{"identifier": "Jsoup-41", "buggy_code": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return this == o;\n    }\n", "fixed_code": "    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return tag.equals(element.tag);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public boolean equals(Object o)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex c07018e..cd2e86a 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1172,7 +1172,7 @@ public class Element extends Node {\n \n         Element element = (Element) o;\n \n-        return tag.equals(element.tag);\n+        return this == o;\n     }\n \n     @Override\n"}
{"identifier": "Closure-22", "buggy_code": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n      return;\n        }\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n      } else {\n      return;\n      }\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n", "fixed_code": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult() || n.isBlock()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public void visit(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 722d225..b9aa412 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n"}
{"identifier": "JacksonDatabind-77", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex ad37dd170..a8f42c81f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -140,7 +140,6 @@ public class BeanDeserializerFactory\n             return null;\n         }\n         // For checks like [databind#1599]\n-        checkIllegalTypes(ctxt, type, beanDesc);\n         // Use generic bean introspection to build deserializer\n         return buildBeanDeserializer(ctxt, type, beanDesc);\n     }\n@@ -840,21 +839,7 @@ public class BeanDeserializerFactory\n     /**\n      * @since 2.8.9\n      */\n-    protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type,\n-            BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n         // There are certain nasty classes that could cause problems, mostly\n         // via default typing -- catch them here.\n-        Class<?> raw = type.getRawClass();\n-        String name = raw.getSimpleName();\n-\n-        if (\"TemplatesImpl\".equals(name)) { // [databind#1599] \n-            if (raw.getName().startsWith(\"com.sun.org.apache.xalan\")) {\n-                throw JsonMappingException.from(ctxt,\n-                        String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\",\n-                                name));\n-            }\n-        }\n-    }\n+\n }\n"}
{"identifier": "Csv-8", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 772aaf0..22130bf 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -313,12 +313,6 @@ public final class CSVFormat implements Serializable {\n         if (header == null) {\n         \tthis.header = null;\n         } else {\n-        \tSet<String> dupCheck = new HashSet<String>();\n-        \tfor(String hdr : header) {\n-        \t\tif (!dupCheck.add(hdr)) {\n-        \t\t\tthrow new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n-        \t\t}\n-        \t}\n             this.header = header.clone();        \t\n         }\n         this.skipHeaderRecord = skipHeaderRecord;\n@@ -668,6 +662,13 @@ public final class CSVFormat implements Serializable {\n             throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n         }\n \n+        if (header != null) {\n+            final Set<String> set = new HashSet<String>(header.length);\n+            set.addAll(Arrays.asList(header));\n+            if (set.size() != header.length) {\n+                throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n+            }\n+        }\n     }\n \n     /**\n"}
{"identifier": "Closure-110", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex fbd46d3..7e9c8b8 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -355,7 +355,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n-        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n@@ -364,13 +363,12 @@ class ScopedAliases implements HotSwapCompilerPass {\n         } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n-        } else if (isVar || isFunctionDecl) {\n-          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n+        } else if (isVar) {\n           Node grandparent = parent.getParent();\n-          Node value = v.getInitialValue() != null ?\n-              v.getInitialValue() :\n+          Node value = n.hasChildren() ?\n+              v.getInitialValue().detachFromParent() :\n               null;\n-          Node varNode = null;\n+          Node varNode = parent;\n \n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);\n@@ -382,9 +380,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n \n           // First, we need to free up the function expression (EXPR)\n           // to be used in another expression.\n-          if (isFunctionDecl) {\n             // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-            Node existingName = v.getNameNode();\n \n             // We can't keep the local name on the function expression,\n             // because IE is buggy and will leak the name into the global\n@@ -393,19 +389,9 @@ class ScopedAliases implements HotSwapCompilerPass {\n             //\n             // This will only cause problems if this is a hoisted, recursive\n             // function, and the programmer is using the hoisting.\n-            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-            value.replaceChild(existingName, newName);\n \n-            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-            grandparent.replaceChild(parent, varNode);\n-          } else {\n-            if (value != null) {\n               // If this is a VAR, we can just detach the expression and\n               // the tree will still be valid.\n-              value.detachFromParent();\n-            }\n-            varNode = parent;\n-          }\n \n           // Add $jscomp.scope.name = EXPR;\n           // Make sure we copy over all the jsdoc and debug info.\n@@ -419,11 +405,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n \n-            if (isHoisted) {\n-              grandparent.addChildToFront(newDecl);\n-            } else {\n               grandparent.addChildBefore(newDecl, varNode);\n-            }\n           }\n \n           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\ndiff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java\nindex 6a3e9e0..b645632 100644\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n@@ -551,9 +551,6 @@ public class Node implements Cloneable, Serializable {\n       return null;\n     }\n     Node n = first;\n-    if (n == null) {\n-      throw new RuntimeException(\"node is not a child\");\n-    }\n \n     while (n.next != child) {\n       n = n.next;\n"}
{"identifier": "Lang-56", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/lang/time/FastDateFormat.java b/src/java/org/apache/commons/lang/time/FastDateFormat.java\nindex 756290f..89d8073 100644\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -137,11 +137,11 @@ public class FastDateFormat extends Format {\n     /**\n      * The parsed rules.\n      */\n-    private transient Rule[] mRules;\n+    private Rule[] mRules;\n     /**\n      * The estimated maximum length.\n      */\n-    private transient int mMaxLengthEstimate;\n+    private int mMaxLengthEstimate;\n \n     //-----------------------------------------------------------------------\n     /**\n@@ -1019,10 +1019,6 @@ public class FastDateFormat extends Format {\n \n     // Serializing\n     //-----------------------------------------------------------------------\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        init();\n-    }\n     \n     // Rules\n     //-----------------------------------------------------------------------\n"}
{"identifier": "JacksonCore-26", "buggy_code": "    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n", "fixed_code": "    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java\nindex c2817aff..5046b373 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java\n@@ -105,7 +105,6 @@ public class NonBlockingJsonParser\n         _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n \n         // And then update buffer settings\n-        _currBufferStart = start;\n         _inputBuffer = buf;\n         _inputPtr = start;\n         _inputEnd = end;\n"}
{"identifier": "Csv-15", "buggy_code": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n", "fixed_code": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex dc7588b..35c2ad1 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1186,7 +1186,9 @@ public final class CSVFormat implements Serializable {\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (c <= COMMENT) {\n+                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n+                    quote = true;\n+                } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n"}
{"identifier": "Closure-133", "buggy_code": "  /**\n   * Returns the remainder of the line.\n   */\n  private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    return result;\n  }\n", "fixed_code": "  /**\n   * Returns the remainder of the line.\n   */\n  private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n    return result;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Returns the remainder of the line.\n   */\n  private String getRemainingJSDocLine()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex ce94573..6e3294b 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -2398,7 +2398,6 @@ public final class JsDocInfoParser {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n-    unreadToken = NO_UNREAD_TOKEN;\n     return result;\n   }\n \n"}
{"identifier": "Chart-23", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java b/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java\nindex d2b24c6..bbd5ddb 100644\n--- a/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java\n@@ -432,25 +432,6 @@ public class MinMaxCategoryRenderer extends AbstractCategoryItemRenderer {\n      *\n      * @since 1.0.7\n      */\n-    public boolean equals(Object obj) {\n-        if (obj == this) {\n-            return true;\n-        }\n-        if (!(obj instanceof MinMaxCategoryRenderer)) {\n-            return false;\n-        }\n-        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;\n-        if (this.plotLines != that.plotLines) {\n-            return false;\n-        }\n-        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {\n-            return false;\n-        }\n-        if (!this.groupStroke.equals(that.groupStroke)) {\n-            return false;\n-        }\n-        return super.equals(obj);\n-    }\n \n     /**\n      * Returns an icon.\n"}
{"identifier": "Closure-73", "buggy_code": "  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n", "fixed_code": "  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 823d897..558e74f 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c < 0x7f) {\n+            if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n"}
{"identifier": "JacksonCore-19", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex c0bad368..64c798dc 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -1415,10 +1415,6 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n         int fractLen = 0;\n         // And then see if we get other parts\n         if (c == '.') { // yes, fraction\n-            if (outPtr >= outBuf.length) {\n-                outBuf = _textBuffer.finishCurrentSegment();\n-                outPtr = 0;\n-            }\n             outBuf[outPtr++] = c;\n \n             fract_loop:\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\nindex 9296543e..872ffce5 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n@@ -1541,10 +1541,6 @@ public class UTF8StreamJsonParser\n \n         // And then see if we get other parts\n         if (c == INT_PERIOD) { // yes, fraction\n-            if (outPtr >= outBuf.length) {\n-                outBuf = _textBuffer.finishCurrentSegment();\n-                outPtr = 0;\n-            }\n             outBuf[outPtr++] = (char) c;\n \n             fract_loop:\n"}
{"identifier": "JacksonDatabind-87", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\nindex 46346dee9..b1086041d 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n@@ -44,7 +44,6 @@ public class StdDateFormat\n      *\n      * @since 2.8.10\n      */\n-    protected final static String DATE_FORMAT_STR_ISO8601_NO_TZ = \"yyyy-MM-dd'T'HH:mm:ss.SSS\";\n \n     /**\n      * ISO-8601 with just the Date part, no time\n@@ -63,7 +62,6 @@ public class StdDateFormat\n     protected final static String[] ALL_FORMATS = new String[] {\n         DATE_FORMAT_STR_ISO8601,\n         DATE_FORMAT_STR_ISO8601_Z,\n-        DATE_FORMAT_STR_ISO8601_NO_TZ,\n         DATE_FORMAT_STR_RFC1123,\n         DATE_FORMAT_STR_PLAIN\n     };\n@@ -83,7 +81,6 @@ public class StdDateFormat\n \n     protected final static DateFormat DATE_FORMAT_ISO8601;\n     protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n-    protected final static DateFormat DATE_FORMAT_ISO8601_NO_TZ; // since 2.8.10\n \n     protected final static DateFormat DATE_FORMAT_PLAIN;\n \n@@ -102,8 +99,6 @@ public class StdDateFormat\n         DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n         DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n         DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n-        DATE_FORMAT_ISO8601_NO_TZ = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ, DEFAULT_LOCALE);\n-        DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);\n         DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n         DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n     }\n@@ -134,7 +129,6 @@ public class StdDateFormat\n     protected transient DateFormat _formatRFC1123;\n     protected transient DateFormat _formatISO8601;\n     protected transient DateFormat _formatISO8601_z;\n-    protected transient DateFormat _formatISO8601_noTz; // 2.8.10\n     protected transient DateFormat _formatPlain;\n \n     /*\n@@ -517,10 +511,10 @@ public class StdDateFormat\n                 }\n             } else {\n                 // If not, plain date, no timezone\n+                StringBuilder sb = new StringBuilder(dateStr);\n                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                 // And possible also millisecond part if missing\n                 if (timeLen < 12) { // missing, or partial\n-                    StringBuilder sb = new StringBuilder(dateStr);\n                     switch (timeLen) {\n                     case 11: sb.append('0');\n                     case 10: sb.append('0');\n@@ -529,16 +523,17 @@ public class StdDateFormat\n                     default:\n                         sb.append(\".000\");\n                     }\n-                    dateStr = sb.toString();\n                 }\n-                df = _formatISO8601_noTz;\n-                formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ;\n+                sb.append('Z');\n+                dateStr = sb.toString();\n+                df = _formatISO8601_z;\n+                formatStr = DATE_FORMAT_STR_ISO8601_Z;\n                 if (df == null) {\n                     // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                     //    must use UTC, not whatever is configured as default timezone\n                     //    (because we know `Z` identifier is used)\n-                    df = _formatISO8601_noTz = _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ, formatStr,\n-                            _timezone, _locale, _lenient);\n+                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n+                            DEFAULT_TIMEZONE, _locale, _lenient);\n                 }\n             }\n         }\n@@ -599,7 +594,6 @@ public class StdDateFormat\n         _formatRFC1123 = null;\n         _formatISO8601 = null;\n         _formatISO8601_z = null;\n-        _formatISO8601_noTz = null;\n \n         _formatPlain = null;\n     }\n"}
{"identifier": "Jsoup-21", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/select/CombiningEvaluator.java b/src/main/java/org/jsoup/select/CombiningEvaluator.java\nindex 781acc6..bd8460a 100644\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n@@ -61,9 +61,6 @@ abstract class CombiningEvaluator extends Evaluator {\n                 this.evaluators.addAll(evaluators);\n         }\n \n-        Or() {\n-            super();\n-        }\n \n         public void add(Evaluator e) {\n             evaluators.add(e);\ndiff --git a/src/main/java/org/jsoup/select/QueryParser.java b/src/main/java/org/jsoup/select/QueryParser.java\nindex 417cb22..d0afaaf 100644\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n@@ -55,7 +55,15 @@ class QueryParser {\n             // hierarchy and extras\n             boolean seenWhite = tq.consumeWhitespace();\n \n-            if (tq.matchesAny(combinators)) {\n+            if (tq.matchChomp(\",\")) {\n+                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n+                evals.clear();\n+                evals.add(or);\n+                while (!tq.isEmpty()) {\n+                    String subQuery = tq.chompTo(\",\");\n+                    or.add(parse(subQuery));\n+                }\n+            } else if (tq.matchesAny(combinators)) {\n                 combinator(tq.consume());\n             } else if (seenWhite) {\n                 combinator(' ');\n@@ -90,18 +98,6 @@ class QueryParser {\n             evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n         else if (combinator == '~')\n             evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n-        else if (combinator == ',') { // group or\n-            CombiningEvaluator.Or or;\n-            if (e instanceof CombiningEvaluator.Or) {\n-                or = (CombiningEvaluator.Or) e;\n-                or.add(f);\n-            } else {\n-                or = new CombiningEvaluator.Or();\n-                or.add(e);\n-                or.add(f);\n-            }\n-            evals.add(or);\n-        }\n         else\n             throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n     }\n"}
{"identifier": "Math-40", "buggy_code": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n", "fixed_code": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                final int p = agingA - MAXIMAL_AGING;\n                final double weightA = (1 << p) - 1;\n                final double weightB = p + 1;\n                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                final int p = agingB - MAXIMAL_AGING;\n                final double weightA = p + 1;\n                final double weightB = (1 << p) - 1;\n                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                nextX = xA + 0.5 * (xB - xA);\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     *\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 59dc461..93dd3bb 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -232,16 +232,10 @@ public class BracketingNthOrderBrentSolver\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                final int p = agingA - MAXIMAL_AGING;\n-                final double weightA = (1 << p) - 1;\n-                final double weightB = p + 1;\n-                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n+                targetY = -REDUCTION_FACTOR * yB;\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n-                final int p = agingB - MAXIMAL_AGING;\n-                final double weightA = p + 1;\n-                final double weightB = (1 << p) - 1;\n-                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n+                targetY = -REDUCTION_FACTOR * yA;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n"}
{"identifier": "JacksonCore-16", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\nindex 0c9c4eb9..9dadc51f 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n@@ -32,7 +32,6 @@ public class JsonParserSequence extends JsonParserDelegate\n      *\n      * @since 2.8\n      */\n-    protected boolean _suppressNextToken;\n     \n     /*\n      *******************************************************\n@@ -43,7 +42,6 @@ public class JsonParserSequence extends JsonParserDelegate\n     protected JsonParserSequence(JsonParser[] parsers)\n     {\n         super(parsers[0]);\n-        _suppressNextToken = delegate.hasCurrentToken();\n         _parsers = parsers;\n         _nextParser = 1;\n     }\n@@ -103,21 +101,15 @@ public class JsonParserSequence extends JsonParserDelegate\n     }\n \n     @Override\n-    public JsonToken nextToken() throws IOException\n+    public JsonToken nextToken() throws IOException, JsonParseException\n     {\n-        if (delegate == null) {\n-            return null;\n-        }\n-        if (_suppressNextToken) {\n-            _suppressNextToken = false;\n-            return delegate.currentToken();\n-        }\n         JsonToken t = delegate.nextToken();\n-        while ((t == null) && switchToNext()) {\n-            t = delegate.hasCurrentToken()\n-                    ? delegate.currentToken() : delegate.nextToken();\n+        if (t != null) return t;\n+        while (switchToNext()) {\n+            t = delegate.nextToken();\n+            if (t != null) return t;\n         }\n-        return t;\n+        return null;\n     }\n \n     /*\n"}
{"identifier": "Math-4", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex aad7b65..a146cb6 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -111,9 +111,6 @@ public class SubLine {\n \n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n-        if (v1D == null) {\n-            return null;\n-        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex ea9e96a..a9d621a 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -115,9 +115,6 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n \n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n-        if (v2D == null) {\n-            return null;\n-        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n"}
{"identifier": "Closure-103", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 6ef2548..3b67af3 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -891,7 +891,6 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n-      case Token.INSTANCEOF:\n         return true;\n       case Token.FUNCTION:\n         return false;\ndiff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex ca5edbd..4937879 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -760,16 +760,9 @@ class DisambiguateProperties<T> implements CompilerPass {\n       }\n       // If the property does not exist on the referenced type but the original\n       // type is an object type, see if any subtype has the property.\n-      if (foundType == null) {\n-        ObjectType maybeType = ObjectType.cast(\n-            registry.getGreatestSubtypeWithProperty(type, field));\n         // getGreatestSubtypeWithProperty does not guarantee that the property\n         // is defined on the returned type, it just indicates that it might be,\n         // so we have to double check.\n-        if (maybeType != null && maybeType.hasOwnProperty(field)) {\n-          foundType = maybeType;\n-        }\n-      }\n       return foundType;\n     }\n \n"}
{"identifier": "Lang-43", "buggy_code": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n", "fixed_code": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 4af3955..404be49 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -419,7 +419,6 @@ public class ExtendedMessageFormat extends MessageFormat {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n-            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;\n"}
{"identifier": "JacksonDatabind-38", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\nindex e0a785672..39c103822 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n@@ -1,6 +1,5 @@\n package com.fasterxml.jackson.databind.type;\n \n-import java.lang.reflect.TypeVariable;\n \n import com.fasterxml.jackson.databind.JavaType;\n \n@@ -48,14 +47,7 @@ public final class CollectionType\n     public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n         // First: may need to fabricate TypeBindings (needed for refining into\n         // concrete collection types, as per [databind#1102])\n-        TypeVariable<?>[] vars = rawType.getTypeParameters();\n-        TypeBindings bindings;\n-        if ((vars == null) || (vars.length != 1)) {\n-            bindings = TypeBindings.emptyBindings();\n-        } else {\n-            bindings = TypeBindings.create(rawType, elemT);\n-        }\n-        return new CollectionType(rawType, bindings,\n+        return new CollectionType(rawType, null,\n                 // !!! TODO: Wrong, does have supertypes, but:\n                 _bogusSuperClass(rawType), null, elemT,\n                 null, null, false);\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\nindex e71abb683..a11767f44 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n@@ -1,6 +1,5 @@\n package com.fasterxml.jackson.databind.type;\n \n-import java.lang.reflect.TypeVariable;\n \n import com.fasterxml.jackson.databind.JavaType;\n \n@@ -45,15 +44,8 @@ public final class MapType extends MapLikeType\n     {\n         // First: may need to fabricate TypeBindings (needed for refining into\n         // concrete collection types, as per [databind#1102])\n-        TypeVariable<?>[] vars = rawType.getTypeParameters();\n-        TypeBindings bindings;\n-        if ((vars == null) || (vars.length != 2)) {\n-            bindings = TypeBindings.emptyBindings();\n-        } else {\n-            bindings = TypeBindings.create(rawType, keyT, valueT);\n-        }\n         // !!! TODO: Wrong, does have supertypes\n-        return new MapType(rawType, bindings, _bogusSuperClass(rawType), null,\n+        return new MapType(rawType, null, _bogusSuperClass(rawType), null,\n                 keyT, valueT, null, null, false);\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\nindex 1174710df..ceb0117a7 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n@@ -113,9 +113,8 @@ public class SimpleType // note: until 2.6 was final\n         if (cls.isArray()) {\n             throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n         }\n-        TypeBindings b = TypeBindings.emptyBindings();\n-        return new SimpleType(cls, b,\n-                _buildSuperClass(cls.getSuperclass(), b), null, null, null, false);\n+        return new SimpleType(cls, TypeBindings.emptyBindings(),\n+                _bogusSuperClass(cls), null, null, null, false);\n     }\n \n     @Override\n@@ -249,18 +248,6 @@ public class SimpleType // note: until 2.6 was final\n      * \n      * @since 2.7 -- remove when not needed (2.8?)\n      */\n-    private static JavaType _buildSuperClass(Class<?> superClass, TypeBindings b)\n-    {\n-        if (superClass == null) {\n-            return null;\n-        }\n-        if (superClass == Object.class) {\n-            return TypeFactory.unknownType();\n-        }\n-        JavaType superSuper = _buildSuperClass(superClass.getSuperclass(), b);\n-        return new SimpleType(superClass, b,\n-                superSuper, null, null, null, false);\n-    }\n \n     /*\n     /**********************************************************\n"}
{"identifier": "Csv-7", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 315a11c..a6a6d49 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -29,7 +29,6 @@ import java.io.StringReader;\n import java.net.URL;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n@@ -369,9 +368,6 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n             // build the name to index mappings\n             if (header != null) {\n                 for (int i = 0; i < header.length; i++) {\n-                    if (hdrMap.containsKey(header[i])) {\n-                        throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n-                    }\n                     hdrMap.put(header[i], Integer.valueOf(i));\n                 }\n             }\n"}
{"identifier": "Closure-100", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex 1b6c93f..6390687 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -96,13 +96,6 @@ final class CheckGlobalThis implements Callback {\n       // var a = function() { }; // or\n       // function a() {} // or\n       // a.x = function() {};\n-      int pType = parent.getType();\n-      if (!(pType == Token.BLOCK ||\n-            pType == Token.SCRIPT ||\n-            pType == Token.NAME ||\n-            pType == Token.ASSIGN)) {\n-        return false;\n-      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {\n@@ -150,7 +143,7 @@ final class CheckGlobalThis implements Callback {\n     }\n \n     // Also report a THIS with a property access.\n-    return parent != null && NodeUtil.isGet(parent);\n+    return false;\n   }\n \n   /**\n"}
{"identifier": "JacksonDatabind-75", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\nindex dae384a7c..75c12b5c4 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n@@ -83,7 +83,7 @@ public class EnumSerializer\n          *   handle toString() case dynamically (for example)\n          */\n         EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass);\n-        Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true, null);\n+        Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n         return new EnumSerializer(v, serializeAsIndex);\n     }\n \n@@ -101,7 +101,7 @@ public class EnumSerializer\n                     property, handledType());\n             if (format != null) {\n                 Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(),\n-                        format, false, _serializeAsIndex);\n+                        format, false);\n                 if (serializeAsIndex != _serializeAsIndex) {\n                     return new EnumSerializer(_values, serializeAsIndex);\n                 }\n@@ -214,16 +214,15 @@ public class EnumSerializer\n      * index (number) or not.\n      */\n     protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass,\n-            JsonFormat.Value format, boolean fromClass,\n-            Boolean defaultValue)\n+            JsonFormat.Value format, boolean fromClass)\n     {\n         JsonFormat.Shape shape = (format == null) ? null : format.getShape();\n         if (shape == null) {\n-            return defaultValue;\n+            return null;\n         }\n         // i.e. \"default\", check dynamically\n         if (shape == Shape.ANY || shape == Shape.SCALAR) {\n-            return defaultValue;\n+            return null;\n         }\n         // 19-May-2016, tatu: also consider \"natural\" shape\n         if (shape == Shape.STRING || shape == Shape.NATURAL) {\n"}
{"identifier": "Time-12", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/LocalDate.java b/src/main/java/org/joda/time/LocalDate.java\nindex c86b9d7..3868531 100644\n--- a/src/main/java/org/joda/time/LocalDate.java\n+++ b/src/main/java/org/joda/time/LocalDate.java\n@@ -207,10 +207,9 @@ public final class LocalDate\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n-        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n-            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n+            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );\n@@ -241,12 +240,7 @@ public final class LocalDate\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        if (date.getTime() < 0) {\n             // handle years in era BC\n-            GregorianCalendar cal = new GregorianCalendar();\n-            cal.setTime(date);\n-            return fromCalendarFields(cal);\n-        }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,\ndiff --git a/src/main/java/org/joda/time/LocalDateTime.java b/src/main/java/org/joda/time/LocalDateTime.java\nindex e75deca..f37db3e 100644\n--- a/src/main/java/org/joda/time/LocalDateTime.java\n+++ b/src/main/java/org/joda/time/LocalDateTime.java\n@@ -196,10 +196,9 @@ public final class LocalDateTime\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n-        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n-            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n+            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),\n@@ -234,12 +233,7 @@ public final class LocalDateTime\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        if (date.getTime() < 0) {\n             // handle years in era BC\n-            GregorianCalendar cal = new GregorianCalendar();\n-            cal.setTime(date);\n-            return fromCalendarFields(cal);\n-        }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,\n"}
{"identifier": "Time-19", "buggy_code": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n", "fixed_code": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal >= 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex ec05941..855cad0 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal >= 0) {\n+        } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n"}
{"identifier": "Mockito-32", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\nindex dc2ef6a..e292e13 100644\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n@@ -16,7 +16,6 @@ import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.MockUtil;\n \n-import static org.mockito.Mockito.withSettings;\n \n @SuppressWarnings({\"unchecked\"})\n public class SpyAnnotationEngine implements AnnotationEngine {\n@@ -47,10 +46,7 @@ public class SpyAnnotationEngine implements AnnotationEngine {\n                         // instance has been spied earlier\n                         Mockito.reset(instance);\n                     } else {\n-                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\n-                                .spiedInstance(instance)\n-                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n-                                .name(field.getName())));\n+                        field.set(testClass, Mockito.spy(instance));\n                     }\n                 } catch (IllegalAccessException e) {\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n"}
{"identifier": "Closure-6", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java\nindex 12ce5b3..8cdb02a 100644\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -363,6 +363,9 @@ class TypeValidator {\n       JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n+        registerMismatch(rightType, leftType, null);\n+      } else {\n       // Do not type-check interface methods, because we expect that\n       // they will have dummy implementations that do not match the type\n       // annotations.\n@@ -379,6 +382,7 @@ class TypeValidator {\n           \"assignment to property \" + propName + \" of \" +\n           getReadableJSTypeName(owner, true),\n           rightType, leftType);\n+      }\n       return false;\n     }\n     return true;\n@@ -398,7 +402,11 @@ class TypeValidator {\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n+      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n+        registerMismatch(rightType, leftType, null);\n+      } else {\n       mismatch(t, n, msg, rightType, leftType);\n+      }\n       return false;\n     }\n     return true;\n"}
{"identifier": "Jsoup-53", "buggy_code": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }\n", "fixed_code": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if (c.equals('\\'') || c.equals('\"') && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/TokenQueue.java b/src/main/java/org/jsoup/parser/TokenQueue.java\nindex 47947fa..269a755 100644\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n@@ -262,16 +262,11 @@ public class TokenQueue {\n         int end = -1;\n         int depth = 0;\n         char last = 0;\n-        boolean inQuote = false;\n \n         do {\n             if (isEmpty()) break;\n             Character c = consume();\n             if (last == 0 || last != ESC) {\n-                if (c.equals('\\'') || c.equals('\"') && c != open)\n-                    inQuote = !inQuote;\n-                if (inQuote)\n-                    continue;\n                 if (c.equals(open)) {\n                     depth++;\n                     if (start == -1)\n"}
{"identifier": "Time-2", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 3b84fdc..b9ec964 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -215,7 +215,7 @@ public final class Partial\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n-                if (compare < 0) {\n+                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {\n@@ -446,9 +446,6 @@ public final class Partial\n                         if (compare > 0) {\n                             break;\n                         } else if (compare == 0) {\n-                            if (fieldType.getRangeDurationType() == null) {\n-                                break;\n-                            }\n                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                             if (rangeField.compareTo(loopRangeField) > 0) {\ndiff --git a/src/main/java/org/joda/time/field/UnsupportedDurationField.java b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\nindex 7e0ce57..bf44e01 100644\n--- a/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n+++ b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n@@ -224,9 +224,6 @@ public final class UnsupportedDurationField extends DurationField implements Ser\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n-        if (durationField.isSupported()) {\n-            return 1;\n-        }\n         return 0;\n     }\n \n"}
{"identifier": "Cli-28", "buggy_code": "    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n", "fixed_code": "    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex c106932..6b39536 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -287,7 +287,7 @@ public abstract class Parser implements CommandLineParser\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    continue;\n+                    break;\n                 }\n \n                 cmd.addOption(opt);\n"}
{"identifier": "Gson-3", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\nindex 6fc9f2d3..a0384fa7 100644\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n@@ -33,10 +33,6 @@ import java.util.SortedMap;\n import java.util.SortedSet;\n import java.util.TreeMap;\n import java.util.TreeSet;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ConcurrentNavigableMap;\n-import java.util.concurrent.ConcurrentSkipListMap;\n \n import com.google.gson.InstanceCreator;\n import com.google.gson.JsonIOException;\n@@ -176,19 +172,7 @@ public final class ConstructorConstructor {\n     }\n \n     if (Map.class.isAssignableFrom(rawType)) {\n-      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n-        return new ObjectConstructor<T>() {\n-          @Override public T construct() {\n-            return (T) new ConcurrentSkipListMap<Object, Object>();\n-          }\n-        };\n-      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n-        return new ObjectConstructor<T>() {\n-          @Override public T construct() {\n-            return (T) new ConcurrentHashMap<Object, Object>();\n-          }\n-        };\n-      } else if (SortedMap.class.isAssignableFrom(rawType)) {\n+      if (SortedMap.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor<T>() {\n           @Override public T construct() {\n             return (T) new TreeMap<Object, Object>();\n"}
{"identifier": "Closure-66", "buggy_code": "  /**\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n          // Object literal keys are not typeable\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n", "fixed_code": "  /**\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        } else {\n          // Object literal keys are not typeable\n          typeable = false;\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  public void visit(NodeTraversal t, Node n, Node parent)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex d3def01..edb7805 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -513,9 +513,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n         // Object literal keys are handled with OBJECTLIT\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n-        } else {\n           // Object literal keys are not typeable\n-          typeable = false;\n         }\n         break;\n \n"}
{"identifier": "Time-1", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 6ff2771..3b84fdc 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -214,20 +214,11 @@ public final class Partial\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n-                if (loopUnitField.isSupported() == false) {\n-                    if (lastUnitField.isSupported()) {\n-                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n-                                        types[i - 1].getName() + \" < \" + loopType.getName());\n-                    } else {\n-                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n-                                        types[i - 1].getName() + \" and \" + loopType.getName());\n-                    }\n-                }\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n-                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n+                } else if (compare == 0) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\ndiff --git a/src/main/java/org/joda/time/field/UnsupportedDurationField.java b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\nindex bf44e01..7e0ce57 100644\n--- a/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n+++ b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n@@ -224,6 +224,9 @@ public final class UnsupportedDurationField extends DurationField implements Ser\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n+        if (durationField.isSupported()) {\n+            return 1;\n+        }\n         return 0;\n     }\n \n"}
{"identifier": "Math-12", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\nindex fab295b..4d166c2 100644\n--- a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.commons.math3.random;\n \n-import java.io.Serializable;\n \n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.util.FastMath;\n@@ -27,10 +26,8 @@ import org.apache.commons.math3.util.FastMath;\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator,\n-               Serializable {\n+    implements RandomGenerator {\n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 20130104L;\n     /** Next gaussian. */\n     private double nextGaussian;\n \n"}
{"identifier": "JacksonDatabind-21", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\nindex ca3966ad4..624c08d5c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n@@ -1,7 +1,6 @@\n package com.fasterxml.jackson.databind.introspect;\n \n import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n@@ -62,27 +61,11 @@ public class JacksonAnnotationIntrospector\n      * Since 2.6, we have supported use of {@link JsonProperty} for specifying\n      * explicit serialized name\n      */\n-    @Override\n-    public String findEnumValue(Enum<?> value)\n-    {\n         // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming.\n         //   Unfortunately can not quite use standard AnnotatedClass here (due to various\n         //   reasons, including odd representation JVM uses); has to do for now\n-        try {\n             // We know that values are actually static fields with matching name so:\n-            Field f = value.getClass().getField(value.name());\n-            if (f != null) {\n-                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n-                String n = prop.value();\n-                if (n != null && !n.isEmpty()) {\n-                    return n;\n-                }\n-            }\n-        } catch (Exception e) {\n             // no such field, or access; neither which we can do much about\n-        }\n-        return value.name();\n-    }\n \n     /*\n     /**********************************************************\n"}
{"identifier": "JacksonDatabind-90", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\nindex fceac96e9..b721f6909 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n@@ -69,7 +69,7 @@ public abstract class ValueInstantiator\n      */\n     public boolean canInstantiate() {\n         return canCreateUsingDefault()\n-                || canCreateUsingDelegate() || canCreateUsingArrayDelegate()\n+                || canCreateUsingDelegate() \n                 || canCreateFromObjectWith() || canCreateFromString()\n                 || canCreateFromInt() || canCreateFromLong()\n                 || canCreateFromDouble() || canCreateFromBoolean();\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\nindex 97057703a..917bdfe82 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n@@ -229,14 +229,6 @@ public class StdValueInstantiator\n         return (_withArgsCreator != null);\n     }\n \n-    @Override\n-    public boolean canInstantiate() {\n-        return canCreateUsingDefault()\n-                || canCreateUsingDelegate() || canCreateUsingArrayDelegate()\n-                || canCreateFromObjectWith() || canCreateFromString()\n-                || canCreateFromInt() || canCreateFromLong()\n-                || canCreateFromDouble() || canCreateFromBoolean();\n-    }\n \n     @Override\n     public JavaType getDelegateType(DeserializationConfig config) {\n"}
{"identifier": "Compress-30", "buggy_code": "    /*\n     * (non-Javadoc)\n     * \n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException {\n        if (offs < 0) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n        }\n        if (len < 0) {\n            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n        }\n        if (offs + len > dest.length) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                                + len + \") > dest.length(\" + dest.length + \").\");\n        }\n        if (this.in == null) {\n            throw new IOException(\"stream closed\");\n        }\n\n        final int hi = offs + len;\n        int destOffs = offs;\n        int b;\n        while (destOffs < hi && ((b = read0()) >= 0)) {\n            dest[destOffs++] = (byte) b;\n            count(1);\n        }\n\n        int c = (destOffs == offs) ? -1 : (destOffs - offs);\n        return c;\n    }\n", "fixed_code": "    /*\n     * (non-Javadoc)\n     * \n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException {\n        if (offs < 0) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n        }\n        if (len < 0) {\n            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n        }\n        if (offs + len > dest.length) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                                + len + \") > dest.length(\" + dest.length + \").\");\n        }\n        if (this.in == null) {\n            throw new IOException(\"stream closed\");\n        }\n        if (len == 0) {\n            return 0;\n        }\n\n        final int hi = offs + len;\n        int destOffs = offs;\n        int b;\n        while (destOffs < hi && ((b = read0()) >= 0)) {\n            dest[destOffs++] = (byte) b;\n            count(1);\n        }\n\n        int c = (destOffs == offs) ? -1 : (destOffs - offs);\n        return c;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/*\n     * (non-Javadoc)\n     * \n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\nindex b32b1f9b..e0e3b1ec 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n@@ -165,9 +165,6 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n         if (this.in == null) {\n             throw new IOException(\"stream closed\");\n         }\n-        if (len == 0) {\n-            return 0;\n-        }\n \n         final int hi = offs + len;\n         int destOffs = offs;\n"}
{"identifier": "Closure-18", "buggy_code": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n", "fixed_code": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement()) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 3756b99..8898f77 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement()) {\n+      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n"}
{"identifier": "JacksonCore-11", "buggy_code": "    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n", "fixed_code": "    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n            _verifyNeedForRehash();\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprivate void _verifySharing()\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\nindex d9e6c4f6..f19acc72 100644\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n@@ -879,7 +879,6 @@ public final class ByteQuadsCanonicalizer\n             _hashShared = false;\n             // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n             //    we rehash as needed, as need-rehash flag is not copied from parent\n-            _verifyNeedForRehash();\n         }\n         if (_needRehash) {\n             rehash();\n"}
{"identifier": "Closure-51", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 3a66750..d9ff87a 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -238,7 +238,7 @@ abstract class CodeConsumer {\n       add(\" \");\n     }\n \n-    if ((long) x == x && !isNegativeZero(x)) {\n+    if ((long) x == x) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;\n@@ -256,10 +256,7 @@ abstract class CodeConsumer {\n     } else {\n       add(String.valueOf(x));\n     }\n-  }\n \n-  static boolean isNegativeZero(double x) {\n-    return x == 0.0 && Math.copySign(1, x) == -1.0;\n   }\n \n   static boolean isWordChar(char ch) {\n"}
{"identifier": "Closure-33", "buggy_code": "  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n", "fixed_code": "  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n    if (hasReferenceName()) {\n      return;\n    }\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n  public void matchConstraint(ObjectType constraintObj)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex 81a7d89..b6e3fc7 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -554,9 +554,6 @@ class PrototypeObjectType extends ObjectType {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n-    if (hasReferenceName()) {\n-      return;\n-    }\n \n     // Handle the case where the constraint object is a record type.\n     //\n"}
{"identifier": "Math-15", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex 9dc84c6..d571325 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -310,7 +310,6 @@ public class FastMath {\n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     /** 2^53 - double numbers this large must be even. */\n-    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n \n     /** Constant: {@value}. */\n     private static final double F_1_3 = 1d / 3d;\n@@ -1539,7 +1538,7 @@ public class FastMath {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n+            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                 return pow(-x, y);\n             }\n \n"}
{"identifier": "Closure-143", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\nindex aa29e5f0..13cb6268 100644\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n@@ -868,8 +868,7 @@ abstract class AbstractCommandLineRunner<A extends Compiler,\n           } else if (defValue.length() > 1\n               && ((defValue.charAt(0) == '\\'' &&\n                   defValue.charAt(defValue.length() - 1) == '\\'')\n-                  || (defValue.charAt(0) == '\\\"' &&\n-                      defValue.charAt(defValue.length() - 1) == '\\\"'))) {\n+            )) {\n             // If the value starts and ends with a single quote,\n             // we assume that it's a string.\n             String maybeStringVal =\ndiff --git a/src/com/google/javascript/jscomp/RemoveConstantExpressions.java b/src/com/google/javascript/jscomp/RemoveConstantExpressions.java\nindex 17d55c9f..fee9c287 100644\n--- a/src/com/google/javascript/jscomp/RemoveConstantExpressions.java\n+++ b/src/com/google/javascript/jscomp/RemoveConstantExpressions.java\n@@ -88,8 +88,7 @@ final class RemoveConstantExpressions implements CompilerPass {\n \n       Node exprBody = node.getFirstChild();\n       if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)\n-          || exprBody.getType() == Token.NEW\n-          || exprBody.getType() == Token.CALL) {\n+      ) {\n         changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n       }\n     }\n"}
{"identifier": "JacksonDatabind-85", "buggy_code": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                                || format.hasLocale() || format.hasTimeZone()) {\n                    TimeZone tz = format.getTimeZone();\n                    final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n\n\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n//            serializers.reportBadDefinition(handledType(), String.format(\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        return this;\n    }\n", "fixed_code": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            if (format.hasLocale()) {\n                std = std.withLocale(format.getLocale());\n            }\n            if (format.hasTimeZone()) {\n                std = std.withTimeZone(format.getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n//            serializers.reportBadDefinition(handledType(), String.format(\n            serializers.reportMappingProblem(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`\",\ndf0.getClass().getName());\n        }\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        if (hasLocale) {\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n        } else {\n            df = (SimpleDateFormat) df.clone();\n        }\n        TimeZone newTz = format.getTimeZone();\n        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n        if (changeTZ) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\nindex 4b9312b7a..df3205c4e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n@@ -64,61 +64,34 @@ public abstract class DateTimeSerializerBase<T>\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-        if (format.hasPattern()) {\n+                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n+                                || format.hasLocale() || format.hasTimeZone()) {\n+                    TimeZone tz = format.getTimeZone();\n+                    final String pattern = format.hasPattern()\n+                                    ? format.getPattern()\n+                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n             final Locale loc = format.hasLocale()\n                             ? format.getLocale()\n                             : serializers.getLocale();\n-            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n-            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n-                    : serializers.getTimeZone();\n+                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n+                    if (tz == null) {\n+                        tz = serializers.getTimeZone();\n+                    }\n             df.setTimeZone(tz);\n             return withFormat(Boolean.FALSE, df);\n         }\n \n         // Otherwise, need one of these changes:\n-        final boolean hasLocale = format.hasLocale();\n-        final boolean hasTZ = format.hasTimeZone();\n-        final boolean asString = (shape == JsonFormat.Shape.STRING);\n \n-        if (!hasLocale && !hasTZ && !asString) {\n-            return this;\n-        }\n \n-        DateFormat df0 = serializers.getConfig().getDateFormat();\n         // Jackson's own `StdDateFormat` is quite easy to deal with...\n-        if (df0 instanceof StdDateFormat) {\n-            StdDateFormat std = (StdDateFormat) df0;\n-            if (format.hasLocale()) {\n-                std = std.withLocale(format.getLocale());\n-            }\n-            if (format.hasTimeZone()) {\n-                std = std.withTimeZone(format.getTimeZone());\n-            }\n-            return withFormat(Boolean.FALSE, std);\n-        }\n \n         // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n         //    mechanism for changing `DateFormat` instances (or even clone()ing)\n         //    So: require it be `SimpleDateFormat`; can't config other types\n-        if (!(df0 instanceof SimpleDateFormat)) {\n //            serializers.reportBadDefinition(handledType(), String.format(\n-            serializers.reportMappingProblem(\n-\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`\",\n-df0.getClass().getName());\n-        }\n-        SimpleDateFormat df = (SimpleDateFormat) df0;\n-        if (hasLocale) {\n             // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-            df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n-        } else {\n-            df = (SimpleDateFormat) df.clone();\n-        }\n-        TimeZone newTz = format.getTimeZone();\n-        boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n-        if (changeTZ) {\n-            df.setTimeZone(newTz);\n-        }\n-        return withFormat(Boolean.FALSE, df);\n+        return this;\n     }\n \n     /*\n"}
{"identifier": "Gson-11", "buggy_code": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n", "fixed_code": "    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n    public Number read(JsonReader in) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\nindex 31beb5d6..6a51c64e 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n@@ -368,7 +368,6 @@ public final class TypeAdapters {\n         in.nextNull();\n         return null;\n       case NUMBER:\n-      case STRING:\n         return new LazilyParsedNumber(in.nextString());\n       default:\n         throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n"}
{"identifier": "Compress-43", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\nindex 63aeba72..df1f63ce 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java\n@@ -1031,7 +1031,7 @@ private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased\n \n         final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n         final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));\n+        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n         writeCounted(localHeader);\n         entry.dataStart = streamCompressor.getTotalBytesWritten();\n@@ -1072,7 +1072,7 @@ private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased\n \n         //store method in local variable to prevent multiple method calls\n         final int zipMethod = ze.getMethod();\n-        final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);\n+        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n \n         putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n \n@@ -1168,7 +1168,7 @@ private void addUnicodeExtraFields(final ZipArchiveEntry ze, final boolean encod\n      * @throws IOException on error\n      */\n     protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-        if (!usesDataDescriptor(ze.getMethod(), false)) {\n+        if (ze.getMethod() != DEFLATED || channel != null) {\n             return;\n         }\n         writeCounted(DD_SIG);\n@@ -1489,8 +1489,8 @@ private int versionNeededToExtract(final int zipMethod, final boolean zip64, fin\n         return versionNeededToExtractMethod(zipMethod);\n     }\n \n-    private boolean usesDataDescriptor(final int zipMethod, boolean phased) {\n-        return !phased && zipMethod == DEFLATED && channel == null;\n+    private boolean usesDataDescriptor(final int zipMethod) {\n+        return zipMethod == DEFLATED && channel == null;\n     }\n \n     private int versionNeededToExtractMethod(int zipMethod) {\n"}
{"identifier": "Csv-9", "buggy_code": "    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n", "fixed_code": "    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        if (mapping == null) {\n            return map;\n        }\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex e814b70..3abb468 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -177,9 +177,6 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n      * @return the given map.\n      */\n     <M extends Map<String, String>> M putIn(final M map) {\n-        if (mapping == null) {\n-            return map;\n-        }\n         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n             final int col = entry.getValue().intValue();\n             if (col < values.length) {\n"}
{"identifier": "JxPath-22", "buggy_code": "    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri == null) {\n            String prefix = getPrefix(node);\n            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n    \n            Node aNode = node;\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        return attr.getValue();\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            return null;\n        }\n        return uri;\n    }\n", "fixed_code": "    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri == null) {\n            String prefix = getPrefix(node);\n            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n    \n            Node aNode = node;\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        uri = attr.getValue();\n                        break;\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n        return \"\".equals(uri) ? null : uri;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex f1a1b2b..bbf57ff 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -686,14 +686,14 @@\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        uri = attr.getValue();\n-                        break;\n+                        return attr.getValue();\n                     }\n                 }\n                 aNode = aNode.getParentNode();\n             }\n+            return null;\n         }\n-        return \"\".equals(uri) ? null : uri;\n+        return uri;\n     }\n \n     public Object getValue() {\n\n"}
{"identifier": "Csv-14", "buggy_code": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n", "fixed_code": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n// the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex eee099d..35ee86a 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1036,7 +1036,7 @@ public final class CSVFormat implements Serializable {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n+                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n"}
{"identifier": "JxPath-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\nindex 1544183..f717190 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n@@ -653,27 +653,18 @@ public class CoreFunction extends Operation {\n     protected Object functionFloor(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n-        if (Double.isNaN(v) || Double.isInfinite(v)) {\n-        \treturn new Double(v);\n-        }\n         return new Double(Math.floor(v));\n     }\n \n     protected Object functionCeiling(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n-        if (Double.isNaN(v) || Double.isInfinite(v)) {\n-        \treturn new Double(v);\n-        }\n         return new Double(Math.ceil(v));\n     }\n \n     protected Object functionRound(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n-        if (Double.isNaN(v) || Double.isInfinite(v)) {\n-        \treturn new Double(v);\n-        }\n         return new Double(Math.round(v));\n     }\n \n"}
{"identifier": "Jsoup-57", "buggy_code": "    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                attributes.remove(attrKey);\n        }\n    }\n", "fixed_code": "    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                it.remove();\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java\nindex 8fdb654..49ff25d 100644\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -122,7 +122,7 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n             String attrKey = it.next();\n             if (attrKey.equalsIgnoreCase(key))\n-                it.remove();\n+                attributes.remove(attrKey);\n         }\n     }\n \n"}
{"identifier": "Jsoup-14", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java\nindex 316cbea..6d729cf 100644\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n@@ -194,9 +194,6 @@ class Tokeniser {\n         return tagPending.tagName.equals(lastStartTag.tagName);\n     }\n \n-    String appropriateEndTagName() {\n-        return lastStartTag.tagName;\n-    }\n \n     boolean isTrackErrors() {\n         return trackErrors;\ndiff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex 8774823..ca27ea0 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -215,13 +215,8 @@ enum TokeniserState {\n             if (r.matches('/')) {\n                 t.createTempBuffer();\n                 t.advanceTransition(RCDATAEndTagOpen);\n-            } else if (r.matchesLetter() && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                 // consuming to EOF; break out here\n-                t.tagPending = new Token.EndTag(t.appropriateEndTagName());\n-                t.emitTagPending();\n-                r.unconsume(); // undo \"<\"\n-                t.transition(Data);\n             } else {\n                 t.emit(\"<\");\n                 t.transition(Rcdata);\n"}
{"identifier": "Closure-170", "buggy_code": "    /**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     */\n    private void getNumUseInUseCfgNode(final Node cfgNode) {\n\n      numUsesWithinCfgNode = 0;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName) &&\n            // We make a special exception when the entire cfgNode is a chain\n            // of assignments, since in that case the assignment statements\n            // will happen after the inlining of the right hand side.\n            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n            //   and remove this special case.\n              !(parent.isAssign() &&\n               (parent.getFirstChild() == n))) {\n              // Don't count lhs of top-level assignment chain\n              numUsesWithinCfgNode++;\n          }\n        }\n\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n", "fixed_code": "    /**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     */\n    private void getNumUseInUseCfgNode(final Node cfgNode) {\n\n      numUsesWithinCfgNode = 0;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName)) {\n            // We make a special exception when the entire cfgNode is a chain\n            // of assignments, since in that case the assignment statements\n            // will happen after the inlining of the right hand side.\n            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n            //   and remove this special case.\n            if (parent.isAssign() && (parent.getFirstChild() == n)\n                && isAssignChain(parent, cfgNode)) {\n              // Don't count lhs of top-level assignment chain\n              return;\n            } else {\n              numUsesWithinCfgNode++;\n            }\n          }\n        }\n\n        private boolean isAssignChain(Node child, Node ancestor) {\n          for (Node n = child; n != ancestor; n = n.getParent()) {\n            if (!n.isAssign()) {\n              return false;\n            }\n          }\n          return true;\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     */\n    private void getNumUseInUseCfgNode(final Node cfgNode)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex d58f80cb..ecba09b1 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -479,30 +479,19 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName)) {\n+          if (n.isName() && n.getString().equals(varName) &&\n             // We make a special exception when the entire cfgNode is a chain\n             // of assignments, since in that case the assignment statements\n             // will happen after the inlining of the right hand side.\n             // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n             //   and remove this special case.\n-            if (parent.isAssign() && (parent.getFirstChild() == n)\n-                && isAssignChain(parent, cfgNode)) {\n+              !(parent.isAssign() &&\n+               (parent.getFirstChild() == n))) {\n               // Don't count lhs of top-level assignment chain\n-              return;\n-            } else {\n               numUsesWithinCfgNode++;\n-            }\n           }\n         }\n \n-        private boolean isAssignChain(Node child, Node ancestor) {\n-          for (Node n = child; n != ancestor; n = n.getParent()) {\n-            if (!n.isAssign()) {\n-              return false;\n-            }\n-          }\n-          return true;\n-        }\n       };\n \n       NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n"}
{"identifier": "Gson-5", "buggy_code": "    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n            \n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n\n                // extract hours, minutes, seconds and milliseconds\n                hour = parseInt(date, offset += 1, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n                         */\n                        String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                    +timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n            // If we get a ParseException it'll already have the right message/offset.\n            // Other exception types can convert here.\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + \"'\");\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\"+fail.getClass().getName()+\")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n", "fixed_code": "    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n            \n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n\n                // extract hours, minutes, seconds and milliseconds\n                hour = parseInt(date, offset += 1, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                            int fraction = parseInt(date, offset, parseEndOffset);\n                            // compensate for \"missing\" digits\n                            switch (parseEndOffset - offset) { // number of digits parsed\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                            }\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n                         */\n                        String cleaned = act.replace(\":\", \"\");\n                        if (!cleaned.equals(timezoneId)) {\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                    +timezone.getID());\n                        }\n                    }\n                }\n            } else {\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1);\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n            // If we get a ParseException it'll already have the right message/offset.\n            // Other exception types can convert here.\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        }\n        String input = (date == null) ? null : ('\"' + date + \"'\");\n        String msg = fail.getMessage();\n        if (msg == null || msg.isEmpty()) {\n            msg = \"(\"+fail.getClass().getName()+\")\";\n        }\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        ex.initCause(fail);\n        throw ex;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\nindex c931b090..a326f768 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n@@ -211,7 +211,6 @@ public class ISO8601Utils\n                 String timezoneOffset = date.substring(offset);\n \n                 // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n-                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n \n                 offset += timezoneOffset.length();\n                 // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n"}
{"identifier": "Math-90", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex 237c2f6..75914d7 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,8 +107,6 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-        addValue((Comparable<?>) v);\n-    }\n     \n     /**\n      * Adds 1 to the frequency count for v.\n@@ -120,7 +118,6 @@ public class Frequency implements Serializable {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n-    public void addValue(Comparable<?>v){\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n"}
{"identifier": "Closure-108", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex b2a1690..1e22c9e 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -256,7 +256,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n     private final Map<String, Var> aliases = Maps.newHashMap();\n \n     // Also temporary and cleared for each scope.\n-    private final Set<Node> injectedDecls = Sets.newHashSet();\n \n     // Suppose you create an alias.\n     // var x = goog.x;\n@@ -314,7 +313,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n \n       if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n-        injectedDecls.clear();\n         aliases.clear();\n         forbiddenLocals.clear();\n         transformation = null;\n@@ -431,7 +429,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n             } else {\n               grandparent.addChildBefore(newDecl, varNode);\n             }\n-            injectedDecls.add(newDecl.getFirstChild());\n           }\n \n           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n@@ -581,7 +578,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n         // When we inject declarations, we duplicate jsdoc. Make sure\n         // we only process that jsdoc once.\n         JSDocInfo info = n.getJSDocInfo();\n-        if (info != null && !injectedDecls.contains(n)) {\n+        if (info != null) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }\n"}
{"identifier": "JacksonCore-3", "buggy_code": "    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        // If we have offset, need to omit that from byte offset, so:\n        _bufferRecyclable = bufferRecyclable;\n    }\n", "fixed_code": "    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\npublic UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\nindex fba33c26..f89e661d 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n@@ -122,9 +122,7 @@ public class UTF8StreamJsonParser\n         _inputBuffer = inputBuffer;\n         _inputPtr = start;\n         _inputEnd = end;\n-        _currInputRowStart = start;\n         // If we have offset, need to omit that from byte offset, so:\n-        _currInputProcessed = -start;\n         _bufferRecyclable = bufferRecyclable;\n     }\n \n"}
{"identifier": "Compress-42", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java b/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java\nindex a1b20be3..8fc36068 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java\n@@ -32,7 +32,6 @@\n      * Bits used to indicate the filesystem object type.\n      * @since 1.14\n      */\n-    int FILE_TYPE_FLAG = 0170000;\n     /**\n      * Indicates symbolic links.\n      */\ndiff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex 2abd22b5..5030da57 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -294,7 +294,7 @@ public int getUnixMode() {\n      * @return true if the entry represents a unix symlink, false otherwise.\n      */\n     public boolean isUnixSymlink() {\n-        return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG;\n+        return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n     }\n \n     /**\n"}
{"identifier": "Closure-129", "buggy_code": "    /**\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     */\n    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }\n", "fixed_code": "    /**\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     */\n    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n      while (first.isCast()) {\n        first = first.getFirstChild();\n      }\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     */\n    private void annotateCalls(Node n)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/PrepareAst.java b/src/com/google/javascript/jscomp/PrepareAst.java\nindex 42982af..d993bee 100644\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n@@ -163,9 +163,6 @@ class PrepareAst implements CompilerPass {\n       Node first = n.getFirstChild();\n \n       // ignore cast nodes.\n-      while (first.isCast()) {\n-        first = first.getFirstChild();\n-      }\n \n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);\n"}
{"identifier": "JacksonDatabind-35", "buggy_code": "    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n        // first, sanity checks\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n            // should always get field name, but just in case...\n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n\n        // Minor complication: we may need to merge type id in?\n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); // recreate START_OBJECT\n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n        // And then need the closing END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }\n", "fixed_code": "    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n        // first, sanity checks\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            // should always get field name, but just in case...\n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        } else if (t != JsonToken.FIELD_NAME) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n\n        // Minor complication: we may need to merge type id in?\n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); // recreate START_OBJECT\n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n        // And then need the closing END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\nindex 659762bd0..0b954f686 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n@@ -86,17 +86,15 @@ public class AsWrapperTypeDeserializer\n             }\n         }\n         // first, sanity checks\n-        JsonToken t = p.getCurrentToken();\n-        if (t == JsonToken.START_OBJECT) {\n+        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n+                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n+        }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n-        } else if (t != JsonToken.FIELD_NAME) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n         final String typeId = p.getText();\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n         p.nextToken();\n"}
{"identifier": "JacksonDatabind-51", "buggy_code": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { // what should this be taken to mean?\n                        // TODO: try to figure out something better\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                    //   generic type with custom type resolvers. If so, should try to retain them.\n                    //  Whether this is sufficient to avoid problems remains to be seen, but for\n                    //  now it should improve things.\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n", "fixed_code": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { // what should this be taken to mean?\n                        // TODO: try to figure out something better\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                    //   generic type with custom type resolvers. If so, should try to retain them.\n                    //  Whether this is sufficient to avoid problems remains to be seen, but for\n                    //  now it should improve things.\n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nprotected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\nindex cd9b15554..23380f082 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n@@ -181,9 +181,7 @@ public abstract class TypeDeserializerBase\n                     //   generic type with custom type resolvers. If so, should try to retain them.\n                     //  Whether this is sufficient to avoid problems remains to be seen, but for\n                     //  now it should improve things.\n-                    if (!type.hasGenericTypes()) {\n                         type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n-                    }\n                 }\n                 deser = ctxt.findContextualValueDeserializer(type, _property);\n             }\n"}
{"identifier": "Closure-83", "buggy_code": "      @Override\n      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = params.getParameter(0);\n\n        if (param == null) {\n          setter.addValue(true);\n          return 0;\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            setter.addValue(true);\n            return 0;\n          }\n          return 1;\n        }\n      }\n", "fixed_code": "      @Override\n      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = null;\n        try {\n          param = params.getParameter(0);\n        } catch (CmdLineException e) {}\n\n        if (param == null) {\n          setter.addValue(true);\n          return 0;\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            setter.addValue(true);\n            return 0;\n          }\n          return 1;\n        }\n      }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@Override\n      public int parseArguments(Parameters params) throws CmdLineException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 4c3b258..f146b0e 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -331,10 +331,7 @@ public class CommandLineRunner extends\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = null;\n-        try {\n-          param = params.getParameter(0);\n-        } catch (CmdLineException e) {}\n+        String param = params.getParameter(0);\n \n         if (param == null) {\n           setter.addValue(true);\n"}
{"identifier": "Gson-6", "buggy_code": "  @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> fieldType, JsonAdapter annotation) {\n    Class<?> value = annotation.value();\n    TypeAdapter<?> typeAdapter;\n    if (TypeAdapter.class.isAssignableFrom(value)) {\n      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n          .construct()\n          .create(gson, fieldType);\n    } else {\n      throw new IllegalArgumentException(\n          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n    }\n      typeAdapter = typeAdapter.nullSafe();\n    return typeAdapter;\n  }\n", "fixed_code": "  @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> fieldType, JsonAdapter annotation) {\n    Class<?> value = annotation.value();\n    TypeAdapter<?> typeAdapter;\n    if (TypeAdapter.class.isAssignableFrom(value)) {\n      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n          .construct()\n          .create(gson, fieldType);\n    } else {\n      throw new IllegalArgumentException(\n          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n    }\n    if (typeAdapter != null) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n    return typeAdapter;\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n@SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n  static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> fieldType, JsonAdapter annotation)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\nindex b52e1573..30c4f6e9 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n@@ -64,9 +64,7 @@ public final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapte\n       throw new IllegalArgumentException(\n           \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n     }\n-    if (typeAdapter != null) {\n       typeAdapter = typeAdapter.nullSafe();\n-    }\n     return typeAdapter;\n   }\n }\n"}
{"identifier": "Closure-44", "buggy_code": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n      // Do not allow a forward slash to appear after a DIV.\n      // For example,\n      // REGEXP DIV REGEXP\n      // is valid and should print like\n      // / // / /\n    }\n\n    append(newcode);\n  }\n", "fixed_code": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      // Do not allow a forward slash to appear after a DIV.\n      // For example,\n      // REGEXP DIV REGEXP\n      // is valid and should print like\n      // / // / /\n      append(\" \");\n    }\n\n    append(newcode);\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid add(String newcode)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 8023324..4755665 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -191,13 +191,11 @@ abstract class CodeConsumer {\n       // need space to separate. This is not pretty printing.\n       // For example: \"return foo;\"\n       append(\" \");\n-    } else if (c == '/' && getLastChar() == '/') {\n       // Do not allow a forward slash to appear after a DIV.\n       // For example,\n       // REGEXP DIV REGEXP\n       // is valid and should print like\n       // / // / /\n-      append(\" \");\n     }\n \n     append(newcode);\n"}
{"identifier": "Chart-17", "buggy_code": "    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException not thrown by this class, but \n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n", "fixed_code": "    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException not thrown by this class, but \n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException not thrown by this class, but \n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 907fc20..ffd1dff 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -854,8 +854,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        TimeSeries clone = (TimeSeries) super.clone();\n-        clone.data = (List) ObjectUtilities.deepClone(this.data);\n+        Object clone = createCopy(0, getItemCount() - 1);\n         return clone;\n     }\n \n"}
{"identifier": "Closure-176", "buggy_code": "  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        boolean isVarDeclaration = left.hasChildren();\n\n        // When looking at VAR initializers for declared VARs, we tend\n        // to use the declared type over the type it's being\n        // initialized to in the global scope.\n        //\n        // For example,\n        // /** @param {number} */ var f = goog.abstractMethod;\n        // it's obvious that the programmer wants you to use\n        // the declared function signature, not the inferred signature.\n        //\n        // Or,\n        // /** @type {Object.<string>} */ var x = {};\n        // the one-time anonymous object on the right side\n        // is as narrow as it can possibly be, but we need to make\n        // sure we back-infer the <string> element constraint on\n        // the left hand side, so we use the left hand side.\n\n        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n            // Makes it easier to check for NPEs.\n\n        // TODO(nicksantos): This might be a better check once we have\n        // back-inference of object/array constraints.  It will probably\n        // introduce more type warnings.  It uses the result type iff it's\n        // strictly narrower than the declared var type.\n        //\n        //boolean isVarTypeBetter = isVarDeclaration &&\n        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n        //     || !resultType.isSubtype(varType));\n\n\n        if (isVarTypeBetter) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n", "fixed_code": "  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        JSType varType = var == null ? null : var.getType();\n        boolean isVarDeclaration = left.hasChildren()\n            && varType != null && !var.isTypeInferred();\n\n        // When looking at VAR initializers for declared VARs, we tend\n        // to use the declared type over the type it's being\n        // initialized to in the global scope.\n        //\n        // For example,\n        // /** @param {number} */ var f = goog.abstractMethod;\n        // it's obvious that the programmer wants you to use\n        // the declared function signature, not the inferred signature.\n        //\n        // Or,\n        // /** @type {Object.<string>} */ var x = {};\n        // the one-time anonymous object on the right side\n        // is as narrow as it can possibly be, but we need to make\n        // sure we back-infer the <string> element constraint on\n        // the left hand side, so we use the left hand side.\n\n        boolean isVarTypeBetter = isVarDeclaration &&\n            // Makes it easier to check for NPEs.\n            !resultType.isNullType() && !resultType.isVoidType();\n\n        // TODO(nicksantos): This might be a better check once we have\n        // back-inference of object/array constraints.  It will probably\n        // introduce more type warnings.  It uses the result type iff it's\n        // strictly narrower than the declared var type.\n        //\n        //boolean isVarTypeBetter = isVarDeclaration &&\n        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n        //     || !resultType.isSubtype(varType));\n\n\n        if (isVarTypeBetter) {\n          redeclareSimpleVar(scope, left, varType);\n        } else {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(resultType);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 54d429d9..c43a7d1a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -527,9 +527,7 @@ class TypeInference\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n-        JSType varType = var == null ? null : var.getType();\n-        boolean isVarDeclaration = left.hasChildren()\n-            && varType != null && !var.isTypeInferred();\n+        boolean isVarDeclaration = left.hasChildren();\n \n         // When looking at VAR initializers for declared VARs, we tend\n         // to use the declared type over the type it's being\n@@ -547,9 +545,8 @@ class TypeInference\n         // sure we back-infer the <string> element constraint on\n         // the left hand side, so we use the left hand side.\n \n-        boolean isVarTypeBetter = isVarDeclaration &&\n+        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n             // Makes it easier to check for NPEs.\n-            !resultType.isNullType() && !resultType.isVoidType();\n \n         // TODO(nicksantos): This might be a better check once we have\n         // back-inference of object/array constraints.  It will probably\n@@ -562,11 +559,10 @@ class TypeInference\n \n \n         if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, varType);\n-        } else {\n           redeclareSimpleVar(scope, left, resultType);\n         }\n-        left.setJSType(resultType);\n+        left.setJSType(isVarDeclaration || leftType == null ?\n+            resultType : null);\n \n         if (var != null && var.isTypeInferred()) {\n           JSType oldType = var.getType();\n"}
{"identifier": "JacksonDatabind-40", "buggy_code": "", "fixed_code": "        @Override\n        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n            // [databind#1095]: Should not allow coercion from into null from Empty String\n            // either, if `null` not allowed\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                throw ctxt.mappingException(\n                        \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\nindex b8ade5b1e..10954f5db 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n@@ -145,17 +145,8 @@ public class NumberDeserializers\n             return _nullValue;\n         }\n \n-        @Override\n-        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n             // [databind#1095]: Should not allow coercion from into null from Empty String\n             // either, if `null` not allowed\n-            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n-                throw ctxt.mappingException(\n-                        \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n-                        handledType().toString());\n-            }\n-            return _nullValue;\n-        }\n     }\n \n     /*\n"}
{"identifier": "Cli-25", "buggy_code": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = width - 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "fixed_code": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\n/**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex a46b0ec..028ff5c 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -822,7 +822,7 @@ public class HelpFormatter\n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = 1;\n+            nextLineTabStop = width - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n"}
{"identifier": "Lang-20", "buggy_code": null, "fixed_code": null, "prompt_strategy": "sigonly-instruct", "prompt": null, "ground_truth": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 711852e..3c2cf3f 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n"}
{"identifier": "Closure-38", "buggy_code": "  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if (x < 0 && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n", "fixed_code": "  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if ((x < 0 || negativeZero) && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n", "prompt_strategy": "sigonly-instruct", "prompt": "Please complete the following function:\n\n```java\nvoid addNumber(double x)\n```\n\nProvide the completed function inside a code block.", "ground_truth": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 3522e89..4381487 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,7 +242,7 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if ((x < 0 || negativeZero) && prev == '-') {\n+    if (x < 0 && prev == '-') {\n       add(\" \");\n     }\n \n"}
